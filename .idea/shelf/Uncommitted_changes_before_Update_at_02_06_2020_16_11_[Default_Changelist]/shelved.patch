Index: env/Lib/site-packages/pipenv/vendor/pythonfinder/__init__.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from __future__ import absolute_import, print_function\r\n\r\n# Add NullHandler to \"pythonfinder\" logger, because Python2's default root\r\n# logger has no handler and warnings like this would be reported:\r\n#\r\n# > No handlers could be found for logger \"pythonfinder.models.pyenv\"\r\nimport logging\r\n\r\nfrom .exceptions import InvalidPythonVersion\r\nfrom .models import SystemPath, WindowsFinder\r\nfrom .pythonfinder import Finder\r\n\r\n__version__ = \"1.2.2\"\r\n\r\n\r\nlogger = logging.getLogger(__name__)\r\nlogger.addHandler(logging.NullHandler())\r\n\r\n__all__ = [\"Finder\", \"WindowsFinder\", \"SystemPath\", \"InvalidPythonVersion\"]\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- env/Lib/site-packages/pipenv/vendor/pythonfinder/__init__.py	(revision 7de091c5b19e7b06e80c151f7100df6d0f893820)
+++ env/Lib/site-packages/pipenv/vendor/pythonfinder/__init__.py	(date 1591098443230)
@@ -10,7 +10,7 @@
 from .models import SystemPath, WindowsFinder
 from .pythonfinder import Finder
 
-__version__ = "1.2.2"
+__version__ = "1.2.4"
 
 
 logger = logging.getLogger(__name__)
Index: env/Lib/site-packages/pipenv/vendor/toml/LICENSE.txt
===================================================================
--- env/Lib/site-packages/pipenv/vendor/toml/LICENSE.txt	(revision 7de091c5b19e7b06e80c151f7100df6d0f893820)
+++ env/Lib/site-packages/pipenv/vendor/toml/LICENSE.txt	(revision 7de091c5b19e7b06e80c151f7100df6d0f893820)
@@ -1,27 +0,0 @@
-The MIT License
-
-Copyright 2013-2019 William Pearson
-Copyright 2015-2016 Julien Enselme
-Copyright 2016 Google Inc.
-Copyright 2017 Samuel Vasko
-Copyright 2017 Nate Prewitt
-Copyright 2017 Jack Evans
-Copyright 2019 Filippo Broggini
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-THE SOFTWARE.
\ No newline at end of file
Index: env/Lib/site-packages/pipenv-2020.5.28.dist-info/entry_points.txt
===================================================================
--- env/Lib/site-packages/pipenv-2020.5.28.dist-info/entry_points.txt	(revision 7de091c5b19e7b06e80c151f7100df6d0f893820)
+++ env/Lib/site-packages/pipenv-2020.5.28.dist-info/entry_points.txt	(revision 7de091c5b19e7b06e80c151f7100df6d0f893820)
@@ -1,4 +0,0 @@
-[console_scripts]
-pipenv = pipenv:cli
-pipenv-resolver = pipenv.resolver:main
-
Index: env/Lib/site-packages/pipenv-2020.5.28.dist-info/top_level.txt
===================================================================
--- env/Lib/site-packages/pipenv-2020.5.28.dist-info/top_level.txt	(revision 7de091c5b19e7b06e80c151f7100df6d0f893820)
+++ env/Lib/site-packages/pipenv-2020.5.28.dist-info/top_level.txt	(revision 7de091c5b19e7b06e80c151f7100df6d0f893820)
@@ -1,1 +0,0 @@
-pipenv
Index: env/Lib/site-packages/pipenv/vendor/requirementslib/__init__.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># -*- coding=utf-8 -*-\r\nfrom __future__ import absolute_import, print_function\r\n\r\nimport logging\r\nimport warnings\r\n\r\nfrom vistir.compat import ResourceWarning\r\n\r\nfrom .models.lockfile import Lockfile\r\nfrom .models.pipfile import Pipfile\r\nfrom .models.requirements import Requirement\r\n\r\n__version__ = \"1.5.9\"\r\n\r\n\r\nlogger = logging.getLogger(__name__)\r\nlogger.addHandler(logging.NullHandler())\r\nwarnings.filterwarnings(\"ignore\", category=ResourceWarning)\r\n\r\n\r\n__all__ = [\"Lockfile\", \"Pipfile\", \"Requirement\"]\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- env/Lib/site-packages/pipenv/vendor/requirementslib/__init__.py	(revision 7de091c5b19e7b06e80c151f7100df6d0f893820)
+++ env/Lib/site-packages/pipenv/vendor/requirementslib/__init__.py	(date 1591098443826)
@@ -10,7 +10,7 @@
 from .models.pipfile import Pipfile
 from .models.requirements import Requirement
 
-__version__ = "1.5.9"
+__version__ = "1.5.11"
 
 
 logger = logging.getLogger(__name__)
Index: env/Lib/site-packages/pipenv/installers.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import os\r\nimport operator\r\nimport re\r\nfrom abc import ABCMeta, abstractmethod\r\n\r\n\r\nfrom .environments import PIPENV_INSTALL_TIMEOUT\r\nfrom .vendor import attr, delegator\r\nfrom .utils import find_windows_executable\r\n\r\n\r\n@attr.s\r\nclass Version(object):\r\n\r\n    major = attr.ib()\r\n    minor = attr.ib()\r\n    patch = attr.ib()\r\n\r\n    def __str__(self):\r\n        parts = [self.major, self.minor]\r\n        if self.patch is not None:\r\n            parts.append(self.patch)\r\n        return '.'.join(str(p) for p in parts)\r\n\r\n    @classmethod\r\n    def parse(cls, name):\r\n        \"\"\"Parse an X.Y.Z or X.Y string into a version tuple.\r\n        \"\"\"\r\n        match = re.match(r'^(\\d+)\\.(\\d+)(?:\\.(\\d+))?$', name)\r\n        if not match:\r\n            raise ValueError('invalid version name {0!r}'.format(name))\r\n        major = int(match.group(1))\r\n        minor = int(match.group(2))\r\n        patch = match.group(3)\r\n        if patch is not None:\r\n            patch = int(patch)\r\n        return cls(major, minor, patch)\r\n\r\n    @property\r\n    def cmpkey(self):\r\n        \"\"\"Make the version a comparable tuple.\r\n\r\n        Some old Python versions does not have a patch part, e.g. 2.7.0 is\r\n        named \"2.7\" in pyenv. Fix that, otherwise `None` will fail to compare\r\n        with int.\r\n        \"\"\"\r\n        return (self.major, self.minor, self.patch or 0)\r\n\r\n    def matches_minor(self, other):\r\n        \"\"\"Check whether this version matches the other in (major, minor).\r\n        \"\"\"\r\n        return (self.major, self.minor) == (other.major, other.minor)\r\n\r\n\r\nclass InstallerNotFound(RuntimeError):\r\n    pass\r\n\r\n\r\nclass InstallerError(RuntimeError):\r\n    def __init__(self, desc, c):\r\n        super(InstallerError, self).__init__(desc)\r\n        self.out = c.out\r\n        self.err = c.err\r\n\r\n\r\nclass Installer(object):\r\n    __metaclass__ = ABCMeta\r\n\r\n    def __init__(self):\r\n        self.cmd = self._find_installer()\r\n        super(Installer, self).__init__()\r\n\r\n    @abstractmethod\r\n    def _find_installer(self):\r\n        pass\r\n\r\n    @staticmethod\r\n    def _find_python_installer_by_name_and_env(name, env_var):\r\n        \"\"\"\r\n        Given a python installer (pyenv or asdf), try to locate the binary for that\r\n        installer.\r\n\r\n        pyenv/asdf are not always present on PATH. Both installers also support a\r\n        custom environment variable (PYENV_ROOT or ASDF_DIR) which alows them to\r\n        be installed into a non-default location (the default/suggested source\r\n        install location is in ~/.pyenv or ~/.asdf).\r\n\r\n        For systems without the installers on PATH, and with a custom location\r\n        (e.g. /opt/pyenv), Pipenv can use those installers without modifications to\r\n        PATH, if an installer's respective environment variable is present in an\r\n        environment's .env file.\r\n\r\n        This function searches for installer binaries in the following locations,\r\n        by precedence:\r\n            1. On PATH, equivalent to which(1).\r\n            2. In the \"bin\" subdirectory of PYENV_ROOT or ASDF_DIR, depending on the\r\n               installer.\r\n            3. In ~/.pyenv/bin or ~/.asdf/bin, depending on the installer.\r\n        \"\"\"\r\n        for candidate in (\r\n            # Look for the Python installer using the equivalent of 'which'. On\r\n            # Homebrew-installed systems, the env var may not be set, but this\r\n            # strategy will work.\r\n            find_windows_executable('', name),\r\n            # Check for explicitly set install locations (e.g. PYENV_ROOT, ASDF_DIR).\r\n            os.path.join(os.path.expanduser(os.getenv(env_var, '/dev/null')), 'bin', name),\r\n            # Check the pyenv/asdf-recommended from-source install locations\r\n            os.path.join(os.path.expanduser('~/.{}'.format(name)), 'bin', name),\r\n        ):\r\n            if candidate is not None and os.path.isfile(candidate) and os.access(candidate, os.X_OK):\r\n                return candidate\r\n        raise InstallerNotFound()\r\n\r\n    def _run(self, *args, **kwargs):\r\n        timeout = kwargs.pop('timeout', delegator.TIMEOUT)\r\n        if kwargs:\r\n            k = list(kwargs.keys())[0]\r\n            raise TypeError('unexpected keyword argument {0!r}'.format(k))\r\n        args = (self.cmd,) + tuple(args)\r\n        c = delegator.run(args, block=False, timeout=timeout)\r\n        c.block()\r\n        if c.return_code != 0:\r\n            raise InstallerError('failed to run {0}'.format(args), c)\r\n        return c\r\n\r\n    @abstractmethod\r\n    def iter_installable_versions(self):\r\n        \"\"\"Iterate through CPython versions available for Pipenv to install.\r\n        \"\"\"\r\n        pass\r\n\r\n    def find_version_to_install(self, name):\r\n        \"\"\"Find a version in the installer from the version supplied.\r\n\r\n        A ValueError is raised if a matching version cannot be found.\r\n        \"\"\"\r\n        version = Version.parse(name)\r\n        if version.patch is not None:\r\n            return name\r\n        try:\r\n            best_match = max((\r\n                inst_version\r\n                for inst_version in self.iter_installable_versions()\r\n                if inst_version.matches_minor(version)\r\n            ), key=operator.attrgetter('cmpkey'))\r\n        except ValueError:\r\n            raise ValueError(\r\n                'no installable version found for {0!r}'.format(name),\r\n            )\r\n        return best_match\r\n\r\n    @abstractmethod\r\n    def install(self, version):\r\n        \"\"\"Install the given version with runner implementation.\r\n\r\n        The version must be a ``Version`` instance representing a version\r\n        found in the Installer.\r\n\r\n        A ValueError is raised if the given version does not have a match in\r\n        the runner. A InstallerError is raised if the runner command fails.\r\n        \"\"\"\r\n        pass\r\n\r\n\r\nclass Pyenv(Installer):\r\n\r\n    def _find_installer(self):\r\n        return self._find_python_installer_by_name_and_env('pyenv', 'PYENV_ROOT')\r\n\r\n    def iter_installable_versions(self):\r\n        \"\"\"Iterate through CPython versions available for Pipenv to install.\r\n        \"\"\"\r\n        for name in self._run('install', '--list').out.splitlines():\r\n            try:\r\n                version = Version.parse(name.strip())\r\n            except ValueError:\r\n                continue\r\n            yield version\r\n\r\n    def install(self, version):\r\n        \"\"\"Install the given version with pyenv.\r\n        The version must be a ``Version`` instance representing a version\r\n        found in pyenv.\r\n        A ValueError is raised if the given version does not have a match in\r\n        pyenv. A InstallerError is raised if the pyenv command fails.\r\n        \"\"\"\r\n        c = self._run(\r\n            'install', '-s', str(version),\r\n            timeout=PIPENV_INSTALL_TIMEOUT,\r\n        )\r\n        return c\r\n\r\n\r\nclass Asdf(Installer):\r\n\r\n    def _find_installer(self):\r\n        return self._find_python_installer_by_name_and_env('asdf', 'ASDF_DIR')\r\n\r\n    def iter_installable_versions(self):\r\n        \"\"\"Iterate through CPython versions available for asdf to install.\r\n        \"\"\"\r\n        for name in self._run('list-all', 'python').out.splitlines():\r\n            try:\r\n                version = Version.parse(name.strip())\r\n            except ValueError:\r\n                continue\r\n            yield version\r\n\r\n    def install(self, version):\r\n        \"\"\"Install the given version with asdf.\r\n        The version must be a ``Version`` instance representing a version\r\n        found in asdf.\r\n        A ValueError is raised if the given version does not have a match in\r\n        asdf. A InstallerError is raised if the asdf command fails.\r\n        \"\"\"\r\n        c = self._run(\r\n            'install', 'python', str(version),\r\n            timeout=PIPENV_INSTALL_TIMEOUT,\r\n        )\r\n        return c\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- env/Lib/site-packages/pipenv/installers.py	(revision 7de091c5b19e7b06e80c151f7100df6d0f893820)
+++ env/Lib/site-packages/pipenv/installers.py	(date 1591098437576)
@@ -1,6 +1,7 @@
 import os
 import operator
 import re
+import six
 from abc import ABCMeta, abstractmethod
 
 
@@ -63,13 +64,16 @@
         self.err = c.err
 
 
+@six.add_metaclass(ABCMeta)
 class Installer(object):
-    __metaclass__ = ABCMeta
 
     def __init__(self):
         self.cmd = self._find_installer()
         super(Installer, self).__init__()
 
+    def __str__(self):
+        return self.__class__.__name__
+
     @abstractmethod
     def _find_installer(self):
         pass
Index: env/Lib/site-packages/pipenv/vendor/vendor.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>appdirs==1.4.4\r\nbackports.shutil_get_terminal_size==1.0.0\r\nbackports.weakref==1.0.post1\r\nclick==7.1.2\r\nclick-completion==0.5.2\r\nclick-didyoumean==0.0.3\r\ncolorama==0.4.3\r\ndelegator.py==0.1.1\r\n    pexpect==4.8.0\r\n        ptyprocess==0.6.0\r\npython-dotenv==0.10.3\r\nfirst==2.0.1\r\niso8601==0.1.12\r\njinja2==2.11.2\r\nmarkupsafe==1.1.1\r\nparse==1.15.0\r\npathlib2==2.3.5\r\n    scandir==1.10\r\npipdeptree==0.13.2\r\npipreqs==0.4.10\r\n    docopt==0.6.2\r\n    yarg==0.1.9\r\npythonfinder==1.2.2\r\nrequests==2.23.0\r\n    chardet==3.0.4\r\n    idna==2.9\r\n    urllib3==1.25.9\r\n    certifi==2020.4.5.1\r\nrequirementslib==1.5.9\r\n    attrs==19.3.0\r\n    distlib==0.3.0\r\n    packaging==20.3\r\n    pyparsing==2.4.7\r\n    git+https://github.com/sarugaku/plette.git@master#egg=plette\r\n        tomlkit==0.5.11\r\nshellingham==1.3.2\r\nsix==1.14.0\r\nsemver==2.9.0\r\ntoml==0.10.1\r\ncached-property==1.5.1\r\nvistir==0.5.2\r\npip-shims==0.5.2\r\n    contextlib2==0.6.0.post1\r\n    funcsigs==1.0.2\r\nenum34==1.1.10\r\n# yaspin==0.15.0\r\nyaspin==0.14.3\r\ncerberus==1.3.2\r\nresolvelib==0.3.0\r\nbackports.functools_lru_cache==1.6.1\r\npep517==0.8.2\r\n    zipp==0.6.0\r\n    importlib_metadata==1.6.0\r\n    importlib-resources==1.5.0\r\n    more-itertools==5.0.0\r\ngit+https://github.com/sarugaku/passa.git@master#egg=passa\r\norderedmultidict==1.0.1\r\ndparse==0.5.0\r\npython-dateutil==2.8.1\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- env/Lib/site-packages/pipenv/vendor/vendor.txt	(revision 7de091c5b19e7b06e80c151f7100df6d0f893820)
+++ env/Lib/site-packages/pipenv/vendor/vendor.txt	(date 1591098440685)
@@ -20,18 +20,18 @@
 pipreqs==0.4.10
     docopt==0.6.2
     yarg==0.1.9
-pythonfinder==1.2.2
+pythonfinder==1.2.4
 requests==2.23.0
     chardet==3.0.4
     idna==2.9
     urllib3==1.25.9
     certifi==2020.4.5.1
-requirementslib==1.5.9
+requirementslib==1.5.11
     attrs==19.3.0
     distlib==0.3.0
     packaging==20.3
     pyparsing==2.4.7
-    git+https://github.com/sarugaku/plette.git@master#egg=plette
+    plette==0.2.3
         tomlkit==0.5.11
 shellingham==1.3.2
 six==1.14.0
Index: env/Lib/site-packages/pipenv/vendor/requirementslib/models/url.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># -*- coding=utf-8 -*-\r\nfrom __future__ import absolute_import, print_function\r\n\r\nfrom pipenv.vendor import attr\r\nimport pip_shims.shims\r\nfrom orderedmultidict import omdict\r\nfrom six.moves.urllib.parse import quote_plus, unquote_plus\r\nfrom urllib3 import util as urllib3_util\r\nfrom urllib3.util import parse_url as urllib3_parse\r\nfrom urllib3.util.url import Url\r\n\r\nfrom ..environment import MYPY_RUNNING\r\nfrom ..utils import is_installable_file\r\nfrom .utils import extras_to_string, parse_extras\r\n\r\nif MYPY_RUNNING:\r\n    from typing import Dict, List, Optional, Text, Tuple, TypeVar, Union\r\n    from pip_shims.shims import Link\r\n    from vistir.compat import Path\r\n\r\n    _T = TypeVar(\"_T\")\r\n    STRING_TYPE = Union[bytes, str, Text]\r\n    S = TypeVar(\"S\", bytes, str, Text)\r\n\r\n\r\ndef _get_parsed_url(url):\r\n    # type: (S) -> Url\r\n    \"\"\"This is a stand-in function for `urllib3.util.parse_url`\r\n\r\n    The orignal function doesn't handle special characters very well, this simply splits\r\n    out the authentication section, creates the parsed url, then puts the authentication\r\n    section back in, bypassing validation.\r\n\r\n    :return: The new, parsed URL object\r\n    :rtype: :class:`~urllib3.util.url.Url`\r\n    \"\"\"\r\n\r\n    try:\r\n        parsed = urllib3_parse(url)\r\n    except ValueError:\r\n        scheme, _, url = url.partition(\"://\")\r\n        auth, _, url = url.rpartition(\"@\")\r\n        url = \"{scheme}://{url}\".format(scheme=scheme, url=url)\r\n        parsed = urllib3_parse(url)._replace(auth=auth)\r\n    if parsed.auth and unquote_plus(parsed.auth) != parsed.auth:\r\n        return parsed._replace(auth=unquote_plus(parsed.auth))\r\n    return parsed\r\n\r\n\r\ndef remove_password_from_url(url):\r\n    # type: (S) -> S\r\n    \"\"\"Given a url, remove the password and insert 4 dashes.\r\n\r\n    :param url: The url to replace the authentication in\r\n    :type url: S\r\n    :return: The new URL without authentication\r\n    :rtype: S\r\n    \"\"\"\r\n\r\n    parsed = _get_parsed_url(url)\r\n    if parsed.auth:\r\n        auth, _, _ = parsed.auth.partition(\":\")\r\n        return parsed._replace(auth=\"{auth}:----\".format(auth=auth)).url\r\n    return parsed.url\r\n\r\n\r\n@attr.s(hash=True)\r\nclass URI(object):\r\n    #: The target hostname, e.g. `amazon.com`\r\n    host = attr.ib(type=str)\r\n    #: The URI Scheme, e.g. `salesforce`\r\n    scheme = attr.ib(default=\"https\", type=str)\r\n    #: The numeric port of the url if specified\r\n    port = attr.ib(default=None, type=int)\r\n    #: The url path, e.g. `/path/to/endpoint`\r\n    path = attr.ib(default=\"\", type=str)\r\n    #: Query parameters, e.g. `?variable=value...`\r\n    query = attr.ib(default=\"\", type=str)\r\n    #: URL Fragments, e.g. `#fragment=value`\r\n    fragment = attr.ib(default=\"\", type=str)\r\n    #: Subdirectory fragment, e.g. `&subdirectory=blah...`\r\n    subdirectory = attr.ib(default=\"\", type=str)\r\n    #: VCS ref this URI points at, if available\r\n    ref = attr.ib(default=\"\", type=str)\r\n    #: The username if provided, parsed from `user:password@hostname`\r\n    username = attr.ib(default=\"\", type=str)\r\n    #: Password parsed from `user:password@hostname`\r\n    password = attr.ib(default=\"\", type=str, repr=False)\r\n    #: An orderedmultidict representing query fragments\r\n    query_dict = attr.ib(factory=omdict, type=omdict)\r\n    #: The name of the specified package in case it is a VCS URI with an egg fragment\r\n    name = attr.ib(default=\"\", type=str)\r\n    #: Any extras requested from the requirement\r\n    extras = attr.ib(factory=tuple, type=tuple)\r\n    #: Whether the url was parsed as a direct pep508-style URL\r\n    is_direct_url = attr.ib(default=False, type=bool)\r\n    #: Whether the url was an implicit `git+ssh` url (passed as `git+git@`)\r\n    is_implicit_ssh = attr.ib(default=False, type=bool)\r\n    _auth = attr.ib(default=None, type=str, repr=False)\r\n    _fragment_dict = attr.ib(factory=dict, type=dict)\r\n    _username_is_quoted = attr.ib(type=bool, default=False)\r\n    _password_is_quoted = attr.ib(type=bool, default=False)\r\n\r\n    def _parse_query(self):\r\n        # type: () -> URI\r\n        query = self.query if self.query is not None else \"\"\r\n        query_dict = omdict()\r\n        queries = query.split(\"&\")\r\n        query_items = []\r\n        subdirectory = self.subdirectory if self.subdirectory else None\r\n        for q in queries:\r\n            key, _, val = q.partition(\"=\")\r\n            val = unquote_plus(val.replace(\"+\", \" \"))\r\n            if key == \"subdirectory\" and not subdirectory:\r\n                subdirectory = val\r\n            else:\r\n                query_items.append((key, val))\r\n        query_dict.load(query_items)\r\n        return attr.evolve(\r\n            self, query_dict=query_dict, subdirectory=subdirectory, query=query\r\n        )\r\n\r\n    def _parse_fragment(self):\r\n        # type: () -> URI\r\n        subdirectory = self.subdirectory if self.subdirectory else \"\"\r\n        fragment = self.fragment if self.fragment else \"\"\r\n        if self.fragment is None:\r\n            return self\r\n        fragments = self.fragment.split(\"&\")\r\n        fragment_items = {}\r\n        name = self.name if self.name else \"\"\r\n        extras = self.extras\r\n        for q in fragments:\r\n            key, _, val = q.partition(\"=\")\r\n            val = unquote_plus(val.replace(\"+\", \" \"))\r\n            fragment_items[key] = val\r\n            if key == \"egg\":\r\n                from .utils import parse_extras\r\n\r\n                name, stripped_extras = pip_shims.shims._strip_extras(val)\r\n                if stripped_extras:\r\n                    extras = tuple(parse_extras(stripped_extras))\r\n            elif key == \"subdirectory\":\r\n                subdirectory = val\r\n        return attr.evolve(\r\n            self,\r\n            fragment_dict=fragment_items,\r\n            subdirectory=subdirectory,\r\n            fragment=fragment,\r\n            extras=extras,\r\n            name=name,\r\n        )\r\n\r\n    def _parse_auth(self):\r\n        # type: () -> URI\r\n        if self._auth:\r\n            username, _, password = self._auth.partition(\":\")\r\n            username_is_quoted, password_is_quoted = False, False\r\n            quoted_username, quoted_password = \"\", \"\"\r\n            if password:\r\n                quoted_password = quote_plus(password)\r\n                password_is_quoted = quoted_password != password\r\n            if username:\r\n                quoted_username = quote_plus(username)\r\n                username_is_quoted = quoted_username != username\r\n            return attr.evolve(\r\n                self,\r\n                username=quoted_username,\r\n                password=quoted_password,\r\n                username_is_quoted=username_is_quoted,\r\n                password_is_quoted=password_is_quoted,\r\n            )\r\n        return self\r\n\r\n    def get_password(self, unquote=False, include_token=True):\r\n        # type: (bool, bool) -> str\r\n        password = self.password if self.password else \"\"\r\n        if password and unquote and self._password_is_quoted:\r\n            password = unquote_plus(password)\r\n        return password\r\n\r\n    def get_username(self, unquote=False):\r\n        # type: (bool) -> str\r\n        username = self.username if self.username else \"\"\r\n        if username and unquote and self._username_is_quoted:\r\n            username = unquote_plus(username)\r\n        return username\r\n\r\n    @staticmethod\r\n    def parse_subdirectory(url_part):\r\n        # type: (str) -> Tuple[str, Optional[str]]\r\n        subdir = None\r\n        if \"&subdirectory\" in url_part:\r\n            url_part, _, subdir = url_part.rpartition(\"&\")\r\n            if \"#egg=\" not in url_part:\r\n                subdir = \"#{0}\".format(subdir.strip())\r\n            else:\r\n                subdir = \"&{0}\".format(subdir.strip())\r\n        return url_part.strip(), subdir\r\n\r\n    @classmethod\r\n    def get_parsed_url(cls, url):\r\n        # if there is a \"#\" in the auth section, this could break url parsing\r\n        parsed_url = _get_parsed_url(url)\r\n        if \"@\" in url and \"#\" in url:\r\n            scheme = \"{0}://\".format(parsed_url.scheme)\r\n            if parsed_url.scheme == \"file\":\r\n                scheme = \"{0}/\".format(scheme)\r\n            url_without_scheme = url.replace(scheme, \"\")\r\n            maybe_auth, _, maybe_url = url_without_scheme.partition(\"@\")\r\n            if \"#\" in maybe_auth and (not parsed_url.host or \".\" not in parsed_url.host):\r\n                new_parsed_url = _get_parsed_url(\"{0}{1}\".format(scheme, maybe_url))\r\n                new_parsed_url = new_parsed_url._replace(auth=maybe_auth)\r\n                return new_parsed_url\r\n        return parsed_url\r\n\r\n    @classmethod\r\n    def parse(cls, url):\r\n        # type: (S) -> URI\r\n        from .utils import DIRECT_URL_RE, split_ref_from_uri\r\n\r\n        is_direct_url = False\r\n        name_with_extras = None\r\n        is_implicit_ssh = url.strip().startswith(\"git+git@\")\r\n        if is_implicit_ssh:\r\n            from ..utils import add_ssh_scheme_to_git_uri\r\n\r\n            url = add_ssh_scheme_to_git_uri(url)\r\n        direct_match = DIRECT_URL_RE.match(url)\r\n        if direct_match is not None:\r\n            is_direct_url = True\r\n            name_with_extras, _, url = url.partition(\"@\")\r\n            name_with_extras = name_with_extras.strip()\r\n        url, ref = split_ref_from_uri(url.strip())\r\n        if \"file:/\" in url and \"file:///\" not in url:\r\n            url = url.replace(\"file:/\", \"file:///\")\r\n        parsed = cls.get_parsed_url(url)\r\n        # if there is a \"#\" in the auth section, this could break url parsing\r\n        if not (parsed.scheme and parsed.host):\r\n            # check if this is a file uri\r\n            if not (\r\n                parsed.scheme\r\n                and parsed.path\r\n                and (parsed.scheme == \"file\" or parsed.scheme.endswith(\"+file\"))\r\n            ):\r\n                raise ValueError(\"Failed parsing URL {0!r} - Not a valid url\".format(url))\r\n        parsed_dict = dict(parsed._asdict()).copy()\r\n        parsed_dict[\"is_direct_url\"] = is_direct_url\r\n        parsed_dict[\"is_implicit_ssh\"] = is_implicit_ssh\r\n        parsed_dict.update(\r\n            **update_url_name_and_fragment(name_with_extras, ref, parsed_dict)\r\n        )  # type: ignore\r\n        return cls(**parsed_dict)._parse_auth()._parse_query()._parse_fragment()\r\n\r\n    def to_string(\r\n        self,\r\n        escape_password=True,  # type: bool\r\n        unquote=True,  # type: bool\r\n        direct=None,  # type: Optional[bool]\r\n        strip_ssh=False,  # type: bool\r\n        strip_ref=False,  # type: bool\r\n        strip_name=False,  # type: bool\r\n        strip_subdir=False,  # type: bool\r\n    ):\r\n        # type: (...) -> str\r\n        \"\"\"Converts the current URI to a string, unquoting or escaping the\r\n        password as needed.\r\n\r\n        :param escape_password: Whether to replace password with ``----``, default True\r\n        :param escape_password: bool, optional\r\n        :param unquote: Whether to unquote url-escapes in the password, default False\r\n        :param unquote: bool, optional\r\n        :param bool direct: Whether to format as a direct URL\r\n        :param bool strip_ssh: Whether to strip the SSH scheme from the url (git only)\r\n        :param bool strip_ref: Whether to drop the VCS ref (if present)\r\n        :param bool strip_name: Whether to drop the name and extras (if present)\r\n        :param bool strip_subdir: Whether to drop the subdirectory (if present)\r\n        :return: The reconstructed string representing the URI\r\n        :rtype: str\r\n        \"\"\"\r\n\r\n        if direct is None:\r\n            direct = self.is_direct_url\r\n        if escape_password:\r\n            password = \"----\" if self.password else \"\"\r\n            if password:\r\n                username = self.get_username(unquote=unquote)\r\n            elif self.username:\r\n                username = \"----\"\r\n            else:\r\n                username = \"\"\r\n        else:\r\n            password = self.get_password(unquote=unquote)\r\n            username = self.get_username(unquote=unquote)\r\n        auth = \"\"\r\n        if username:\r\n            if password:\r\n                auth = \"{username}:{password}@\".format(\r\n                    password=password, username=username\r\n                )\r\n            else:\r\n                auth = \"{username}@\".format(username=username)\r\n        query = \"\"\r\n        if self.query:\r\n            query = \"{query}?{self.query}\".format(query=query, self=self)\r\n        subdir_prefix = \"#\"\r\n        if not direct:\r\n            if self.name and not strip_name:\r\n                fragment = \"#egg={self.name_with_extras}\".format(self=self)\r\n                subdir_prefix = \"&\"\r\n            elif not strip_name and (\r\n                self.extras and self.scheme and self.scheme.startswith(\"file\")\r\n            ):\r\n                from .utils import extras_to_string\r\n\r\n                fragment = extras_to_string(self.extras)\r\n            else:\r\n                fragment = \"\"\r\n            query = \"{query}{fragment}\".format(query=query, fragment=fragment)\r\n        if self.subdirectory and not strip_subdir:\r\n            query = \"{query}{subdir_prefix}subdirectory={self.subdirectory}\".format(\r\n                query=query, subdir_prefix=subdir_prefix, self=self\r\n            )\r\n        host_port_path = self.get_host_port_path(strip_ref=strip_ref)\r\n        url = \"{self.scheme}://{auth}{host_port_path}{query}\".format(\r\n            self=self, auth=auth, host_port_path=host_port_path, query=query\r\n        )\r\n        if strip_ssh:\r\n            from ..utils import strip_ssh_from_git_uri\r\n\r\n            url = strip_ssh_from_git_uri(url)\r\n        if self.name and direct and not strip_name:\r\n            return \"{self.name_with_extras}@ {url}\".format(self=self, url=url)\r\n        return url\r\n\r\n    def get_host_port_path(self, strip_ref=False):\r\n        # type: (bool) -> str\r\n        host = self.host if self.host else \"\"\r\n        if self.port is not None:\r\n            host = \"{host}:{self.port!s}\".format(host=host, self=self)\r\n        path = \"{self.path}\".format(self=self) if self.path else \"\"\r\n        if self.ref and not strip_ref:\r\n            path = \"{path}@{self.ref}\".format(path=path, self=self)\r\n        return \"{host}{path}\".format(host=host, path=path)\r\n\r\n    @property\r\n    def hidden_auth(self):\r\n        # type: () -> str\r\n        auth = \"\"\r\n        if self.username and self.password:\r\n            password = \"****\"\r\n            username = self.get_username(unquote=True)\r\n            auth = \"{username}:{password}\".format(username=username, password=password)\r\n        elif self.username and not self.password:\r\n            auth = \"****\"\r\n        return auth\r\n\r\n    @property\r\n    def name_with_extras(self):\r\n        # type: () -> str\r\n        from .utils import extras_to_string\r\n\r\n        if not self.name:\r\n            return \"\"\r\n        extras = extras_to_string(self.extras)\r\n        return \"{self.name}{extras}\".format(self=self, extras=extras)\r\n\r\n    @property\r\n    def as_link(self):\r\n        # type: () -> Link\r\n        link = pip_shims.shims.Link(\r\n            self.to_string(escape_password=False, strip_ssh=False, direct=False)\r\n        )\r\n        return link\r\n\r\n    @property\r\n    def bare_url(self):\r\n        # type: () -> str\r\n        return self.to_string(\r\n            escape_password=False,\r\n            strip_ssh=self.is_implicit_ssh,\r\n            direct=False,\r\n            strip_name=True,\r\n            strip_ref=True,\r\n            strip_subdir=True,\r\n        )\r\n\r\n    @property\r\n    def url_without_fragment_or_ref(self):\r\n        # type: () -> str\r\n        return self.to_string(\r\n            escape_password=False,\r\n            strip_ssh=self.is_implicit_ssh,\r\n            direct=False,\r\n            strip_name=True,\r\n            strip_ref=True,\r\n        )\r\n\r\n    @property\r\n    def url_without_fragment(self):\r\n        # type: () -> str\r\n        return self.to_string(\r\n            escape_password=False,\r\n            strip_ssh=self.is_implicit_ssh,\r\n            direct=False,\r\n            strip_name=True,\r\n        )\r\n\r\n    @property\r\n    def url_without_ref(self):\r\n        # type: () -> str\r\n        return self.to_string(\r\n            escape_password=False,\r\n            strip_ssh=self.is_implicit_ssh,\r\n            direct=False,\r\n            strip_ref=True,\r\n        )\r\n\r\n    @property\r\n    def base_url(self):\r\n        # type: () -> str\r\n        return self.to_string(\r\n            escape_password=False,\r\n            strip_ssh=self.is_implicit_ssh,\r\n            direct=False,\r\n            unquote=False,\r\n        )\r\n\r\n    @property\r\n    def full_url(self):\r\n        # type: () -> str\r\n        return self.to_string(escape_password=False, strip_ssh=False, direct=False)\r\n\r\n    @property\r\n    def secret(self):\r\n        # type: () -> str\r\n        return self.full_url\r\n\r\n    @property\r\n    def safe_string(self):\r\n        # type: () -> str\r\n        return self.to_string(escape_password=True, unquote=True)\r\n\r\n    @property\r\n    def unsafe_string(self):\r\n        # type: () -> str\r\n        return self.to_string(escape_password=False, unquote=True)\r\n\r\n    @property\r\n    def uri_escape(self):\r\n        # type: () -> str\r\n        return self.to_string(escape_password=False, unquote=False)\r\n\r\n    @property\r\n    def is_installable(self):\r\n        # type: () -> bool\r\n        return self.is_file_url and is_installable_file(self.bare_url)\r\n\r\n    @property\r\n    def is_vcs(self):\r\n        # type: () -> bool\r\n        from ..utils import VCS_SCHEMES\r\n\r\n        return self.scheme in VCS_SCHEMES\r\n\r\n    @property\r\n    def is_file_url(self):\r\n        # type: () -> bool\r\n        return all([self.scheme, self.scheme == \"file\"])\r\n\r\n    def __str__(self):\r\n        # type: () -> str\r\n        return self.to_string(escape_password=True, unquote=True)\r\n\r\n\r\ndef update_url_name_and_fragment(name_with_extras, ref, parsed_dict):\r\n    # type: (Optional[str], Optional[str], Dict[str, Optional[str]]) -> Dict[str, Optional[str]]\r\n    if name_with_extras:\r\n        fragment = \"\"  # type: Optional[str]\r\n        parsed_extras = ()\r\n        name, extras = pip_shims.shims._strip_extras(name_with_extras)\r\n        if extras:\r\n            parsed_extras = parsed_extras + tuple(parse_extras(extras))\r\n        if parsed_dict[\"fragment\"] is not None:\r\n            fragment = \"{0}\".format(parsed_dict[\"fragment\"])\r\n            if fragment.startswith(\"egg=\"):\r\n                _, _, fragment_part = fragment.partition(\"=\")\r\n                fragment_name, fragment_extras = pip_shims.shims._strip_extras(\r\n                    fragment_part\r\n                )\r\n                name = name if name else fragment_name\r\n                if fragment_extras:\r\n                    parsed_extras = parsed_extras + tuple(parse_extras(fragment_extras))\r\n                name_with_extras = \"{0}{1}\".format(name, extras_to_string(parsed_extras))\r\n        elif (\r\n            parsed_dict.get(\"path\") is not None and \"&subdirectory\" in parsed_dict[\"path\"]\r\n        ):\r\n            path, fragment = URI.parse_subdirectory(parsed_dict[\"path\"])  # type: ignore\r\n            parsed_dict[\"path\"] = path\r\n        elif ref is not None and \"&subdirectory\" in ref:\r\n            ref, fragment = URI.parse_subdirectory(ref)\r\n        parsed_dict[\"name\"] = name\r\n        parsed_dict[\"extras\"] = parsed_extras\r\n    if ref:\r\n        parsed_dict[\"ref\"] = ref.strip()\r\n    return parsed_dict\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- env/Lib/site-packages/pipenv/vendor/requirementslib/models/url.py	(revision 7de091c5b19e7b06e80c151f7100df6d0f893820)
+++ env/Lib/site-packages/pipenv/vendor/requirementslib/models/url.py	(date 1591098443929)
@@ -4,7 +4,7 @@
 from pipenv.vendor import attr
 import pip_shims.shims
 from orderedmultidict import omdict
-from six.moves.urllib.parse import quote_plus, unquote_plus
+from six.moves.urllib.parse import quote, unquote_plus, unquote as url_unquote
 from urllib3 import util as urllib3_util
 from urllib3.util import parse_url as urllib3_parse
 from urllib3.util.url import Url
@@ -42,8 +42,8 @@
         auth, _, url = url.rpartition("@")
         url = "{scheme}://{url}".format(scheme=scheme, url=url)
         parsed = urllib3_parse(url)._replace(auth=auth)
-    if parsed.auth and unquote_plus(parsed.auth) != parsed.auth:
-        return parsed._replace(auth=unquote_plus(parsed.auth))
+    if parsed.auth:
+        return parsed._replace(auth=url_unquote(parsed.auth))
     return parsed
 
 
@@ -110,7 +110,7 @@
         subdirectory = self.subdirectory if self.subdirectory else None
         for q in queries:
             key, _, val = q.partition("=")
-            val = unquote_plus(val.replace("+", " "))
+            val = unquote_plus(val)
             if key == "subdirectory" and not subdirectory:
                 subdirectory = val
             else:
@@ -132,7 +132,7 @@
         extras = self.extras
         for q in fragments:
             key, _, val = q.partition("=")
-            val = unquote_plus(val.replace("+", " "))
+            val = unquote_plus(val)
             fragment_items[key] = val
             if key == "egg":
                 from .utils import parse_extras
@@ -158,10 +158,10 @@
             username_is_quoted, password_is_quoted = False, False
             quoted_username, quoted_password = "", ""
             if password:
-                quoted_password = quote_plus(password)
+                quoted_password = quote(password)
                 password_is_quoted = quoted_password != password
             if username:
-                quoted_username = quote_plus(username)
+                quoted_username = quote(username)
                 username_is_quoted = quoted_username != username
             return attr.evolve(
                 self,
@@ -176,14 +176,14 @@
         # type: (bool, bool) -> str
         password = self.password if self.password else ""
         if password and unquote and self._password_is_quoted:
-            password = unquote_plus(password)
+            password = url_unquote(password)
         return password
 
     def get_username(self, unquote=False):
         # type: (bool) -> str
         username = self.username if self.username else ""
         if username and unquote and self._username_is_quoted:
-            username = unquote_plus(username)
+            username = url_unquote(username)
         return username
 
     @staticmethod
Index: env/Lib/site-packages/pipenv/vendor/requirementslib/models/setup_info.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># -*- coding=utf-8 -*-\r\nfrom __future__ import absolute_import, print_function\r\n\r\nimport ast\r\nimport atexit\r\nimport contextlib\r\nimport importlib\r\nimport io\r\nimport operator\r\nimport os\r\nimport shutil\r\nimport sys\r\nfrom functools import partial\r\n\r\nfrom pipenv.vendor import attr\r\nimport chardet\r\nimport packaging.specifiers\r\nimport packaging.utils\r\nimport packaging.version\r\nimport pep517.envbuild\r\nimport pep517.wrappers\r\nimport six\r\nfrom appdirs import user_cache_dir\r\nfrom distlib.wheel import Wheel\r\nfrom packaging.markers import Marker\r\nfrom pip_shims.utils import call_function_with_correct_args\r\nfrom six.moves import configparser\r\nfrom six.moves.urllib.parse import unquote, urlparse, urlunparse\r\nfrom vistir.compat import FileNotFoundError, Iterable, Mapping, Path, finalize, lru_cache\r\nfrom vistir.contextmanagers import cd, temp_path\r\nfrom vistir.misc import run\r\nfrom vistir.path import create_tracked_tempdir, ensure_mkdir_p, mkdir_p, rmtree\r\n\r\nfrom ..environment import MYPY_RUNNING\r\nfrom ..exceptions import RequirementError\r\nfrom .utils import (\r\n    get_default_pyproject_backend,\r\n    get_name_variants,\r\n    get_pyproject,\r\n    init_requirement,\r\n    read_source,\r\n    split_vcs_method_from_uri,\r\n    strip_extras_markers_from_requirement,\r\n)\r\n\r\ntry:\r\n    import pkg_resources.extern.packaging.requirements as pkg_resources_requirements\r\nexcept ImportError:\r\n    pkg_resources_requirements = None\r\n\r\ntry:\r\n    from setuptools.dist import distutils, Distribution\r\nexcept ImportError:\r\n    import distutils\r\n    from distutils.core import Distribution\r\n\r\ntry:\r\n    from contextlib import ExitStack\r\nexcept ImportError:\r\n    from contextlib2 import ExitStack\r\n\r\ntry:\r\n    from os import scandir\r\nexcept ImportError:\r\n    from scandir import scandir\r\n\r\n\r\nif MYPY_RUNNING:\r\n    from typing import (\r\n        Any,\r\n        Callable,\r\n        Dict,\r\n        List,\r\n        Generator,\r\n        Optional,\r\n        Union,\r\n        Tuple,\r\n        TypeVar,\r\n        Text,\r\n        Set,\r\n        AnyStr,\r\n        Sequence,\r\n    )\r\n    import requests\r\n    from pip_shims.shims import InstallRequirement, PackageFinder\r\n    from pkg_resources import (\r\n        PathMetadata,\r\n        DistInfoDistribution,\r\n        EggInfoDistribution,\r\n        Requirement as PkgResourcesRequirement,\r\n    )\r\n    from packaging.requirements import Requirement as PackagingRequirement\r\n\r\n    TRequirement = TypeVar(\"TRequirement\")\r\n    RequirementType = TypeVar(\r\n        \"RequirementType\", covariant=True, bound=PackagingRequirement\r\n    )\r\n    MarkerType = TypeVar(\"MarkerType\", covariant=True, bound=Marker)\r\n    STRING_TYPE = Union[str, bytes, Text]\r\n    S = TypeVar(\"S\", bytes, str, Text)\r\n    AST_SEQ = TypeVar(\"AST_SEQ\", ast.Tuple, ast.List)\r\n\r\n\r\nCACHE_DIR = os.environ.get(\"PIPENV_CACHE_DIR\", user_cache_dir(\"pipenv\"))\r\n\r\n# The following are necessary for people who like to use \"if __name__\" conditionals\r\n# in their setup.py scripts\r\n_setup_stop_after = None\r\n_setup_distribution = None\r\n\r\n\r\ndef pep517_subprocess_runner(cmd, cwd=None, extra_environ=None):\r\n    # type: (List[AnyStr], Optional[AnyStr], Optional[Mapping[S, S]]) -> None\r\n    \"\"\"The default method of calling the wrapper subprocess.\"\"\"\r\n    env = os.environ.copy()\r\n    if extra_environ:\r\n        env.update(extra_environ)\r\n\r\n    run(\r\n        cmd,\r\n        cwd=cwd,\r\n        env=env,\r\n        block=True,\r\n        combine_stderr=True,\r\n        return_object=False,\r\n        write_to_stdout=False,\r\n        nospin=True,\r\n    )\r\n\r\n\r\nclass BuildEnv(pep517.envbuild.BuildEnvironment):\r\n    def pip_install(self, reqs):\r\n        cmd = [\r\n            sys.executable,\r\n            \"-m\",\r\n            \"pip\",\r\n            \"install\",\r\n            \"--ignore-installed\",\r\n            \"--prefix\",\r\n            self.path,\r\n        ] + list(reqs)\r\n        run(\r\n            cmd,\r\n            block=True,\r\n            combine_stderr=True,\r\n            return_object=False,\r\n            write_to_stdout=False,\r\n            nospin=True,\r\n        )\r\n\r\n\r\nclass HookCaller(pep517.wrappers.Pep517HookCaller):\r\n    def __init__(self, source_dir, build_backend, backend_path=None):\r\n        self.source_dir = os.path.abspath(source_dir)\r\n        self.build_backend = build_backend\r\n        self._subprocess_runner = pep517_subprocess_runner\r\n        if backend_path:\r\n            backend_path = [\r\n                pep517.wrappers.norm_and_check(self.source_dir, p) for p in backend_path\r\n            ]\r\n        self.backend_path = backend_path\r\n\r\n\r\ndef parse_special_directives(setup_entry, package_dir=None):\r\n    # type: (S, Optional[STRING_TYPE]) -> S\r\n    rv = setup_entry\r\n    if not package_dir:\r\n        package_dir = os.getcwd()\r\n    if setup_entry.startswith(\"file:\"):\r\n        _, path = setup_entry.split(\"file:\")\r\n        path = path.strip()\r\n        if os.path.exists(path):\r\n            rv = read_source(path)\r\n    elif setup_entry.startswith(\"attr:\"):\r\n        _, resource = setup_entry.split(\"attr:\")\r\n        resource = resource.strip()\r\n        with temp_path():\r\n            sys.path.insert(0, package_dir)\r\n            if \".\" in resource:\r\n                resource, _, attribute = resource.rpartition(\".\")\r\n            package, _, path = resource.partition(\".\")\r\n            base_path = os.path.join(package_dir, package)\r\n            if path:\r\n                path = os.path.join(base_path, os.path.join(*path.split(\".\")))\r\n            else:\r\n                path = base_path\r\n            if not os.path.exists(path) and os.path.exists(\"{0}.py\".format(path)):\r\n                path = \"{0}.py\".format(path)\r\n            elif os.path.isdir(path):\r\n                path = os.path.join(path, \"__init__.py\")\r\n            rv = ast_parse_attribute_from_file(path, attribute)\r\n            if rv:\r\n                return str(rv)\r\n            module = importlib.import_module(resource)\r\n            rv = getattr(module, attribute)\r\n            if not isinstance(rv, six.string_types):\r\n                rv = str(rv)\r\n    return rv\r\n\r\n\r\ndef make_base_requirements(reqs):\r\n    # type: (Sequence[STRING_TYPE]) -> Set[BaseRequirement]\r\n    requirements = set()\r\n    if not isinstance(reqs, (list, tuple, set)):\r\n        reqs = [reqs]\r\n    for req in reqs:\r\n        if isinstance(req, BaseRequirement):\r\n            requirements.add(req)\r\n        elif pkg_resources_requirements is not None and isinstance(\r\n            req, pkg_resources_requirements.Requirement\r\n        ):\r\n            requirements.add(BaseRequirement.from_req(req))\r\n        elif req and isinstance(req, six.string_types) and not req.startswith(\"#\"):\r\n            requirements.add(BaseRequirement.from_string(req))\r\n    return requirements\r\n\r\n\r\ndef setuptools_parse_setup_cfg(path):\r\n    from setuptools.config import read_configuration\r\n\r\n    parsed = read_configuration(path)\r\n    results = parsed.get(\"metadata\", {})\r\n    results.update(parsed.get(\"options\", {}))\r\n    results[\"install_requires\"] = make_base_requirements(\r\n        results.get(\"install_requires\", [])\r\n    )\r\n    extras = {}\r\n    for extras_section, extras_reqs in results.get(\"extras_require\", {}).items():\r\n        new_reqs = tuple(make_base_requirements(extras_reqs))\r\n        if new_reqs:\r\n            extras[extras_section] = new_reqs\r\n    results[\"extras_require\"] = extras\r\n    results[\"setup_requires\"] = make_base_requirements(results.get(\"setup_requires\", []))\r\n    return results\r\n\r\n\r\ndef get_package_dir_from_setupcfg(parser, base_dir=None):\r\n    # type: (configparser.ConfigParser, STRING_TYPE) -> Text\r\n    if base_dir is not None:\r\n        package_dir = base_dir\r\n    else:\r\n        package_dir = os.getcwd()\r\n    if parser.has_option(\"options.packages.find\", \"where\"):\r\n        pkg_dir = parser.get(\"options.packages.find\", \"where\")\r\n        if isinstance(pkg_dir, Mapping):\r\n            pkg_dir = pkg_dir.get(\"where\")\r\n        package_dir = os.path.join(package_dir, pkg_dir)\r\n    elif parser.has_option(\"options\", \"packages\"):\r\n        pkg_dir = parser.get(\"options\", \"packages\")\r\n        if \"find:\" in pkg_dir:\r\n            _, pkg_dir = pkg_dir.split(\"find:\")\r\n            pkg_dir = pkg_dir.strip()\r\n        package_dir = os.path.join(package_dir, pkg_dir)\r\n    elif os.path.exists(os.path.join(package_dir, \"setup.py\")):\r\n        setup_py = ast_parse_setup_py(os.path.join(package_dir, \"setup.py\"))\r\n        if \"package_dir\" in setup_py:\r\n            package_lookup = setup_py[\"package_dir\"]\r\n            if not isinstance(package_lookup, Mapping):\r\n                package_dir = package_lookup\r\n            package_dir = package_lookup.get(\r\n                next(iter(list(package_lookup.keys()))), package_dir\r\n            )\r\n    if not os.path.isabs(package_dir):\r\n        if not base_dir:\r\n            package_dir = os.path.join(os.path.getcwd(), package_dir)\r\n        else:\r\n            package_dir = os.path.join(base_dir, package_dir)\r\n    return package_dir\r\n\r\n\r\ndef get_name_and_version_from_setupcfg(parser, package_dir):\r\n    # type: (configparser.ConfigParser, STRING_TYPE) -> Tuple[Optional[S], Optional[S]]\r\n    name, version = None, None\r\n    if parser.has_option(\"metadata\", \"name\"):\r\n        name = parse_special_directives(parser.get(\"metadata\", \"name\"), package_dir)\r\n    if parser.has_option(\"metadata\", \"version\"):\r\n        version = parse_special_directives(parser.get(\"metadata\", \"version\"), package_dir)\r\n    return name, version\r\n\r\n\r\ndef get_extras_from_setupcfg(parser):\r\n    # type: (configparser.ConfigParser) -> Dict[STRING_TYPE, Tuple[BaseRequirement, ...]]\r\n    extras = {}  # type: Dict[STRING_TYPE, Tuple[BaseRequirement, ...]]\r\n    if \"options.extras_require\" not in parser.sections():\r\n        return extras\r\n    extras_require_section = parser.options(\"options.extras_require\")\r\n    for section in extras_require_section:\r\n        if section in [\"options\", \"metadata\"]:\r\n            continue\r\n        section_contents = parser.get(\"options.extras_require\", section)\r\n        section_list = section_contents.split(\"\\n\")\r\n        section_extras = tuple(make_base_requirements(section_list))\r\n        if section_extras:\r\n            extras[section] = section_extras\r\n    return extras\r\n\r\n\r\ndef parse_setup_cfg(\r\n    setup_cfg_contents,  # type: S\r\n    base_dir,  # type: S\r\n):\r\n    # type: (...) -> Dict[S, Union[S, None, Set[BaseRequirement], List[S], Dict[STRING_TYPE, Tuple[BaseRequirement]]]]\r\n    default_opts = {\r\n        \"metadata\": {\"name\": \"\", \"version\": \"\"},\r\n        \"options\": {\r\n            \"install_requires\": \"\",\r\n            \"python_requires\": \"\",\r\n            \"build_requires\": \"\",\r\n            \"setup_requires\": \"\",\r\n            \"extras\": \"\",\r\n            \"packages.find\": {\"where\": \".\"},\r\n        },\r\n    }\r\n    parser = configparser.ConfigParser(default_opts)\r\n    if six.PY2:\r\n        buff = io.BytesIO(setup_cfg_contents)\r\n        parser.readfp(buff)\r\n    else:\r\n        parser.read_string(setup_cfg_contents)\r\n    results = {}\r\n    package_dir = get_package_dir_from_setupcfg(parser, base_dir=base_dir)\r\n    name, version = get_name_and_version_from_setupcfg(parser, package_dir)\r\n    results[\"name\"] = name\r\n    results[\"version\"] = version\r\n    install_requires = set()  # type: Set[BaseRequirement]\r\n    if parser.has_option(\"options\", \"install_requires\"):\r\n        install_requires = make_base_requirements(\r\n            parser.get(\"options\", \"install_requires\").split(\"\\n\")\r\n        )\r\n    results[\"install_requires\"] = install_requires\r\n    if parser.has_option(\"options\", \"python_requires\"):\r\n        results[\"python_requires\"] = parse_special_directives(\r\n            parser.get(\"options\", \"python_requires\"), package_dir\r\n        )\r\n    if parser.has_option(\"options\", \"build_requires\"):\r\n        results[\"build_requires\"] = parser.get(\"options\", \"build_requires\")\r\n    results[\"extras_require\"] = get_extras_from_setupcfg(parser)\r\n    return results\r\n\r\n\r\n@contextlib.contextmanager\r\ndef _suppress_distutils_logs():\r\n    # type: () -> Generator[None, None, None]\r\n    \"\"\"Hack to hide noise generated by `setup.py develop`.\r\n\r\n    There isn't a good way to suppress them now, so let's monky-patch.\r\n    See https://bugs.python.org/issue25392.\r\n    \"\"\"\r\n\r\n    f = distutils.log.Log._log\r\n\r\n    def _log(log, level, msg, args):\r\n        if level >= distutils.log.ERROR:\r\n            f(log, level, msg, args)\r\n\r\n    distutils.log.Log._log = _log\r\n    yield\r\n    distutils.log.Log._log = f\r\n\r\n\r\ndef build_pep517(source_dir, build_dir, config_settings=None, dist_type=\"wheel\"):\r\n    if config_settings is None:\r\n        config_settings = {}\r\n    requires, backend = get_pyproject(source_dir)\r\n    hookcaller = HookCaller(source_dir, backend)\r\n    if dist_type == \"sdist\":\r\n        get_requires_fn = hookcaller.get_requires_for_build_sdist\r\n        build_fn = hookcaller.build_sdist\r\n    else:\r\n        get_requires_fn = hookcaller.get_requires_for_build_wheel\r\n        build_fn = hookcaller.build_wheel\r\n\r\n    with BuildEnv() as env:\r\n        env.pip_install(requires)\r\n        reqs = get_requires_fn(config_settings)\r\n        env.pip_install(reqs)\r\n        return build_fn(build_dir, config_settings)\r\n\r\n\r\n@ensure_mkdir_p(mode=0o775)\r\ndef _get_src_dir(root):\r\n    # type: (AnyStr) -> AnyStr\r\n    src = os.environ.get(\"PIP_SRC\")\r\n    if src:\r\n        return src\r\n    virtual_env = os.environ.get(\"VIRTUAL_ENV\")\r\n    if virtual_env is not None:\r\n        return os.path.join(virtual_env, \"src\")\r\n    if root is not None:\r\n        # Intentionally don't match pip's behavior here -- this is a temporary copy\r\n        src_dir = create_tracked_tempdir(prefix=\"requirementslib-\", suffix=\"-src\")\r\n    else:\r\n        src_dir = os.path.join(root, \"src\")\r\n    return src_dir\r\n\r\n\r\n@lru_cache()\r\ndef ensure_reqs(reqs):\r\n    # type: (List[Union[S, PkgResourcesRequirement]]) -> List[PkgResourcesRequirement]\r\n    import pkg_resources\r\n\r\n    if not isinstance(reqs, Iterable):\r\n        raise TypeError(\"Expecting an Iterable, got %r\" % reqs)\r\n    new_reqs = []\r\n    for req in reqs:\r\n        if not req:\r\n            continue\r\n        if isinstance(req, six.string_types):\r\n            req = pkg_resources.Requirement.parse(\"{0}\".format(str(req)))\r\n        # req = strip_extras_markers_from_requirement(req)\r\n        new_reqs.append(req)\r\n    return new_reqs\r\n\r\n\r\ndef _prepare_wheel_building_kwargs(\r\n    ireq=None,  # type: Optional[InstallRequirement]\r\n    src_root=None,  # type: Optional[STRING_TYPE]\r\n    src_dir=None,  # type: Optional[STRING_TYPE]\r\n    editable=False,  # type: bool\r\n):\r\n    # type: (...) -> Dict[STRING_TYPE, STRING_TYPE]\r\n    download_dir = os.path.join(CACHE_DIR, \"pkgs\")  # type: STRING_TYPE\r\n    mkdir_p(download_dir)\r\n\r\n    wheel_download_dir = os.path.join(CACHE_DIR, \"wheels\")  # type: STRING_TYPE\r\n    mkdir_p(wheel_download_dir)\r\n    if src_dir is None:\r\n        if editable and src_root is not None:\r\n            src_dir = src_root\r\n        elif src_root is not None:\r\n            src_dir = _get_src_dir(root=src_root)  # type: STRING_TYPE\r\n        else:\r\n            src_dir = create_tracked_tempdir(prefix=\"reqlib-src\")\r\n\r\n    # Let's always resolve in isolation\r\n    if src_dir is None:\r\n        src_dir = create_tracked_tempdir(prefix=\"reqlib-src\")\r\n    build_dir = create_tracked_tempdir(prefix=\"reqlib-build\")\r\n\r\n    return {\r\n        \"build_dir\": build_dir,\r\n        \"src_dir\": src_dir,\r\n        \"download_dir\": download_dir,\r\n        \"wheel_download_dir\": wheel_download_dir,\r\n    }\r\n\r\n\r\nclass ScandirCloser(object):\r\n    def __init__(self, path):\r\n        self.iterator = scandir(path)\r\n\r\n    def __next__(self):\r\n        return next(iter(self.iterator))\r\n\r\n    def __iter__(self):\r\n        return self\r\n\r\n    def next(self):\r\n        return self.__next__()\r\n\r\n    def close(self):\r\n        if getattr(self.iterator, \"close\", None):\r\n            self.iterator.close()\r\n        else:\r\n            pass\r\n\r\n\r\ndef iter_metadata(path, pkg_name=None, metadata_type=\"egg-info\"):\r\n    # type: (AnyStr, Optional[AnyStr], AnyStr) -> Generator\r\n    if pkg_name is not None:\r\n        pkg_variants = get_name_variants(pkg_name)\r\n    non_matching_dirs = []\r\n    with contextlib.closing(ScandirCloser(path)) as path_iterator:\r\n        for entry in path_iterator:\r\n            if entry.is_dir():\r\n                entry_name, ext = os.path.splitext(entry.name)\r\n                if ext.endswith(metadata_type):\r\n                    if pkg_name is None or entry_name.lower() in pkg_variants:\r\n                        yield entry\r\n                elif not entry.name.endswith(metadata_type):\r\n                    non_matching_dirs.append(entry)\r\n        for entry in non_matching_dirs:\r\n            for dir_entry in iter_metadata(\r\n                entry.path, pkg_name=pkg_name, metadata_type=metadata_type\r\n            ):\r\n                yield dir_entry\r\n\r\n\r\ndef find_egginfo(target, pkg_name=None):\r\n    # type: (AnyStr, Optional[AnyStr]) -> Generator\r\n    egg_dirs = (\r\n        egg_dir\r\n        for egg_dir in iter_metadata(target, pkg_name=pkg_name)\r\n        if egg_dir is not None\r\n    )\r\n    if pkg_name:\r\n        yield next(iter(eggdir for eggdir in egg_dirs if eggdir is not None), None)\r\n    else:\r\n        for egg_dir in egg_dirs:\r\n            yield egg_dir\r\n\r\n\r\ndef find_distinfo(target, pkg_name=None):\r\n    # type: (AnyStr, Optional[AnyStr]) -> Generator\r\n    dist_dirs = (\r\n        dist_dir\r\n        for dist_dir in iter_metadata(\r\n            target, pkg_name=pkg_name, metadata_type=\"dist-info\"\r\n        )\r\n        if dist_dir is not None\r\n    )\r\n    if pkg_name:\r\n        yield next(iter(dist for dist in dist_dirs if dist is not None), None)\r\n    else:\r\n        for dist_dir in dist_dirs:\r\n            yield dist_dir\r\n\r\n\r\ndef get_distinfo_dist(path, pkg_name=None):\r\n    # type: (S, Optional[S]) -> Optional[DistInfoDistribution]\r\n    import pkg_resources\r\n\r\n    dist_dir = next(iter(find_distinfo(path, pkg_name=pkg_name)), None)\r\n    if dist_dir is not None:\r\n        metadata_dir = dist_dir.path\r\n        base_dir = os.path.dirname(metadata_dir)\r\n        dist = next(iter(pkg_resources.find_distributions(base_dir)), None)\r\n        if dist is not None:\r\n            return dist\r\n    return None\r\n\r\n\r\ndef get_egginfo_dist(path, pkg_name=None):\r\n    # type: (S, Optional[S]) -> Optional[EggInfoDistribution]\r\n    import pkg_resources\r\n\r\n    egg_dir = next(iter(find_egginfo(path, pkg_name=pkg_name)), None)\r\n    if egg_dir is not None:\r\n        metadata_dir = egg_dir.path\r\n        base_dir = os.path.dirname(metadata_dir)\r\n        path_metadata = pkg_resources.PathMetadata(base_dir, metadata_dir)\r\n        dist_iter = pkg_resources.distributions_from_metadata(path_metadata.egg_info)\r\n        dist = next(iter(dist_iter), None)\r\n        if dist is not None:\r\n            return dist\r\n    return None\r\n\r\n\r\ndef get_metadata(path, pkg_name=None, metadata_type=None):\r\n    # type: (S, Optional[S], Optional[S]) -> Dict[S, Union[S, List[RequirementType], Dict[S, RequirementType]]]\r\n    wheel_allowed = metadata_type == \"wheel\" or metadata_type is None\r\n    egg_allowed = metadata_type == \"egg\" or metadata_type is None\r\n    dist = None  # type: Optional[Union[DistInfoDistribution, EggInfoDistribution]]\r\n    if wheel_allowed:\r\n        dist = get_distinfo_dist(path, pkg_name=pkg_name)\r\n    if egg_allowed and dist is None:\r\n        dist = get_egginfo_dist(path, pkg_name=pkg_name)\r\n    if dist is not None:\r\n        return get_metadata_from_dist(dist)\r\n    return {}\r\n\r\n\r\n@lru_cache()\r\ndef get_extra_name_from_marker(marker):\r\n    # type: (MarkerType) -> Optional[S]\r\n    if not marker:\r\n        raise ValueError(\"Invalid value for marker: {0!r}\".format(marker))\r\n    if not getattr(marker, \"_markers\", None):\r\n        raise TypeError(\"Expecting a marker instance, received {0!r}\".format(marker))\r\n    for elem in marker._markers:\r\n        if isinstance(elem, tuple) and elem[0].value == \"extra\":\r\n            return elem[2].value\r\n    return None\r\n\r\n\r\ndef get_metadata_from_wheel(wheel_path):\r\n    # type: (S) -> Dict[Any, Any]\r\n    if not isinstance(wheel_path, six.string_types):\r\n        raise TypeError(\"Expected string instance, received {0!r}\".format(wheel_path))\r\n    try:\r\n        dist = Wheel(wheel_path)\r\n    except Exception:\r\n        pass\r\n    metadata = dist.metadata\r\n    name = metadata.name\r\n    version = metadata.version\r\n    requires = []\r\n    extras_keys = getattr(metadata, \"extras\", [])  # type: List[STRING_TYPE]\r\n    extras = {\r\n        k: [] for k in extras_keys\r\n    }  # type: Dict[STRING_TYPE, List[RequirementType]]\r\n    for req in getattr(metadata, \"run_requires\", []):\r\n        parsed_req = init_requirement(req)\r\n        parsed_marker = parsed_req.marker\r\n        if parsed_marker:\r\n            extra = get_extra_name_from_marker(parsed_marker)\r\n            if extra is None:\r\n                requires.append(parsed_req)\r\n                continue\r\n            if extra not in extras:\r\n                extras[extra] = []\r\n            parsed_req = strip_extras_markers_from_requirement(parsed_req)\r\n            extras[extra].append(parsed_req)\r\n        else:\r\n            requires.append(parsed_req)\r\n    return {\"name\": name, \"version\": version, \"requires\": requires, \"extras\": extras}\r\n\r\n\r\ndef get_metadata_from_dist(dist):\r\n    # type: (Union[PathMetadata, EggInfoDistribution, DistInfoDistribution]) -> Dict[S, Union[S, List[RequirementType], Dict[S, RequirementType]]]\r\n    try:\r\n        requires = dist.requires()\r\n    except Exception:\r\n        requires = []\r\n    try:\r\n        dep_map = dist._build_dep_map()\r\n    except Exception:\r\n        dep_map = {}\r\n    deps = []  # type: List[PkgResourcesRequirement]\r\n    extras = {}\r\n    for k in dep_map.keys():\r\n        if k is None:\r\n            deps.extend(dep_map.get(k))\r\n            continue\r\n        else:\r\n            extra = None\r\n            _deps = dep_map.get(k)\r\n            if k.startswith(\":python_version\"):\r\n                marker = k.replace(\":\", \"; \")\r\n            else:\r\n                if \":python_version\" in k:\r\n                    extra, _, marker = k.partition(\":\")\r\n                    marker = \"; {0}\".format(marker)\r\n                else:\r\n                    marker = \"\"\r\n                    extra = \"{0}\".format(k)\r\n            _deps = ensure_reqs(\r\n                tuple([\"{0}{1}\".format(str(req), marker) for req in _deps])\r\n            )\r\n            if extra:\r\n                extras[extra] = _deps\r\n            else:\r\n                deps.extend(_deps)\r\n    requires.extend(deps)\r\n    return {\r\n        \"name\": dist.project_name,\r\n        \"version\": dist.version,\r\n        \"requires\": requires,\r\n        \"extras\": extras,\r\n    }\r\n\r\n\r\nAST_BINOP_MAP = dict(\r\n    (\r\n        (ast.Add, operator.add),\r\n        (ast.Sub, operator.sub),\r\n        (ast.Mult, operator.mul),\r\n        (ast.Div, operator.floordiv),\r\n        (ast.Mod, operator.mod),\r\n        (ast.Pow, operator.pow),\r\n        (ast.LShift, operator.lshift),\r\n        (ast.RShift, operator.rshift),\r\n        (ast.BitAnd, operator.and_),\r\n        (ast.BitOr, operator.or_),\r\n        (ast.BitXor, operator.xor),\r\n    )\r\n)\r\n\r\n\r\nAST_COMPARATORS = dict(\r\n    (\r\n        (ast.Lt, operator.lt),\r\n        (ast.LtE, operator.le),\r\n        (ast.Eq, operator.eq),\r\n        (ast.Gt, operator.gt),\r\n        (ast.GtE, operator.ge),\r\n        (ast.NotEq, operator.ne),\r\n        (ast.Is, operator.is_),\r\n        (ast.IsNot, operator.is_not),\r\n        (ast.And, operator.and_),\r\n        (ast.Or, operator.or_),\r\n        (ast.Not, operator.not_),\r\n        (ast.In, lambda a, b: operator.contains(b, a)),\r\n    )\r\n)\r\n\r\n\r\nclass Analyzer(ast.NodeVisitor):\r\n    def __init__(self):\r\n        self.name_types = []\r\n        self.function_map = {}  # type: Dict[Any, Any]\r\n        self.function_names = {}\r\n        self.resolved_function_names = {}\r\n        self.functions = []\r\n        self.strings = []\r\n        self.assignments = {}\r\n        self.binOps = []\r\n        self.binOps_map = {}\r\n        self.recurse = True\r\n        super(Analyzer, self).__init__()\r\n\r\n    def generic_visit(self, node):\r\n        if isinstance(node, ast.Call):\r\n            self.functions.append(node)\r\n            self.function_map.update(ast_unparse(node, initial_mapping=True))\r\n        if isinstance(node, ast.Name):\r\n            self.name_types.append(node)\r\n        if isinstance(node, ast.Str):\r\n            self.strings.append(node)\r\n        if isinstance(node, ast.Assign):\r\n            self.assignments.update(ast_unparse(node, initial_mapping=True))\r\n        super(Analyzer, self).generic_visit(node)\r\n\r\n    @contextlib.contextmanager\r\n    def no_recurse(self):\r\n        original_recurse_val = self.recurse\r\n        try:\r\n            self.recurse = False\r\n            yield\r\n        finally:\r\n            self.recurse = original_recurse_val\r\n\r\n    def visit_BinOp(self, node):\r\n        node = ast_unparse(node, initial_mapping=True)\r\n        self.binOps.append(node)\r\n\r\n    def unmap_binops(self):\r\n        for binop in self.binOps:\r\n            self.binOps_map[binop] = ast_unparse(binop, analyzer=self)\r\n\r\n    def match_assignment_str(self, match):\r\n        return next(\r\n            iter(k for k in self.assignments if getattr(k, \"id\", \"\") == match), None\r\n        )\r\n\r\n    def match_assignment_name(self, match):\r\n        return next(\r\n            iter(k for k in self.assignments if getattr(k, \"id\", \"\") == match.id), None\r\n        )\r\n\r\n    def generic_unparse(self, item):\r\n        if any(isinstance(item, k) for k in AST_BINOP_MAP.keys()):\r\n            return AST_BINOP_MAP[type(item)]\r\n        elif any(isinstance(item, k) for k in AST_COMPARATORS.keys()):\r\n            return AST_COMPARATORS[type(item)]\r\n        return item\r\n\r\n    def unparse(self, item):\r\n        unparser = getattr(\r\n            self, \"unparse_{0}\".format(item.__class__.__name__), self.generic_unparse\r\n        )\r\n        return unparser(item)\r\n\r\n    def unparse_Dict(self, item):\r\n        # unparsed = dict(zip(unparse(item.keys), unparse(item.values)))\r\n        return dict(\r\n            (self.unparse(k), self.unparse(v)) for k, v in zip(item.keys, item.values)\r\n        )\r\n\r\n    def unparse_List(self, item):\r\n        return [self.unparse(el) for el in item.elts]\r\n\r\n    def unparse_Tuple(self, item):\r\n        return tuple([self.unparse(el) for el in item.elts])\r\n\r\n    def unparse_Str(self, item):\r\n        return item.s\r\n\r\n    def unparse_Subscript(self, item):\r\n        unparsed = self.unparse(item.value)\r\n        if isinstance(item.slice, ast.Index):\r\n            try:\r\n                unparsed = unparsed[self.unparse(item.slice.value)]\r\n            except KeyError:\r\n                # not everything can be looked up before runtime\r\n                unparsed = item\r\n        return unparsed\r\n\r\n    def unparse_Num(self, item):\r\n        return item.n\r\n\r\n    def unparse_BinOp(self, item):\r\n        if item in self.binOps_map:\r\n            unparsed = self.binOps_map[item]\r\n        else:\r\n            right_item = self.unparse(item.right)\r\n            left_item = self.unparse(item.left)\r\n            op = getattr(item, \"op\", None)\r\n            op_func = self.unparse(op) if op is not None else op\r\n            try:\r\n                unparsed = op_func(left_item, right_item)\r\n            except Exception:\r\n                unparsed = (left_item, op_func, right_item)\r\n        return unparsed\r\n\r\n    def unparse_Name(self, item):\r\n        unparsed = item.id\r\n        if not self.recurse:\r\n            return unparsed\r\n        if item in self.assignments and self.recurse:\r\n            items = self.unparse(self.assignments[item])\r\n            unparsed = items.get(item.id, item.id)\r\n        else:\r\n            assignment = self.match_assignment_name(item)\r\n            if assignment is not None:\r\n                items = self.unparse(self.assignments[assignment])\r\n                unparsed = items.get(item.id, item.id)\r\n        return unparsed\r\n\r\n    def unparse_NameConstant(self, item):\r\n        return item.value\r\n\r\n    def unparse_Constant(self, item):\r\n        return item.value\r\n\r\n    def unparse_Ellipsis(self, item):\r\n        return item.value\r\n\r\n    def unparse_Attribute(self, item):\r\n        attr_name = getattr(item, \"value\", None)\r\n        attr_attr = getattr(item, \"attr\", None)\r\n        name = None\r\n        name = self.unparse(attr_name) if attr_name is not None else attr_attr\r\n        if attr_name and not self.recurse:\r\n            name = attr_name\r\n        elif name and attr_attr:\r\n            if isinstance(name, six.string_types):\r\n                unparsed = \".\".join([item for item in (name, attr_attr) if item])\r\n            else:\r\n                unparsed = item\r\n        elif attr_attr and not name:\r\n            unparsed = attr_attr\r\n        else:\r\n            unparsed = name if not unparsed else unparsed\r\n        return unparsed\r\n\r\n    def unparse_Compare(self, item):\r\n        if isinstance(item.left, ast.Attribute) or isinstance(item.left, ast.Str):\r\n            import importlib\r\n\r\n            left = unparse(item.left)\r\n            if \".\" in left:\r\n                name, _, val = left.rpartition(\".\")\r\n                left = getattr(importlib.import_module(name), val, left)\r\n            comparators = []\r\n            for comparator in item.comparators:\r\n                right = self.unparse(comparator)\r\n                if isinstance(comparator, ast.Attribute) and \".\" in right:\r\n                    name, _, val = right.rpartition(\".\")\r\n                    right = getattr(importlib.import_module(name), val, right)\r\n                comparators.append(right)\r\n            unparsed = (left, self.unparse(item.ops), comparators)\r\n        else:\r\n            unparsed = item\r\n        return unparsed\r\n\r\n    def unparse_IfExp(self, item):\r\n        ops, truth_vals = [], []\r\n        if isinstance(item.test, ast.Compare):\r\n            left, ops, right = self.unparse(item.test)\r\n        else:\r\n            result = self.unparse(item.test)\r\n            if isinstance(result, dict):\r\n                k, v = result.popitem()\r\n                if not v:\r\n                    truth_vals = [False]\r\n        for i, op in enumerate(ops):\r\n            if i == 0:\r\n                truth_vals.append(op(left, right[i]))\r\n            else:\r\n                truth_vals.append(op(right[i - 1], right[i]))\r\n        if all(truth_vals):\r\n            unparsed = self.unparse(item.body)\r\n        else:\r\n            unparsed = self.unparse(item.orelse)\r\n        return unparsed\r\n\r\n    def unparse_Call(self, item):\r\n        unparsed = {}\r\n        if isinstance(item.func, (ast.Name, ast.Attribute)):\r\n            func_name = self.unparse(item.func)\r\n        else:\r\n            try:\r\n                func_name = self.unparse(item.func)\r\n            except Exception:\r\n                func_name = None\r\n        if not func_name:\r\n            return {}\r\n        if isinstance(func_name, dict):\r\n            unparsed.update(func_name)\r\n            func_name = next(iter(func_name.keys()))\r\n        else:\r\n            unparsed[func_name] = {}\r\n        for key in (\"kwargs\", \"keywords\"):\r\n            val = getattr(item, key, [])\r\n            if val is None:\r\n                continue\r\n            for keyword in self.unparse(val):\r\n                unparsed[func_name].update(self.unparse(keyword))\r\n        return unparsed\r\n\r\n    def unparse_keyword(self, item):\r\n        return {self.unparse(item.arg): self.unparse(item.value)}\r\n\r\n    def unparse_Assign(self, item):\r\n        # XXX: DO NOT UNPARSE THIS\r\n        # XXX: If we unparse this it becomes impossible to map it back\r\n        # XXX: To the original node in the AST so we can find the\r\n        # XXX: Original reference\r\n        with self.no_recurse():\r\n            target = self.unparse(next(iter(item.targets)))\r\n            val = self.unparse(item.value)\r\n        if isinstance(target, (tuple, set, list)):\r\n            unparsed = dict(zip(target, val))\r\n        else:\r\n            unparsed = {target: val}\r\n        return unparsed\r\n\r\n    def unparse_Mapping(self, item):\r\n        unparsed = {}\r\n        for k, v in item.items():\r\n            try:\r\n                unparsed[self.unparse(k)] = self.unparse(v)\r\n            except TypeError:\r\n                unparsed[k] = self.unparse(v)\r\n        return unparsed\r\n\r\n    def unparse_list(self, item):\r\n        return type(item)([self.unparse(el) for el in item])\r\n\r\n    def unparse_tuple(self, item):\r\n        return self.unparse_list(item)\r\n\r\n    def unparse_str(self, item):\r\n        return item\r\n\r\n    def parse_function_names(self, should_retry=True, function_map=None):\r\n        if function_map is None:\r\n            function_map = {}\r\n        retries = []\r\n        for k, v in function_map.items():\r\n            fn_name = \"\"\r\n            if k in self.function_names:\r\n                fn_name = self.function_names[k]\r\n            elif isinstance(k, ast.Name):\r\n                fn_name = k.id\r\n            elif isinstance(k, ast.Attribute):\r\n                try:\r\n                    fn = ast_unparse(k, analyzer=self)\r\n                except Exception:\r\n                    if should_retry:\r\n                        retries.append((k, v))\r\n                    continue\r\n                else:\r\n                    if isinstance(fn, six.string_types):\r\n                        _, _, fn_name = fn.rpartition(\".\")\r\n            if fn_name:\r\n                self.resolved_function_names[fn_name] = ast_unparse(v, analyzer=self)\r\n        return retries\r\n\r\n    def parse_functions(self):\r\n        retries = self.parse_function_names(function_map=self.function_map)\r\n        if retries:\r\n            failures = self.parse_function_names(\r\n                should_retry=False, function_map=dict(retries)\r\n            )\r\n        return self.resolved_function_names\r\n\r\n    def parse_setup_function(self):\r\n        setup = {}  # type: Dict[Any, Any]\r\n        self.unmap_binops()\r\n        function_names = self.parse_functions()\r\n        if \"setup\" in function_names:\r\n            setup = self.unparse(function_names[\"setup\"])\r\n        keys = list(setup.keys())\r\n        if len(keys) == 1 and keys[0] is None:\r\n            _, setup = setup.popitem()\r\n        return setup\r\n\r\n\r\ndef ast_unparse(item, initial_mapping=False, analyzer=None, recurse=True):  # noqa:C901\r\n    # type: (Any, bool, Optional[Analyzer], bool) -> Union[List[Any], Dict[Any, Any], Tuple[Any, ...], STRING_TYPE]\r\n    unparse = partial(\r\n        ast_unparse, initial_mapping=initial_mapping, analyzer=analyzer, recurse=recurse\r\n    )\r\n    if getattr(ast, \"Constant\", None):\r\n        constant = (ast.Constant, ast.Ellipsis)\r\n    else:\r\n        constant = ast.Ellipsis\r\n    unparsed = item\r\n    if isinstance(item, ast.Dict):\r\n        unparsed = dict(zip(unparse(item.keys), unparse(item.values)))\r\n    elif isinstance(item, ast.List):\r\n        unparsed = [unparse(el) for el in item.elts]\r\n    elif isinstance(item, ast.Tuple):\r\n        unparsed = tuple([unparse(el) for el in item.elts])\r\n    elif isinstance(item, ast.Str):\r\n        unparsed = item.s\r\n    elif isinstance(item, ast.Subscript):\r\n        unparsed = unparse(item.value)\r\n        if not initial_mapping:\r\n            if isinstance(item.slice, ast.Index):\r\n                try:\r\n                    unparsed = unparsed[unparse(item.slice.value)]\r\n                except KeyError:\r\n                    # not everything can be looked up before runtime\r\n                    unparsed = item\r\n    elif any(isinstance(item, k) for k in AST_BINOP_MAP.keys()):\r\n        unparsed = AST_BINOP_MAP[type(item)]\r\n    elif isinstance(item, ast.Num):\r\n        unparsed = item.n\r\n    elif isinstance(item, ast.BinOp):\r\n        if analyzer and item in analyzer.binOps_map:\r\n            unparsed = analyzer.binOps_map[item]\r\n        else:\r\n            right_item = unparse(item.right)\r\n            left_item = unparse(item.left)\r\n            op = getattr(item, \"op\", None)\r\n            op_func = unparse(op) if op is not None else op\r\n            if not initial_mapping:\r\n                try:\r\n                    unparsed = op_func(left_item, right_item)\r\n                except Exception:\r\n                    unparsed = (left_item, op_func, right_item)\r\n            else:\r\n                item.left = left_item\r\n                item.right = right_item\r\n                item.op = op_func\r\n                unparsed = item\r\n    elif isinstance(item, ast.Name):\r\n        if not initial_mapping:\r\n            unparsed = item.id\r\n            if analyzer and recurse:\r\n                if item in analyzer.assignments:\r\n                    items = unparse(analyzer.assignments[item])\r\n                    unparsed = items.get(item.id, item.id)\r\n                else:\r\n                    assignment = analyzer.match_assignment_name(item)\r\n                    if assignment is not None:\r\n                        items = unparse(analyzer.assignments[assignment])\r\n                        unparsed = items.get(item.id, item.id)\r\n        else:\r\n            unparsed = item\r\n    elif six.PY3 and isinstance(item, ast.NameConstant):\r\n        unparsed = item.value\r\n    elif any(isinstance(item, k) for k in AST_COMPARATORS.keys()):\r\n        unparsed = AST_COMPARATORS[type(item)]\r\n    elif isinstance(item, constant):\r\n        unparsed = item.value\r\n    elif isinstance(item, ast.Compare):\r\n        if isinstance(item.left, ast.Attribute) or isinstance(item.left, ast.Str):\r\n            import importlib\r\n\r\n            left = unparse(item.left)\r\n            if \".\" in left:\r\n                name, _, val = left.rpartition(\".\")\r\n                left = getattr(importlib.import_module(name), val, left)\r\n            comparators = []\r\n            for comparator in item.comparators:\r\n                right = unparse(comparator)\r\n                if isinstance(comparator, ast.Attribute) and \".\" in right:\r\n                    name, _, val = right.rpartition(\".\")\r\n                    right = getattr(importlib.import_module(name), val, right)\r\n                comparators.append(right)\r\n            unparsed = (left, unparse(item.ops), comparators)\r\n    elif isinstance(item, ast.IfExp):\r\n        if initial_mapping:\r\n            unparsed = item\r\n        else:\r\n            ops, truth_vals = [], []\r\n            if isinstance(item.test, ast.Compare):\r\n                left, ops, right = unparse(item.test)\r\n            else:\r\n                result = ast_unparse(item.test)\r\n                if isinstance(result, dict):\r\n                    k, v = result.popitem()\r\n                    if not v:\r\n                        truth_vals = [False]\r\n            for i, op in enumerate(ops):\r\n                if i == 0:\r\n                    truth_vals.append(op(left, right[i]))\r\n                else:\r\n                    truth_vals.append(op(right[i - 1], right[i]))\r\n            if all(truth_vals):\r\n                unparsed = unparse(item.body)\r\n            else:\r\n                unparsed = unparse(item.orelse)\r\n    elif isinstance(item, ast.Attribute):\r\n        attr_name = getattr(item, \"value\", None)\r\n        attr_attr = getattr(item, \"attr\", None)\r\n        name = None\r\n        if initial_mapping:\r\n            unparsed = item\r\n        elif attr_name and not recurse:\r\n            name = attr_name\r\n        else:\r\n            name = unparse(attr_name) if attr_name is not None else attr_attr\r\n        if name and attr_attr:\r\n            if not initial_mapping and isinstance(name, six.string_types):\r\n                unparsed = \".\".join([item for item in (name, attr_attr) if item])\r\n            else:\r\n                unparsed = item\r\n        elif attr_attr and not name and not initial_mapping:\r\n            unparsed = attr_attr\r\n        else:\r\n            unparsed = name if not unparsed else unparsed\r\n    elif isinstance(item, ast.Call):\r\n        unparsed = {}\r\n        if isinstance(item.func, (ast.Name, ast.Attribute)):\r\n            func_name = unparse(item.func)\r\n        else:\r\n            try:\r\n                func_name = unparse(item.func)\r\n            except Exception:\r\n                func_name = None\r\n        if func_name and not isinstance(func_name, dict):\r\n            unparsed[func_name] = {}\r\n        if isinstance(func_name, dict):\r\n            unparsed.update(func_name)\r\n            func_name = next(iter(func_name.keys()))\r\n        if func_name:\r\n            for key in (\"kwargs\", \"keywords\"):\r\n                val = getattr(item, key, [])\r\n                if val is None:\r\n                    continue\r\n                if isinstance(val, ast.Name):\r\n                    unparsed[func_name] = val\r\n                else:\r\n                    for keyword in unparse(val):\r\n                        unparsed[func_name].update(unparse(keyword))\r\n    elif isinstance(item, ast.keyword):\r\n        unparsed = {unparse(item.arg): unparse(item.value)}\r\n    elif isinstance(item, ast.Assign):\r\n        # XXX: DO NOT UNPARSE THIS\r\n        # XXX: If we unparse this it becomes impossible to map it back\r\n        # XXX: To the original node in the AST so we can find the\r\n        # XXX: Original reference\r\n        if not initial_mapping:\r\n            target = unparse(next(iter(item.targets)), recurse=False)\r\n            val = unparse(item.value, recurse=False)\r\n            if isinstance(target, (tuple, set, list)):\r\n                unparsed = dict(zip(target, val))\r\n            else:\r\n                unparsed = {target: val}\r\n        else:\r\n            unparsed = {next(iter(item.targets)): item}\r\n    elif isinstance(item, Mapping):\r\n        unparsed = {}\r\n        for k, v in item.items():\r\n            try:\r\n                unparsed[unparse(k)] = unparse(v)\r\n            except TypeError:\r\n                unparsed[k] = unparse(v)\r\n    elif isinstance(item, (list, tuple)):\r\n        unparsed = type(item)([unparse(el) for el in item])\r\n    elif isinstance(item, six.string_types):\r\n        unparsed = item\r\n    return unparsed\r\n\r\n\r\ndef ast_parse_attribute_from_file(path, attribute):\r\n    # type: (S) -> Any\r\n    analyzer = ast_parse_file(path)\r\n    target_value = None\r\n    for k, v in analyzer.assignments.items():\r\n        name = \"\"\r\n        if isinstance(k, ast.Name):\r\n            name = k.id\r\n        elif isinstance(k, ast.Attribute):\r\n            fn = ast_unparse(k)\r\n            if isinstance(fn, six.string_types):\r\n                _, _, name = fn.rpartition(\".\")\r\n        if name == attribute:\r\n            target_value = ast_unparse(v, analyzer=analyzer)\r\n            break\r\n    if isinstance(target_value, Mapping) and attribute in target_value:\r\n        return target_value[attribute]\r\n    return target_value\r\n\r\n\r\ndef ast_parse_file(path):\r\n    # type: (S) -> Analyzer\r\n    try:\r\n        tree = ast.parse(read_source(path))\r\n    except SyntaxError:\r\n        # The source may be encoded strangely, e.g. azure-storage\r\n        # which has a setup.py encoded with utf-8-sig\r\n        with open(path, \"rb\") as fh:\r\n            contents = fh.read()\r\n        encoding = chardet.detect(contents)[\"encoding\"]\r\n        tree = ast.parse(contents.decode(encoding))\r\n    ast_analyzer = Analyzer()\r\n    ast_analyzer.visit(tree)\r\n    return ast_analyzer\r\n\r\n\r\ndef ast_parse_setup_py(path):\r\n    # type: (S) -> Dict[Any, Any]\r\n    ast_analyzer = ast_parse_file(path)\r\n    setup = {}  # type: Dict[Any, Any]\r\n    ast_analyzer.unmap_binops()\r\n    function_names = ast_analyzer.parse_functions()\r\n    if \"setup\" in function_names:\r\n        setup = ast_unparse(function_names[\"setup\"], analyzer=ast_analyzer)\r\n    keys = list(setup.keys())\r\n    if len(keys) == 1 and keys[0] is None:\r\n        _, setup = setup.popitem()\r\n    return setup\r\n\r\n\r\ndef run_setup(script_path, egg_base=None):\r\n    # type: (str, Optional[str]) -> Distribution\r\n    \"\"\"Run a `setup.py` script with a target **egg_base** if provided.\r\n\r\n    :param S script_path: The path to the `setup.py` script to run\r\n    :param Optional[S] egg_base: The metadata directory to build in\r\n    :raises FileNotFoundError: If the provided `script_path` does not exist\r\n    :return: The metadata dictionary\r\n    :rtype: Dict[Any, Any]\r\n    \"\"\"\r\n\r\n    if not os.path.exists(script_path):\r\n        raise FileNotFoundError(script_path)\r\n    target_cwd = os.path.dirname(os.path.abspath(script_path))\r\n    if egg_base is None:\r\n        egg_base = os.path.join(target_cwd, \"reqlib-metadata\")\r\n    with temp_path(), cd(target_cwd), _suppress_distutils_logs():\r\n        # This is for you, Hynek\r\n        # see https://github.com/hynek/environ_config/blob/69b1c8a/setup.py\r\n        args = [\"egg_info\"]\r\n        if egg_base:\r\n            args += [\"--egg-base\", egg_base]\r\n        script_name = os.path.basename(script_path)\r\n        g = {\"__file__\": script_name, \"__name__\": \"__main__\"}\r\n        sys.path.insert(0, target_cwd)\r\n        local_dict = {}\r\n        if sys.version_info < (3, 5):\r\n            save_argv = sys.argv\r\n        else:\r\n            save_argv = sys.argv.copy()\r\n        try:\r\n            global _setup_distribution, _setup_stop_after\r\n            _setup_stop_after = \"run\"\r\n            sys.argv[0] = script_name\r\n            sys.argv[1:] = args\r\n            with open(script_name, \"rb\") as f:\r\n                contents = f.read()\r\n                if six.PY3:\r\n                    contents.replace(br\"\\r\\n\", br\"\\n\")\r\n                else:\r\n                    contents.replace(r\"\\r\\n\", r\"\\n\")\r\n                if sys.version_info < (3, 5):\r\n                    exec(contents, g, local_dict)\r\n                else:\r\n                    exec(contents, g)\r\n        # We couldn't import everything needed to run setup\r\n        except Exception:\r\n            python = os.environ.get(\"PIP_PYTHON_PATH\", sys.executable)\r\n            out, _ = run(\r\n                [python, \"setup.py\"] + args,\r\n                cwd=target_cwd,\r\n                block=True,\r\n                combine_stderr=False,\r\n                return_object=False,\r\n                nospin=True,\r\n            )\r\n        finally:\r\n            _setup_stop_after = None\r\n            sys.argv = save_argv\r\n            _setup_distribution = get_metadata(egg_base, metadata_type=\"egg\")\r\n        dist = _setup_distribution\r\n    return dist\r\n\r\n\r\n@attr.s(slots=True, frozen=True)\r\nclass BaseRequirement(object):\r\n    name = attr.ib(default=\"\", cmp=True)  # type: STRING_TYPE\r\n    requirement = attr.ib(\r\n        default=None, cmp=True\r\n    )  # type: Optional[PkgResourcesRequirement]\r\n\r\n    def __str__(self):\r\n        # type: () -> S\r\n        return \"{0}\".format(str(self.requirement))\r\n\r\n    def as_dict(self):\r\n        # type: () -> Dict[STRING_TYPE, Optional[PkgResourcesRequirement]]\r\n        return {self.name: self.requirement}\r\n\r\n    def as_tuple(self):\r\n        # type: () -> Tuple[STRING_TYPE, Optional[PkgResourcesRequirement]]\r\n        return (self.name, self.requirement)\r\n\r\n    @classmethod\r\n    @lru_cache()\r\n    def from_string(cls, line):\r\n        # type: (S) -> BaseRequirement\r\n        line = line.strip()\r\n        req = init_requirement(line)\r\n        return cls.from_req(req)\r\n\r\n    @classmethod\r\n    @lru_cache()\r\n    def from_req(cls, req):\r\n        # type: (PkgResourcesRequirement) -> BaseRequirement\r\n        name = None\r\n        key = getattr(req, \"key\", None)\r\n        name = getattr(req, \"name\", None)\r\n        project_name = getattr(req, \"project_name\", None)\r\n        if key is not None:\r\n            name = key\r\n        if name is None:\r\n            name = project_name\r\n        return cls(name=name, requirement=req)\r\n\r\n\r\n@attr.s(slots=True, frozen=True)\r\nclass Extra(object):\r\n    name = attr.ib(default=None, cmp=True)  # type: STRING_TYPE\r\n    requirements = attr.ib(factory=frozenset, cmp=True, type=frozenset)\r\n\r\n    def __str__(self):\r\n        # type: () -> S\r\n        return \"{0}: {{{1}}}\".format(\r\n            self.name, \", \".join([r.name for r in self.requirements])\r\n        )\r\n\r\n    def add(self, req):\r\n        # type: (BaseRequirement) -> \"Extra\"\r\n        if req not in self.requirements:\r\n            current_set = set(self.requirements)\r\n            current_set.add(req)\r\n            return attr.evolve(self, requirements=frozenset(current_set))\r\n        return self\r\n\r\n    def as_dict(self):\r\n        # type: () -> Dict[STRING_TYPE, Tuple[RequirementType, ...]]\r\n        return {self.name: tuple([r.requirement for r in self.requirements])}\r\n\r\n\r\n@attr.s(slots=True, eq=True, hash=True)\r\nclass SetupInfo(object):\r\n    name = attr.ib(default=None, eq=True)  # type: STRING_TYPE\r\n    base_dir = attr.ib(default=None, eq=True, hash=False)  # type: STRING_TYPE\r\n    _version = attr.ib(default=None, eq=True)  # type: STRING_TYPE\r\n    _requirements = attr.ib(\r\n        type=frozenset, factory=frozenset, eq=True, hash=True\r\n    )  # type: Optional[frozenset]\r\n    build_requires = attr.ib(default=None, eq=True)  # type: Optional[Tuple]\r\n    build_backend = attr.ib(eq=True)  # type: STRING_TYPE\r\n    setup_requires = attr.ib(default=None, eq=True)  # type: Optional[Tuple]\r\n    python_requires = attr.ib(\r\n        default=None, eq=True\r\n    )  # type: Optional[packaging.specifiers.SpecifierSet]\r\n    _extras_requirements = attr.ib(default=None, eq=True)  # type: Optional[Tuple]\r\n    setup_cfg = attr.ib(type=Path, default=None, eq=True, hash=False)\r\n    setup_py = attr.ib(type=Path, default=None, eq=True, hash=False)\r\n    pyproject = attr.ib(type=Path, default=None, eq=True, hash=False)\r\n    ireq = attr.ib(\r\n        default=None, eq=True, hash=False\r\n    )  # type: Optional[InstallRequirement]\r\n    extra_kwargs = attr.ib(default=attr.Factory(dict), type=dict, eq=False, hash=False)\r\n    metadata = attr.ib(default=None)  # type: Optional[Tuple[STRING_TYPE]]\r\n    stack = attr.ib(default=None, eq=False)  # type: Optional[ExitStack]\r\n    _finalizer = attr.ib(default=None, eq=False)  # type: Any\r\n\r\n    def __attrs_post_init__(self):\r\n        self._finalizer = finalize(self, self.stack.close)\r\n\r\n    @build_backend.default\r\n    def get_build_backend(self):\r\n        # type: () -> STRING_TYPE\r\n        return get_default_pyproject_backend()\r\n\r\n    @property\r\n    def requires(self):\r\n        # type: () -> Dict[S, RequirementType]\r\n        if self._requirements is None:\r\n            self._requirements = frozenset()\r\n            self.get_info()\r\n        return {req.name: req.requirement for req in self._requirements}\r\n\r\n    @property\r\n    def extras(self):\r\n        # type: () -> Dict[S, Optional[Any]]\r\n        if self._extras_requirements is None:\r\n            self._extras_requirements = ()\r\n            self.get_info()\r\n        extras_dict = {}\r\n        extras = set(self._extras_requirements)\r\n        for section, deps in extras:\r\n            if isinstance(deps, BaseRequirement):\r\n                extras_dict[section] = deps.requirement\r\n            elif isinstance(deps, (list, tuple)):\r\n                extras_dict[section] = [d.requirement for d in deps]\r\n        return extras_dict\r\n\r\n    @property\r\n    def version(self):\r\n        # type: () -> Optional[str]\r\n        if not self._version:\r\n            info = self.get_info()\r\n            self._version = info.get(\"version\", None)\r\n        return self._version\r\n\r\n    @property\r\n    def egg_base(self):\r\n        # type: () -> S\r\n        base = None  # type: Optional[STRING_TYPE]\r\n        if self.setup_py.exists():\r\n            base = self.setup_py.parent\r\n        elif self.pyproject.exists():\r\n            base = self.pyproject.parent\r\n        elif self.setup_cfg.exists():\r\n            base = self.setup_cfg.parent\r\n        if base is None:\r\n            base = Path(self.base_dir)\r\n        if base is None:\r\n            base = Path(self.extra_kwargs[\"src_dir\"])\r\n        egg_base = base.joinpath(\"reqlib-metadata\")\r\n        if not egg_base.exists():\r\n            atexit.register(rmtree, egg_base.as_posix())\r\n        egg_base.mkdir(parents=True, exist_ok=True)\r\n        return egg_base.as_posix()\r\n\r\n    def update_from_dict(self, metadata):\r\n        name = metadata.get(\"name\", self.name)\r\n        if isinstance(name, six.string_types):\r\n            self.name = self.name if self.name else name\r\n        version = metadata.get(\"version\", None)\r\n        if version:\r\n            try:\r\n                packaging.version.parse(version)\r\n            except TypeError:\r\n                version = self.version if self.version else None\r\n            else:\r\n                version = version\r\n        if version:\r\n            self._version = version\r\n        build_requires = metadata.get(\"build_requires\", [])\r\n        if self.build_requires is None:\r\n            self.build_requires = ()\r\n        self.build_requires = tuple(set(self.build_requires) | set(build_requires))\r\n        self._requirements = (\r\n            frozenset() if self._requirements is None else self._requirements\r\n        )\r\n        requirements = set(self._requirements)\r\n        install_requires = make_base_requirements(metadata.get(\"install_requires\", []))\r\n        requirements |= install_requires\r\n        setup_requires = make_base_requirements(metadata.get(\"setup_requires\", []))\r\n        if self.setup_requires is None:\r\n            self.setup_requires = ()\r\n        self.setup_requires = tuple(set(self.setup_requires) | setup_requires)\r\n        if self.ireq.editable:\r\n            requirements |= setup_requires\r\n        # TODO: Should this be a specifierset?\r\n        self.python_requires = metadata.get(\"python_requires\", self.python_requires)\r\n        extras_require = metadata.get(\"extras_require\", {})\r\n        extras_tuples = []\r\n        for section in set(list(extras_require.keys())) - set(list(self.extras.keys())):\r\n            extras = extras_require[section]\r\n            extras_set = make_base_requirements(extras)\r\n            if self.ireq and self.ireq.extras and section in self.ireq.extras:\r\n                requirements |= extras_set\r\n            extras_tuples.append((section, tuple(extras_set)))\r\n        if self._extras_requirements is None:\r\n            self._extras_requirements = ()\r\n        self._extras_requirements += tuple(extras_tuples)\r\n        build_backend = metadata.get(\"build_backend\", \"setuptools.build_meta:__legacy__\")\r\n        if not self.build_backend:\r\n            self.build_backend = build_backend\r\n        self._requirements = frozenset(requirements)\r\n\r\n    def get_extras_from_ireq(self):\r\n        # type: () -> None\r\n        if self.ireq and self.ireq.extras:\r\n            for extra in self.ireq.extras:\r\n                if extra in self.extras:\r\n                    extras = make_base_requirements(self.extras[extra])\r\n                    self._requirements = frozenset(set(self._requirements) | extras)\r\n                else:\r\n                    extras = tuple(make_base_requirements(extra))\r\n                    self._extras_requirements += (extra, extras)\r\n\r\n    def parse_setup_cfg(self):\r\n        # type: () -> Dict[STRING_TYPE, Any]\r\n        if self.setup_cfg is not None and self.setup_cfg.exists():\r\n            contents = self.setup_cfg.read_text()\r\n            base_dir = self.setup_cfg.absolute().parent.as_posix()\r\n            try:\r\n                parsed = setuptools_parse_setup_cfg(self.setup_cfg.as_posix())\r\n            except Exception:\r\n                if six.PY2:\r\n                    contents = self.setup_cfg.read_bytes()\r\n                parsed = parse_setup_cfg(contents, base_dir)\r\n            if not parsed:\r\n                return {}\r\n            return parsed\r\n        return {}\r\n\r\n    def parse_setup_py(self):\r\n        # type: () -> Dict[STRING_TYPE, Any]\r\n        if self.setup_py is not None and self.setup_py.exists():\r\n            parsed = ast_parse_setup_py(self.setup_py.as_posix())\r\n            if not parsed:\r\n                return {}\r\n            return parsed\r\n        return {}\r\n\r\n    def run_setup(self):\r\n        # type: () -> \"SetupInfo\"\r\n        if self.setup_py is not None and self.setup_py.exists():\r\n            dist = run_setup(self.setup_py.as_posix(), egg_base=self.egg_base)\r\n            target_cwd = self.setup_py.parent.as_posix()\r\n            with temp_path(), cd(target_cwd):\r\n                if not dist:\r\n                    metadata = self.get_egg_metadata()\r\n                    if metadata:\r\n                        return self.populate_metadata(metadata)\r\n\r\n                if isinstance(dist, Mapping):\r\n                    self.populate_metadata(dist)\r\n                    return\r\n                name = dist.get_name()\r\n                if name:\r\n                    self.name = name\r\n                update_dict = {}\r\n                if dist.python_requires:\r\n                    update_dict[\"python_requires\"] = dist.python_requires\r\n                update_dict[\"extras_require\"] = {}\r\n                if dist.extras_require:\r\n                    for extra, extra_requires in dist.extras_require:\r\n                        extras_tuple = make_base_requirements(extra_requires)\r\n                        update_dict[\"extras_require\"][extra] = extras_tuple\r\n                update_dict[\"install_requires\"] = make_base_requirements(\r\n                    dist.get_requires()\r\n                )\r\n                if dist.setup_requires:\r\n                    update_dict[\"setup_requires\"] = make_base_requirements(\r\n                        dist.setup_requires\r\n                    )\r\n                version = dist.get_version()\r\n                if version:\r\n                    update_dict[\"version\"] = version\r\n                return self.update_from_dict(update_dict)\r\n\r\n    @property\r\n    def pep517_config(self):\r\n        config = {}\r\n        config.setdefault(\"--global-option\", [])\r\n        return config\r\n\r\n    def build_wheel(self):\r\n        # type: () -> S\r\n        if not self.pyproject.exists():\r\n            build_requires = \", \".join(['\"{0}\"'.format(r) for r in self.build_requires])\r\n            self.pyproject.write_text(\r\n                six.text_type(\r\n                    \"\"\"\r\n[build-system]\r\nrequires = [{0}]\r\nbuild-backend = \"{1}\"\r\n                \"\"\".format(\r\n                        build_requires, self.build_backend\r\n                    ).strip()\r\n                )\r\n            )\r\n        return build_pep517(\r\n            self.base_dir,\r\n            self.extra_kwargs[\"build_dir\"],\r\n            config_settings=self.pep517_config,\r\n            dist_type=\"wheel\",\r\n        )\r\n\r\n    # noinspection PyPackageRequirements\r\n    def build_sdist(self):\r\n        # type: () -> S\r\n        if not self.pyproject.exists():\r\n            if not self.build_requires:\r\n                build_requires = '\"setuptools\", \"wheel\"'\r\n            else:\r\n                build_requires = \", \".join(\r\n                    ['\"{0}\"'.format(r) for r in self.build_requires]\r\n                )\r\n            self.pyproject.write_text(\r\n                six.text_type(\r\n                    \"\"\"\r\n[build-system]\r\nrequires = [{0}]\r\nbuild-backend = \"{1}\"\r\n                \"\"\".format(\r\n                        build_requires, self.build_backend\r\n                    ).strip()\r\n                )\r\n            )\r\n        return build_pep517(\r\n            self.base_dir,\r\n            self.extra_kwargs[\"build_dir\"],\r\n            config_settings=self.pep517_config,\r\n            dist_type=\"sdist\",\r\n        )\r\n\r\n    def build(self):\r\n        # type: () -> \"SetupInfo\"\r\n        dist_path = None\r\n        metadata = None\r\n        try:\r\n            dist_path = self.build_wheel()\r\n            metadata = self.get_metadata_from_wheel(\r\n                os.path.join(self.extra_kwargs[\"build_dir\"], dist_path)\r\n            )\r\n        except Exception:\r\n            try:\r\n                dist_path = self.build_sdist()\r\n                metadata = self.get_egg_metadata(metadata_type=\"egg\")\r\n                if metadata:\r\n                    self.populate_metadata(metadata)\r\n            except Exception:\r\n                pass\r\n        if metadata:\r\n            self.populate_metadata(metadata)\r\n        if not self.metadata or not self.name:\r\n            metadata = self.get_egg_metadata()\r\n            if metadata:\r\n                self.populate_metadata(metadata)\r\n        if not self.metadata or not self.name:\r\n            return self.run_setup()\r\n        return self\r\n\r\n    def reload(self):\r\n        # type: () -> Dict[S, Any]\r\n        \"\"\"Wipe existing distribution info metadata for rebuilding.\r\n\r\n        Erases metadata from **self.egg_base** and unsets\r\n        **self.requirements** and **self.extras**.\r\n        \"\"\"\r\n        for metadata_dir in os.listdir(self.egg_base):\r\n            shutil.rmtree(metadata_dir, ignore_errors=True)\r\n        self.metadata = None\r\n        self._requirements = frozenset()\r\n        self._extras_requirements = ()\r\n        self.get_info()\r\n\r\n    def get_metadata_from_wheel(self, wheel_path):\r\n        # type: (S) -> Dict[Any, Any]\r\n        \"\"\"Given a path to a wheel, return the metadata from that wheel.\r\n\r\n        :return: A dictionary of metadata from the provided wheel\r\n        :rtype: Dict[Any, Any]\r\n        \"\"\"\r\n\r\n        metadata_dict = get_metadata_from_wheel(wheel_path)\r\n        return metadata_dict\r\n\r\n    def get_egg_metadata(self, metadata_dir=None, metadata_type=None):\r\n        # type: (Optional[AnyStr], Optional[AnyStr]) -> Dict[Any, Any]\r\n        \"\"\"Given a metadata directory, return the corresponding metadata\r\n        dictionary.\r\n\r\n        :param Optional[str] metadata_dir: Root metadata path, default: `os.getcwd()`\r\n        :param Optional[str] metadata_type: Type of metadata to search for, default None\r\n        :return: A metadata dictionary built from the metadata in the given location\r\n        :rtype: Dict[Any, Any]\r\n        \"\"\"\r\n\r\n        package_indicators = [self.pyproject, self.setup_py, self.setup_cfg]\r\n        metadata_dirs = []  # type: List[STRING_TYPE]\r\n        if any([fn is not None and fn.exists() for fn in package_indicators]):\r\n            metadata_dirs = [\r\n                self.extra_kwargs[\"build_dir\"],\r\n                self.egg_base,\r\n                self.extra_kwargs[\"src_dir\"],\r\n            ]\r\n        if metadata_dir is not None:\r\n            metadata_dirs = [metadata_dir] + metadata_dirs\r\n        metadata = [\r\n            get_metadata(d, pkg_name=self.name, metadata_type=metadata_type)\r\n            for d in metadata_dirs\r\n            if os.path.exists(d)\r\n        ]\r\n        metadata = next(iter(d for d in metadata if d), None)\r\n        return metadata\r\n\r\n    def populate_metadata(self, metadata):\r\n        # type: (Dict[Any, Any]) -> \"SetupInfo\"\r\n        \"\"\"Populates the metadata dictionary from the supplied metadata.\r\n\r\n        :return: The current instance.\r\n        :rtype: `SetupInfo`\r\n        \"\"\"\r\n\r\n        _metadata = ()\r\n        for k, v in metadata.items():\r\n            if k == \"extras\" and isinstance(v, dict):\r\n                extras = ()\r\n                for extra, reqs in v.items():\r\n                    extras += ((extra, tuple(reqs)),)\r\n                _metadata += extras\r\n            elif isinstance(v, (list, tuple)):\r\n                _metadata += (k, tuple(v))\r\n            else:\r\n                _metadata += (k, v)\r\n        self.metadata = _metadata\r\n        cleaned = metadata.copy()\r\n        cleaned.update({\"install_requires\": metadata.get(\"requires\", [])})\r\n        if cleaned:\r\n            self.update_from_dict(cleaned.copy())\r\n        else:\r\n            self.update_from_dict(metadata)\r\n        return self\r\n\r\n    def run_pyproject(self):\r\n        # type: () -> \"SetupInfo\"\r\n        \"\"\"Populates the **pyproject.toml** metadata if available.\r\n\r\n        :return: The current instance\r\n        :rtype: `SetupInfo`\r\n        \"\"\"\r\n\r\n        if self.pyproject and self.pyproject.exists():\r\n            result = get_pyproject(self.pyproject.parent)\r\n            if result is not None:\r\n                requires, backend = result\r\n                if self.build_requires is None:\r\n                    self.build_requires = ()\r\n                if backend:\r\n                    self.build_backend = backend\r\n                else:\r\n                    self.build_backend = get_default_pyproject_backend()\r\n                if requires:\r\n                    self.build_requires = tuple(set(requires) | set(self.build_requires))\r\n                else:\r\n                    self.build_requires = (\"setuptools\", \"wheel\")\r\n        return self\r\n\r\n    def get_initial_info(self):\r\n        # type: () -> Dict[S, Any]\r\n        parse_setupcfg = False\r\n        parse_setuppy = False\r\n        if self.setup_cfg and self.setup_cfg.exists():\r\n            parse_setupcfg = True\r\n        if self.setup_py and self.setup_py.exists():\r\n            parse_setuppy = True\r\n        if parse_setuppy or parse_setupcfg:\r\n            with cd(self.base_dir):\r\n                if parse_setuppy:\r\n                    self.update_from_dict(self.parse_setup_py())\r\n                if parse_setupcfg:\r\n                    self.update_from_dict(self.parse_setup_cfg())\r\n            if self.name is not None and any(\r\n                [\r\n                    self.requires,\r\n                    self.setup_requires,\r\n                    self._extras_requirements,\r\n                    self.build_backend,\r\n                ]\r\n            ):\r\n                return self.as_dict()\r\n        return self.get_info()\r\n\r\n    def get_info(self):\r\n        # type: () -> Dict[S, Any]\r\n        with cd(self.base_dir):\r\n            self.run_pyproject()\r\n            self.build()\r\n\r\n        if self.setup_py and self.setup_py.exists() and self.metadata is None:\r\n            if not self.requires or not self.name:\r\n                try:\r\n                    with cd(self.base_dir):\r\n                        self.run_setup()\r\n                except Exception:\r\n                    with cd(self.base_dir):\r\n                        metadata = self.get_egg_metadata()\r\n                        if metadata:\r\n                            self.populate_metadata(metadata)\r\n                if self.metadata is None or not self.name:\r\n                    with cd(self.base_dir):\r\n                        metadata = self.get_egg_metadata()\r\n                        if metadata:\r\n                            self.populate_metadata(metadata)\r\n\r\n        return self.as_dict()\r\n\r\n    def as_dict(self):\r\n        # type: () -> Dict[STRING_TYPE, Any]\r\n        prop_dict = {\r\n            \"name\": self.name,\r\n            \"version\": self.version if self._version else None,\r\n            \"base_dir\": self.base_dir,\r\n            \"ireq\": self.ireq,\r\n            \"build_backend\": self.build_backend,\r\n            \"build_requires\": self.build_requires,\r\n            \"requires\": self.requires if self._requirements else None,\r\n            \"setup_requires\": self.setup_requires,\r\n            \"python_requires\": self.python_requires,\r\n            \"extras\": self.extras if self._extras_requirements else None,\r\n            \"extra_kwargs\": self.extra_kwargs,\r\n            \"setup_cfg\": self.setup_cfg,\r\n            \"setup_py\": self.setup_py,\r\n            \"pyproject\": self.pyproject,\r\n        }\r\n        return {k: v for k, v in prop_dict.items() if v}\r\n\r\n    @classmethod\r\n    def from_requirement(cls, requirement, finder=None):\r\n        # type: (TRequirement, Optional[PackageFinder]) -> Optional[SetupInfo]\r\n        ireq = requirement.as_ireq()\r\n        subdir = getattr(requirement.req, \"subdirectory\", None)\r\n        return cls.from_ireq(ireq, subdir=subdir, finder=finder)\r\n\r\n    @classmethod\r\n    @lru_cache()\r\n    def from_ireq(cls, ireq, subdir=None, finder=None, session=None):\r\n        # type: (InstallRequirement, Optional[AnyStr], Optional[PackageFinder], Optional[requests.Session]) -> Optional[SetupInfo]\r\n        import pip_shims.shims\r\n\r\n        if not ireq.link:\r\n            return None\r\n        if ireq.link.is_wheel:\r\n            return None\r\n        stack = ExitStack()\r\n        if not session:\r\n            cmd = pip_shims.shims.InstallCommand()\r\n            options, _ = cmd.parser.parse_args([])\r\n            session = cmd._build_session(options)\r\n            finder = cmd._build_package_finder(options, session)\r\n        tempdir_manager = stack.enter_context(pip_shims.shims.global_tempdir_manager())\r\n        vcs, uri = split_vcs_method_from_uri(unquote(ireq.link.url_without_fragment))\r\n        parsed = urlparse(uri)\r\n        if \"file\" in parsed.scheme:\r\n            url_path = parsed.path\r\n            if \"@\" in url_path:\r\n                url_path, _, _ = url_path.rpartition(\"@\")\r\n            parsed = parsed._replace(path=url_path)\r\n            uri = urlunparse(parsed)\r\n        path = None\r\n        is_file = False\r\n        if ireq.link.scheme == \"file\" or uri.startswith(\"file://\"):\r\n            is_file = True\r\n            if \"file:/\" in uri and \"file:///\" not in uri:\r\n                uri = uri.replace(\"file:/\", \"file:///\")\r\n            path = pip_shims.shims.url_to_path(uri)\r\n        kwargs = _prepare_wheel_building_kwargs(ireq)\r\n        is_artifact_or_vcs = getattr(\r\n            ireq.link, \"is_vcs\", getattr(ireq.link, \"is_artifact\", False)\r\n        )\r\n        is_vcs = True if vcs else is_artifact_or_vcs\r\n        if is_file and not is_vcs and path is not None and os.path.isdir(path):\r\n            target = os.path.join(kwargs[\"src_dir\"], os.path.basename(path))\r\n            shutil.copytree(path, target)\r\n            ireq.source_dir = target\r\n        if not (ireq.editable and is_file and is_vcs):\r\n            if ireq.is_wheel:\r\n                only_download = True\r\n                download_dir = kwargs[\"wheel_download_dir\"]\r\n            else:\r\n                only_download = False\r\n                download_dir = kwargs[\"download_dir\"]\r\n        elif path is not None and os.path.isdir(path):\r\n            raise RequirementError(\r\n                \"The file URL points to a directory not installable: {}\".format(ireq.link)\r\n            )\r\n        # this ensures the build dir is treated as the temporary build location\r\n        # and the source dir is treated as permanent / not deleted by pip\r\n        build_location_func = getattr(ireq, \"build_location\", None)\r\n        if build_location_func is None:\r\n            build_location_func = getattr(ireq, \"ensure_build_location\", None)\r\n        if not ireq.source_dir:\r\n            build_kwargs = {\"build_dir\": kwargs[\"build_dir\"], \"autodelete\": False}\r\n            call_function_with_correct_args(build_location_func, **build_kwargs)\r\n            ireq.ensure_has_source_dir(kwargs[\"src_dir\"])\r\n            src_dir = ireq.source_dir\r\n            pip_shims.shims.shim_unpack(\r\n                download_dir=download_dir,\r\n                ireq=ireq,\r\n                only_download=only_download,\r\n                session=session,\r\n                hashes=ireq.hashes(False),\r\n            )\r\n        created = cls.create(\r\n            ireq.source_dir, subdirectory=subdir, ireq=ireq, kwargs=kwargs, stack=stack\r\n        )\r\n        return created\r\n\r\n    @classmethod\r\n    def create(\r\n        cls,\r\n        base_dir,  # type: str\r\n        subdirectory=None,  # type: Optional[str]\r\n        ireq=None,  # type: Optional[InstallRequirement]\r\n        kwargs=None,  # type: Optional[Dict[str, str]]\r\n        stack=None,  # type: Optional[ExitStack]\r\n    ):\r\n        # type: (...) -> Optional[SetupInfo]\r\n        if not base_dir or base_dir is None:\r\n            return None\r\n\r\n        creation_kwargs = {\"extra_kwargs\": kwargs}\r\n        if not isinstance(base_dir, Path):\r\n            base_dir = Path(base_dir)\r\n        creation_kwargs[\"base_dir\"] = base_dir.as_posix()\r\n        pyproject = base_dir.joinpath(\"pyproject.toml\")\r\n\r\n        if subdirectory is not None:\r\n            base_dir = base_dir.joinpath(subdirectory)\r\n        setup_py = base_dir.joinpath(\"setup.py\")\r\n        setup_cfg = base_dir.joinpath(\"setup.cfg\")\r\n        creation_kwargs[\"pyproject\"] = pyproject\r\n        creation_kwargs[\"setup_py\"] = setup_py\r\n        creation_kwargs[\"setup_cfg\"] = setup_cfg\r\n        if stack is None:\r\n            stack = ExitStack()\r\n        creation_kwargs[\"stack\"] = stack\r\n        if ireq:\r\n            creation_kwargs[\"ireq\"] = ireq\r\n        created = cls(**creation_kwargs)\r\n        created.get_initial_info()\r\n        return created\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- env/Lib/site-packages/pipenv/vendor/requirementslib/models/setup_info.py	(revision 7de091c5b19e7b06e80c151f7100df6d0f893820)
+++ env/Lib/site-packages/pipenv/vendor/requirementslib/models/setup_info.py	(date 1591098443928)
@@ -469,21 +469,18 @@
     # type: (AnyStr, Optional[AnyStr], AnyStr) -> Generator
     if pkg_name is not None:
         pkg_variants = get_name_variants(pkg_name)
-    non_matching_dirs = []
-    with contextlib.closing(ScandirCloser(path)) as path_iterator:
-        for entry in path_iterator:
-            if entry.is_dir():
-                entry_name, ext = os.path.splitext(entry.name)
-                if ext.endswith(metadata_type):
-                    if pkg_name is None or entry_name.lower() in pkg_variants:
-                        yield entry
-                elif not entry.name.endswith(metadata_type):
-                    non_matching_dirs.append(entry)
-        for entry in non_matching_dirs:
-            for dir_entry in iter_metadata(
-                entry.path, pkg_name=pkg_name, metadata_type=metadata_type
-            ):
-                yield dir_entry
+    dirs_to_search = [path]
+    while dirs_to_search:
+        p = dirs_to_search.pop(0)
+        with contextlib.closing(ScandirCloser(p)) as path_iterator:
+            for entry in path_iterator:
+                if entry.is_dir():
+                    entry_name, ext = os.path.splitext(entry.name)
+                    if ext.endswith(metadata_type):
+                        if pkg_name is None or entry_name.lower() in pkg_variants:
+                            yield entry
+                    elif not entry.name.endswith(metadata_type):
+                        dirs_to_search.append(entry.path)
 
 
 def find_egginfo(target, pkg_name=None):
@@ -729,14 +726,16 @@
             self.binOps_map[binop] = ast_unparse(binop, analyzer=self)
 
     def match_assignment_str(self, match):
-        return next(
-            iter(k for k in self.assignments if getattr(k, "id", "") == match), None
-        )
+        matches = [k for k in self.assignments if getattr(k, "id", "") == match]
+        if matches:
+            return matches[-1]
+        return None
 
     def match_assignment_name(self, match):
-        return next(
-            iter(k for k in self.assignments if getattr(k, "id", "") == match.id), None
-        )
+        matches = [k for k in self.assignments if getattr(k, "id", "") == match.id]
+        if matches:
+            return matches[-1]
+        return None
 
     def generic_unparse(self, item):
         if any(isinstance(item, k) for k in AST_BINOP_MAP.keys()):
@@ -771,7 +770,7 @@
         if isinstance(item.slice, ast.Index):
             try:
                 unparsed = unparsed[self.unparse(item.slice.value)]
-            except KeyError:
+            except (KeyError, TypeError):
                 # not everything can be looked up before runtime
                 unparsed = item
         return unparsed
@@ -838,7 +837,7 @@
         if isinstance(item.left, ast.Attribute) or isinstance(item.left, ast.Str):
             import importlib
 
-            left = unparse(item.left)
+            left = self.unparse(item.left)
             if "." in left:
                 name, _, val = left.rpartition(".")
                 left = getattr(importlib.import_module(name), val, left)
@@ -975,6 +974,16 @@
         keys = list(setup.keys())
         if len(keys) == 1 and keys[0] is None:
             _, setup = setup.popitem()
+        keys = list(setup.keys())
+        for k in keys:
+            # XXX: Remove unresolved functions from the setup dictionary
+            if isinstance(setup[k], dict):
+                if not setup[k]:
+                    continue
+                key = next(iter(setup[k].keys()))
+                val = setup[k][key]
+                if key in function_names and val is None or val == {}:
+                    setup.pop(k)
         return setup
 
 
@@ -1002,7 +1011,7 @@
             if isinstance(item.slice, ast.Index):
                 try:
                     unparsed = unparsed[unparse(item.slice.value)]
-                except KeyError:
+                except (KeyError, TypeError):
                     # not everything can be looked up before runtime
                     unparsed = item
     elif any(isinstance(item, k) for k in AST_BINOP_MAP.keys()):
@@ -1205,6 +1214,16 @@
     keys = list(setup.keys())
     if len(keys) == 1 and keys[0] is None:
         _, setup = setup.popitem()
+    keys = list(setup.keys())
+    for k in keys:
+        # XXX: Remove unresolved functions from the setup dictionary
+        if isinstance(setup[k], dict):
+            if not setup[k]:
+                continue
+            key = next(iter(setup[k].keys()))
+            val = setup[k][key]
+            if key in function_names and val is None or val == {}:
+                setup.pop(k)
     return setup
 
 
@@ -1848,7 +1867,7 @@
         is_vcs = True if vcs else is_artifact_or_vcs
         if is_file and not is_vcs and path is not None and os.path.isdir(path):
             target = os.path.join(kwargs["src_dir"], os.path.basename(path))
-            shutil.copytree(path, target)
+            shutil.copytree(path, target, symlinks=True)
             ireq.source_dir = target
         if not (ireq.editable and is_file and is_vcs):
             if ireq.is_wheel:
Index: env/Lib/site-packages/pipenv/vendor/requirementslib/models/requirements.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># -*- coding: utf-8 -*-\r\n\r\nfrom __future__ import absolute_import, print_function\r\n\r\nimport collections\r\nimport copy\r\nimport os\r\nimport sys\r\nfrom contextlib import contextmanager\r\nfrom distutils.sysconfig import get_python_lib\r\nfrom functools import partial\r\n\r\nfrom pipenv.vendor import attr\r\nimport pip_shims\r\nimport six\r\nimport vistir\r\nfrom cached_property import cached_property\r\nfrom packaging.markers import Marker\r\nfrom packaging.requirements import Requirement as PackagingRequirement\r\nfrom packaging.specifiers import (\r\n    InvalidSpecifier,\r\n    LegacySpecifier,\r\n    Specifier,\r\n    SpecifierSet,\r\n)\r\nfrom packaging.utils import canonicalize_name\r\nfrom six.moves.urllib import parse as urllib_parse\r\nfrom six.moves.urllib.parse import unquote\r\nfrom vistir.compat import FileNotFoundError, Path, lru_cache\r\nfrom vistir.contextmanagers import temp_path\r\nfrom vistir.misc import dedup\r\nfrom vistir.path import (\r\n    create_tracked_tempdir,\r\n    get_converted_relative_path,\r\n    is_file_url,\r\n    is_valid_url,\r\n    mkdir_p,\r\n    normalize_path,\r\n)\r\n\r\nfrom ..environment import MYPY_RUNNING\r\nfrom ..exceptions import RequirementError\r\nfrom ..utils import (\r\n    VCS_LIST,\r\n    add_ssh_scheme_to_git_uri,\r\n    get_setup_paths,\r\n    is_installable_dir,\r\n    is_installable_file,\r\n    is_vcs,\r\n    strip_ssh_from_git_uri,\r\n)\r\nfrom .markers import (\r\n    cleanup_pyspecs,\r\n    contains_pyversion,\r\n    format_pyversion,\r\n    get_contained_pyversions,\r\n    normalize_marker_str,\r\n)\r\nfrom .setup_info import (\r\n    SetupInfo,\r\n    _prepare_wheel_building_kwargs,\r\n    ast_parse_setup_py,\r\n    get_metadata,\r\n    parse_setup_cfg,\r\n)\r\nfrom .url import URI\r\nfrom .utils import (\r\n    DIRECT_URL_RE,\r\n    HASH_STRING,\r\n    URL_RE,\r\n    build_vcs_uri,\r\n    convert_direct_url_to_url,\r\n    create_link,\r\n    extras_to_string,\r\n    filter_none,\r\n    format_requirement,\r\n    get_default_pyproject_backend,\r\n    get_pyproject,\r\n    get_version,\r\n    init_requirement,\r\n    is_pinned_requirement,\r\n    make_install_requirement,\r\n    normalize_name,\r\n    parse_extras,\r\n    read_source,\r\n    specs_to_string,\r\n    split_markers_from_line,\r\n    split_ref_from_uri,\r\n    split_vcs_method_from_uri,\r\n    validate_path,\r\n    validate_specifiers,\r\n    validate_vcs,\r\n)\r\n\r\nif MYPY_RUNNING:\r\n    from typing import (\r\n        Optional,\r\n        TypeVar,\r\n        List,\r\n        Dict,\r\n        Union,\r\n        Any,\r\n        Tuple,\r\n        Sequence,\r\n        Set,\r\n        AnyStr,\r\n        Text,\r\n        Generator,\r\n        FrozenSet,\r\n    )\r\n    from pip_shims.shims import (\r\n        Link,\r\n        InstallRequirement,\r\n        PackageFinder,\r\n        InstallationCandidate,\r\n    )\r\n\r\n    RequirementType = TypeVar(\r\n        \"RequirementType\", covariant=True, bound=PackagingRequirement\r\n    )\r\n    F = TypeVar(\"F\", \"FileRequirement\", \"VCSRequirement\", covariant=True)\r\n    from six.moves.urllib.parse import SplitResult\r\n    from .vcs import VCSRepository\r\n    from .dependencies import AbstractDependency\r\n\r\n    NON_STRING_ITERABLE = Union[List, Set, Tuple]\r\n    STRING_TYPE = Union[str, bytes, Text]\r\n    S = TypeVar(\"S\", bytes, str, Text)\r\n    BASE_TYPES = Union[bool, STRING_TYPE, Tuple[STRING_TYPE, ...]]\r\n    CUSTOM_TYPES = Union[VCSRepository, RequirementType, SetupInfo, \"Line\"]\r\n    CREATION_ARG_TYPES = Union[BASE_TYPES, Link, CUSTOM_TYPES]\r\n    PIPFILE_ENTRY_TYPE = Union[STRING_TYPE, bool, Tuple[STRING_TYPE], List[STRING_TYPE]]\r\n    PIPFILE_TYPE = Union[STRING_TYPE, Dict[STRING_TYPE, PIPFILE_ENTRY_TYPE]]\r\n    TPIPFILE = Dict[STRING_TYPE, PIPFILE_ENTRY_TYPE]\r\n\r\n\r\nSPECIFIERS_BY_LENGTH = sorted(list(Specifier._operators.keys()), key=len, reverse=True)\r\n\r\n\r\nclass Line(object):\r\n    def __init__(self, line, extras=None):\r\n        # type: (AnyStr, Optional[Union[List[S], Set[S], Tuple[S, ...]]]) -> None\r\n        self.editable = False  # type: bool\r\n        if line.startswith(\"-e \"):\r\n            line = line[len(\"-e \") :]\r\n            self.editable = True\r\n        self.extras = ()  # type: Tuple[STRING_TYPE, ...]\r\n        if extras is not None:\r\n            self.extras = tuple(sorted(set(extras)))\r\n        self.line = line  # type: STRING_TYPE\r\n        self.hashes = []  # type: List[STRING_TYPE]\r\n        self.markers = None  # type: Optional[STRING_TYPE]\r\n        self.vcs = None  # type: Optional[STRING_TYPE]\r\n        self.path = None  # type: Optional[STRING_TYPE]\r\n        self.relpath = None  # type: Optional[STRING_TYPE]\r\n        self.uri = None  # type: Optional[STRING_TYPE]\r\n        self._link = None  # type: Optional[Link]\r\n        self.is_local = False  # type: bool\r\n        self._name = None  # type: Optional[STRING_TYPE]\r\n        self._specifier = None  # type: Optional[STRING_TYPE]\r\n        self.parsed_marker = None  # type: Optional[Marker]\r\n        self.preferred_scheme = None  # type: Optional[STRING_TYPE]\r\n        self._requirement = None  # type: Optional[PackagingRequirement]\r\n        self._parsed_url = None  # type: Optional[URI]\r\n        self._setup_cfg = None  # type: Optional[STRING_TYPE]\r\n        self._setup_py = None  # type: Optional[STRING_TYPE]\r\n        self._pyproject_toml = None  # type: Optional[STRING_TYPE]\r\n        self._pyproject_requires = None  # type: Optional[Tuple[STRING_TYPE, ...]]\r\n        self._pyproject_backend = None  # type: Optional[STRING_TYPE]\r\n        self._wheel_kwargs = None  # type: Optional[Dict[STRING_TYPE, STRING_TYPE]]\r\n        self._vcsrepo = None  # type: Optional[VCSRepository]\r\n        self._setup_info = None  # type: Optional[SetupInfo]\r\n        self._ref = None  # type: Optional[STRING_TYPE]\r\n        self._ireq = None  # type: Optional[InstallRequirement]\r\n        self._src_root = None  # type: Optional[STRING_TYPE]\r\n        self.dist = None  # type: Any\r\n        super(Line, self).__init__()\r\n        self.parse()\r\n\r\n    def __hash__(self):\r\n        return hash(\r\n            (\r\n                self.editable,\r\n                self.line,\r\n                self.markers,\r\n                tuple(self.extras),\r\n                tuple(self.hashes),\r\n                self.vcs,\r\n                self.uri,\r\n                self.path,\r\n                self.name,\r\n                self._requirement,\r\n            )\r\n        )\r\n\r\n    def __repr__(self):\r\n        try:\r\n            return (\r\n                \"<Line (editable={self.editable}, name={self._name}, path={self.path}, \"\r\n                \"uri={self.uri}, extras={self.extras}, markers={self.markers}, vcs={self.vcs}\"\r\n                \", specifier={self._specifier}, pyproject={self._pyproject_toml}, \"\r\n                \"pyproject_requires={self._pyproject_requires}, \"\r\n                \"pyproject_backend={self._pyproject_backend}, ireq={self._ireq})>\".format(\r\n                    self=self\r\n                )\r\n            )\r\n        except Exception:\r\n            return \"<Line {0}>\".format(self.__dict__.values())\r\n\r\n    def __str__(self):\r\n        # type: () -> str\r\n        if self.markers:\r\n            return \"{0}; {1}\".format(self.get_line(), self.markers)\r\n        return self.get_line()\r\n\r\n    def get_line(\r\n        self, with_prefix=False, with_markers=False, with_hashes=True, as_list=False\r\n    ):\r\n        # type: (bool, bool, bool, bool) -> Union[STRING_TYPE, List[STRING_TYPE]]\r\n        line = self.line\r\n        extras_str = extras_to_string(self.extras)\r\n        with_hashes = False if self.editable or self.is_vcs else with_hashes\r\n        hash_list = [\"--hash={0}\".format(h) for h in self.hashes]\r\n        if self.is_named:\r\n            line = self.name_and_specifier\r\n        elif self.is_direct_url:\r\n            line = self.link.url\r\n        elif extras_str:\r\n            if self.is_vcs:\r\n                line = self.link.url\r\n                if \"git+file:/\" in line and \"git+file:///\" not in line:\r\n                    line = line.replace(\"git+file:/\", \"git+file:///\")\r\n            elif extras_str not in line:\r\n                line = \"{0}{1}\".format(line, extras_str)\r\n        # XXX: For using markers on vcs or url requirements, they can be used\r\n        # as normal (i.e. no space between the requirement and the semicolon)\r\n        # and no additional quoting as long as they are not editable requirements\r\n        # HOWEVER, for editable requirements, the requirement+marker must be quoted\r\n        # We do this here for the line-formatted versions, but leave it up to the\r\n        # `Script.parse()` functionality in pipenv, for instance, to handle that\r\n        # in a cross-platform manner for the `as_list` approach since that is how\r\n        # we anticipate this will be used if passing directly to the command line\r\n        # for pip.\r\n        if with_markers and self.markers:\r\n            line = \"{0}; {1}\".format(line, self.markers)\r\n            if with_prefix and self.editable and not as_list:\r\n                line = '\"{0}\"'.format(line)\r\n        if as_list:\r\n            result_list = []\r\n            if with_prefix and self.editable:\r\n                result_list.append(\"-e\")\r\n            result_list.append(line)\r\n            if with_hashes:\r\n                result_list.extend(self.hashes)\r\n            return result_list\r\n        if with_prefix and self.editable:\r\n            line = \"-e {0}\".format(line)\r\n        if with_hashes and hash_list:\r\n            line = \"{0} {1}\".format(line, \" \".join(hash_list))\r\n        return line\r\n\r\n    @property\r\n    def name_and_specifier(self):\r\n        name_str, spec_str = \"\", \"\"\r\n        if self.name:\r\n            name_str = \"{0}\".format(self.name.lower())\r\n            extras_str = extras_to_string(self.extras)\r\n            if extras_str:\r\n                name_str = \"{0}{1}\".format(name_str, extras_str)\r\n        if self.specifier:\r\n            spec_str = \"{0}\".format(self.specifier)\r\n        return \"{0}{1}\".format(name_str, spec_str)\r\n\r\n    @classmethod\r\n    def split_hashes(cls, line):\r\n        # type: (S) -> Tuple[S, List[S]]\r\n        if \"--hash\" not in line:\r\n            return line, []\r\n        split_line = line.split()\r\n        line_parts = []  # type: List[S]\r\n        hashes = []  # type: List[S]\r\n        for part in split_line:\r\n            if part.startswith(\"--hash\"):\r\n                param, _, value = part.partition(\"=\")\r\n                hashes.append(value)\r\n            else:\r\n                line_parts.append(part)\r\n        line = \" \".join(line_parts)\r\n        return line, hashes\r\n\r\n    @property\r\n    def line_with_prefix(self):\r\n        # type: () -> STRING_TYPE\r\n        return self.get_line(with_prefix=True, with_hashes=False)\r\n\r\n    @property\r\n    def line_for_ireq(self):\r\n        # type: () -> STRING_TYPE\r\n        line = \"\"  # type: STRING_TYPE\r\n        if self.is_file or self.is_remote_url and not self.is_vcs:\r\n            scheme = self.preferred_scheme if self.preferred_scheme is not None else \"uri\"\r\n            local_line = next(\r\n                iter(\r\n                    [\r\n                        os.path.dirname(os.path.abspath(f))\r\n                        for f in [self.setup_py, self.setup_cfg, self.pyproject_toml]\r\n                        if f is not None\r\n                    ]\r\n                ),\r\n                None,\r\n            )\r\n            if local_line and self.extras:\r\n                local_line = \"{0}{1}\".format(local_line, extras_to_string(self.extras))\r\n            line = local_line if local_line is not None else self.line\r\n            if scheme == \"path\":\r\n                if not line and self.base_path is not None:\r\n                    line = os.path.abspath(self.base_path)\r\n            else:\r\n                if DIRECT_URL_RE.match(self.line):\r\n                    uri = URI.parse(self.line)\r\n                    line = uri.full_url\r\n                    self._requirement = init_requirement(self.line)\r\n                    line = convert_direct_url_to_url(self.line)\r\n                else:\r\n                    if self.link:\r\n                        line = self.link.url\r\n                    else:\r\n                        try:\r\n                            uri = URI.parse(line)\r\n                        except ValueError:\r\n                            line = line\r\n                        else:\r\n                            line = uri.base_url\r\n                            self._link = uri.as_link\r\n\r\n        if self.editable:\r\n            if not line:\r\n                if self.is_path or self.is_file:\r\n                    if not self.path and self.url is not None:\r\n                        line = pip_shims.shims.url_to_path(self.url)\r\n                    else:\r\n                        line = self.path\r\n                    if self.extras:\r\n                        line = \"{0}{1}\".format(line, extras_to_string(self.extras))\r\n                else:\r\n                    line = self.link.url\r\n        elif self.is_vcs and not self.editable:\r\n            line = add_ssh_scheme_to_git_uri(self.line)\r\n        if not line:\r\n            line = self.line\r\n        return line\r\n\r\n    @property\r\n    def base_path(self):\r\n        # type: () -> Optional[S]\r\n        if not self.link and not self.path:\r\n            self.parse_link()\r\n        if not self.path:\r\n            pass\r\n        path = normalize_path(self.path)\r\n        if os.path.exists(path) and os.path.isdir(path):\r\n            path = path\r\n        elif os.path.exists(path) and os.path.isfile(path):\r\n            path = os.path.dirname(path)\r\n        else:\r\n            path = None\r\n        return path\r\n\r\n    @property\r\n    def setup_py(self):\r\n        # type: () -> Optional[STRING_TYPE]\r\n        if self._setup_py is None:\r\n            self.populate_setup_paths()\r\n        return self._setup_py\r\n\r\n    @property\r\n    def setup_cfg(self):\r\n        # type: () -> Optional[STRING_TYPE]\r\n        if self._setup_cfg is None:\r\n            self.populate_setup_paths()\r\n        return self._setup_cfg\r\n\r\n    @property\r\n    def pyproject_toml(self):\r\n        # type: () -> Optional[STRING_TYPE]\r\n        if self._pyproject_toml is None:\r\n            self.populate_setup_paths()\r\n        return self._pyproject_toml\r\n\r\n    @property\r\n    def specifier(self):\r\n        # type: () -> Optional[STRING_TYPE]\r\n        options = [self._specifier]\r\n        for req in (self.ireq, self.requirement):\r\n            if req is not None and getattr(req, \"specifier\", None):\r\n                options.append(req.specifier)\r\n        specifier = next(\r\n            iter(spec for spec in options if spec is not None), None\r\n        )  # type: Optional[Union[Specifier, SpecifierSet]]\r\n        spec_string = None  # type: Optional[STRING_TYPE]\r\n        if specifier is not None:\r\n            spec_string = specs_to_string(specifier)\r\n        elif (\r\n            specifier is None\r\n            and not self.is_named\r\n            and (self._setup_info is not None and self._setup_info.version)\r\n        ):\r\n            spec_string = \"=={0}\".format(self._setup_info.version)\r\n        if spec_string:\r\n            self._specifier = spec_string\r\n        return self._specifier\r\n\r\n    @specifier.setter\r\n    def specifier(self, spec):\r\n        # type: (str) -> None\r\n        if not spec.startswith(\"==\"):\r\n            spec = \"=={0}\".format(spec)\r\n        self._specifier = spec\r\n        self.specifiers = SpecifierSet(spec)\r\n\r\n    @property\r\n    def specifiers(self):\r\n        # type: () -> Optional[SpecifierSet]\r\n        ireq_needs_specifier = False\r\n        req_needs_specifier = False\r\n        if self.ireq is None or self.ireq.req is None or not self.ireq.req.specifier:\r\n            ireq_needs_specifier = True\r\n        if self.requirement is None or not self.requirement.specifier:\r\n            req_needs_specifier = True\r\n        if any([ireq_needs_specifier, req_needs_specifier]):\r\n            # TODO: Should we include versions for VCS dependencies? IS there a reason not\r\n            # to? For now we are using hashes as the equivalent to pin\r\n            # note: we need versions for direct dependencies at the very least\r\n            if (\r\n                self.is_file\r\n                or self.is_remote_url\r\n                or self.is_path\r\n                or (self.is_vcs and not self.editable)\r\n            ):\r\n                if self.specifier is not None:\r\n                    specifier = self.specifier\r\n                    if not isinstance(specifier, SpecifierSet):\r\n                        specifier = SpecifierSet(specifier)\r\n                    self.specifiers = specifier\r\n                    return specifier\r\n        if self.ireq is not None and self.ireq.req is not None:\r\n            return self.ireq.req.specifier\r\n        elif self.requirement is not None:\r\n            return self.requirement.specifier\r\n        return None\r\n\r\n    @specifiers.setter\r\n    def specifiers(self, specifiers):\r\n        # type: (Union[Text, str, SpecifierSet]) -> None\r\n        if not isinstance(specifiers, SpecifierSet):\r\n            if isinstance(specifiers, six.string_types):\r\n                specifiers = SpecifierSet(specifiers)\r\n            else:\r\n                raise TypeError(\"Must pass a string or a SpecifierSet\")\r\n        specs = self.get_requirement_specs(specifiers)\r\n        if self.ireq is not None and self._ireq and self._ireq.req is not None:\r\n            self._ireq.req.specifier = specifiers\r\n            self._ireq.req.specs = specs\r\n        if self.requirement is not None:\r\n            self.requirement.specifier = specifiers\r\n            self.requirement.specs = specs\r\n\r\n    @classmethod\r\n    def get_requirement_specs(cls, specifierset):\r\n        # type: (SpecifierSet) -> List[Tuple[AnyStr, AnyStr]]\r\n        specs = []\r\n        spec = next(iter(specifierset._specs), None)\r\n        if spec:\r\n            specs.append(spec._spec)\r\n        return specs\r\n\r\n    @property\r\n    def requirement(self):\r\n        # type: () -> Optional[RequirementType]\r\n        if self._requirement is None:\r\n            self.parse_requirement()\r\n            if self._requirement is None and self._name is not None:\r\n                self._requirement = init_requirement(canonicalize_name(self.name))\r\n                if self.is_file or self.is_remote_url and self._requirement is not None:\r\n                    self._requirement.url = self.url\r\n        if (\r\n            self._requirement\r\n            and self._requirement.specifier\r\n            and not self._requirement.specs\r\n        ):\r\n            specs = self.get_requirement_specs(self._requirement.specifier)\r\n            self._requirement.specs = specs\r\n        return self._requirement\r\n\r\n    def populate_setup_paths(self):\r\n        # type: () -> None\r\n        if not self.link and not self.path:\r\n            self.parse_link()\r\n        if not self.path:\r\n            return\r\n        base_path = self.base_path\r\n        if base_path is None:\r\n            return\r\n        setup_paths = get_setup_paths(\r\n            base_path, subdirectory=self.subdirectory\r\n        )  # type: Dict[STRING_TYPE, Optional[STRING_TYPE]]\r\n        self._setup_py = setup_paths.get(\"setup_py\")\r\n        self._setup_cfg = setup_paths.get(\"setup_cfg\")\r\n        self._pyproject_toml = setup_paths.get(\"pyproject_toml\")\r\n\r\n    @property\r\n    def pyproject_requires(self):\r\n        # type: () -> Optional[Tuple[STRING_TYPE, ...]]\r\n        if self._pyproject_requires is None and self.pyproject_toml is not None:\r\n            if self.path is not None:\r\n                pyproject_requires, pyproject_backend = None, None\r\n                pyproject_results = get_pyproject(self.path)  # type: ignore\r\n                if pyproject_results:\r\n                    pyproject_requires, pyproject_backend = pyproject_results\r\n                if pyproject_requires:\r\n                    self._pyproject_requires = tuple(pyproject_requires)\r\n                self._pyproject_backend = pyproject_backend\r\n        return self._pyproject_requires\r\n\r\n    @property\r\n    def pyproject_backend(self):\r\n        # type: () -> Optional[STRING_TYPE]\r\n        if self._pyproject_requires is None and self.pyproject_toml is not None:\r\n            pyproject_requires = None  # type: Optional[Sequence[STRING_TYPE]]\r\n            pyproject_backend = None  # type: Optional[STRING_TYPE]\r\n            pyproject_results = get_pyproject(self.path)  # type: ignore\r\n            if pyproject_results:\r\n                pyproject_requires, pyproject_backend = pyproject_results\r\n            if not pyproject_backend and self.setup_cfg is not None:\r\n                setup_dict = SetupInfo.get_setup_cfg(self.setup_cfg)\r\n                pyproject_backend = get_default_pyproject_backend()\r\n                pyproject_requires = setup_dict.get(\r\n                    \"build_requires\", [\"setuptools\", \"wheel\"]\r\n                )  # type: ignore\r\n            if pyproject_requires:\r\n                self._pyproject_requires = tuple(pyproject_requires)\r\n            if pyproject_backend:\r\n                self._pyproject_backend = pyproject_backend\r\n        return self._pyproject_backend\r\n\r\n    def parse_hashes(self):\r\n        # type: () -> \"Line\"\r\n        \"\"\"Parse hashes from *self.line* and set them on the current object.\r\n\r\n        :returns: Self\r\n        :rtype: `:class:~Line`\r\n        \"\"\"\r\n        line, hashes = self.split_hashes(self.line)\r\n        self.hashes = hashes\r\n        self.line = line\r\n        return self\r\n\r\n    def parse_extras(self):\r\n        # type: () -> \"Line\"\r\n        \"\"\"\r\n        Parse extras from *self.line* and set them on the current object\r\n        :returns: self\r\n        :rtype: :class:`~Line`\r\n        \"\"\"\r\n        extras = None\r\n        line = \"{0}\".format(self.line)\r\n        if any([self.is_vcs, self.is_url, \"@\" in line]):\r\n            try:\r\n                if self.parsed_url.name:\r\n                    self._name = self.parsed_url.name\r\n                if (\r\n                    self.parsed_url.host\r\n                    and self.parsed_url.path\r\n                    and self.parsed_url.scheme\r\n                ):\r\n                    self.line = self.parsed_url.to_string(\r\n                        escape_password=False,\r\n                        direct=False,\r\n                        strip_ssh=self.parsed_url.is_implicit_ssh,\r\n                    )\r\n            except ValueError:\r\n                self.line, extras = pip_shims.shims._strip_extras(self.line)\r\n        else:\r\n            self.line, extras = pip_shims.shims._strip_extras(self.line)\r\n        extras_set = set()  # type: Set[STRING_TYPE]\r\n        if extras is not None:\r\n            extras_set = set(parse_extras(extras))\r\n        if self._name:\r\n            self._name, name_extras = pip_shims.shims._strip_extras(self._name)\r\n            if name_extras:\r\n                name_extras = set(parse_extras(name_extras))\r\n                extras_set |= name_extras\r\n        if extras_set is not None:\r\n            self.extras = tuple(sorted(extras_set))\r\n        return self\r\n\r\n    def get_url(self):\r\n        # type: () -> STRING_TYPE\r\n        \"\"\"Sets ``self.name`` if given a **PEP-508** style URL.\"\"\"\r\n        return self.parsed_url.to_string(\r\n            escape_password=False, direct=False, strip_ref=True\r\n        )\r\n\r\n    @property\r\n    def name(self):\r\n        # type: () -> Optional[STRING_TYPE]\r\n        if self._name is None:\r\n            self.parse_name()\r\n            if self._name is None and not self.is_named and not self.is_wheel:\r\n                if self.setup_info:\r\n                    self._name = self.setup_info.name\r\n            elif self.is_wheel:\r\n                self._name = self._parse_wheel()\r\n            if not self._name:\r\n                self._name = self.ireq.name\r\n        return self._name\r\n\r\n    @name.setter\r\n    def name(self, name):\r\n        # type: (STRING_TYPE) -> None\r\n        self._name = name\r\n        if self._setup_info:\r\n            self._setup_info.name = name\r\n        if self.requirement and self._requirement:\r\n            self._requirement.name = name\r\n        if self.ireq and self._ireq and self._ireq.req:\r\n            self._ireq.req.name = name\r\n\r\n    @property\r\n    def url(self):\r\n        # type: () -> Optional[STRING_TYPE]\r\n        try:\r\n            return self.parsed_url.to_string(\r\n                escape_password=False,\r\n                strip_ref=True,\r\n                strip_name=True,\r\n                strip_subdir=True,\r\n                strip_ssh=False,\r\n            )\r\n        except ValueError:\r\n            return None\r\n\r\n    @property\r\n    def link(self):\r\n        # type: () -> Link\r\n        if self._link is None:\r\n            self.parse_link()\r\n        return self._link\r\n\r\n    @property\r\n    def subdirectory(self):\r\n        # type: () -> Optional[STRING_TYPE]\r\n        if self.link is not None:\r\n            return self.link.subdirectory_fragment\r\n        return \"\"\r\n\r\n    @property\r\n    def is_wheel(self):\r\n        # type: () -> bool\r\n        if self.link is None:\r\n            return False\r\n        return self.link.is_wheel\r\n\r\n    @property\r\n    def is_artifact(self):\r\n        # type: () -> bool\r\n\r\n        if self.link is None:\r\n            return False\r\n        return not self.link.is_vcs\r\n\r\n    @property\r\n    def is_vcs(self):\r\n        # type: () -> bool\r\n        # Installable local files and installable non-vcs urls are handled\r\n        # as files, generally speaking\r\n        try:\r\n            if is_vcs(self.line) or is_vcs(self.get_url()):\r\n                return True\r\n        except ValueError:\r\n            return False\r\n        return False\r\n\r\n    @property\r\n    def is_url(self):\r\n        # type: () -> bool\r\n        try:\r\n            url = self.get_url()\r\n        except ValueError:\r\n            return False\r\n        if is_valid_url(url) or is_file_url(url):\r\n            return True\r\n        return False\r\n\r\n    @property\r\n    def is_remote_url(self):\r\n        # type: () -> bool\r\n        return self.is_url and self.parsed_url.host is not None\r\n\r\n    @property\r\n    def is_path(self):\r\n        # type: () -> bool\r\n        try:\r\n            line_url = self.get_url()\r\n        except ValueError:\r\n            line_url = None\r\n        if (\r\n            self.path\r\n            and (\r\n                self.path.startswith(\".\")\r\n                or os.path.isabs(self.path)\r\n                or os.path.exists(self.path)\r\n            )\r\n            and is_installable_file(self.path)\r\n        ):\r\n            return True\r\n        elif (os.path.exists(self.line) and is_installable_file(self.line)) or (\r\n            line_url and os.path.exists(line_url) and is_installable_file(line_url)\r\n        ):\r\n            return True\r\n        return False\r\n\r\n    @property\r\n    def is_file_url(self):\r\n        # type: () -> bool\r\n        try:\r\n            url = self.get_url()\r\n        except ValueError:\r\n            return False\r\n        try:\r\n            parsed_url_scheme = self.parsed_url.scheme\r\n        except ValueError:\r\n            return False\r\n        if url and is_file_url(url) or parsed_url_scheme == \"file\":\r\n            return True\r\n        return False\r\n\r\n    @property\r\n    def is_file(self):\r\n        # type: () -> bool\r\n        try:\r\n            url = self.get_url()\r\n        except ValueError:\r\n            return False\r\n        if (\r\n            self.is_path\r\n            or (is_file_url(url) and is_installable_file(url))\r\n            or (\r\n                self._parsed_url\r\n                and self._parsed_url.is_file_url\r\n                and is_installable_file(self._parsed_url.url_without_fragment_or_ref)\r\n            )\r\n        ):\r\n            return True\r\n        return False\r\n\r\n    @property\r\n    def is_named(self):\r\n        # type: () -> bool\r\n        return not (\r\n            self.is_file_url\r\n            or self.is_url\r\n            or self.is_file\r\n            or self.is_vcs\r\n            or self.is_direct_url\r\n        )\r\n\r\n    @property\r\n    def ref(self):\r\n        # type: () -> Optional[STRING_TYPE]\r\n        if self._ref is None and self.relpath is not None:\r\n            self.relpath, self._ref = split_ref_from_uri(self.relpath)\r\n        return self._ref\r\n\r\n    @property\r\n    def ireq(self):\r\n        # type: () -> Optional[pip_shims.InstallRequirement]\r\n        if self._ireq is None:\r\n            self.parse_ireq()\r\n        return self._ireq\r\n\r\n    @property\r\n    def is_installable(self):\r\n        # type: () -> bool\r\n        try:\r\n            url = self.get_url()\r\n        except ValueError:\r\n            url = None\r\n        possible_paths = (self.line, url, self.path, self.base_path)\r\n        return any(is_installable_file(p) for p in possible_paths if p is not None)\r\n\r\n    @property\r\n    def wheel_kwargs(self):\r\n        if not self._wheel_kwargs:\r\n            self._wheel_kwargs = _prepare_wheel_building_kwargs(self.ireq)\r\n        return self._wheel_kwargs\r\n\r\n    def get_setup_info(self):\r\n        # type: () -> SetupInfo\r\n        setup_info = None\r\n        with pip_shims.shims.global_tempdir_manager():\r\n            setup_info = SetupInfo.from_ireq(self.ireq, subdir=self.subdirectory)\r\n            if not setup_info.name:\r\n                setup_info.get_info()\r\n        return setup_info\r\n\r\n    @property\r\n    def setup_info(self):\r\n        # type: () -> Optional[SetupInfo]\r\n        if not self._setup_info and not self.is_named and not self.is_wheel:\r\n            # make two attempts at this before failing to allow for stale data\r\n            try:\r\n                self.setup_info = self.get_setup_info()\r\n            except FileNotFoundError:\r\n                try:\r\n                    self.setup_info = self.get_setup_info()\r\n                except FileNotFoundError:\r\n                    raise\r\n        return self._setup_info\r\n\r\n    @setup_info.setter\r\n    def setup_info(self, setup_info):\r\n        # type: (SetupInfo) -> None\r\n        self._setup_info = setup_info\r\n        if setup_info.version:\r\n            self.specifier = setup_info.version\r\n        if setup_info.name and not self.name:\r\n            self.name = setup_info.name\r\n\r\n    def _get_vcsrepo(self):\r\n        # type: () -> Optional[VCSRepository]\r\n        from .vcs import VCSRepository\r\n\r\n        checkout_directory = self.wheel_kwargs[\"src_dir\"]  # type: ignore\r\n        if self.name is not None:\r\n            checkout_directory = os.path.join(\r\n                checkout_directory, self.name\r\n            )  # type: ignore\r\n        vcsrepo = VCSRepository(\r\n            url=self.link.url,\r\n            name=self.name,\r\n            ref=self.ref if self.ref else None,\r\n            checkout_directory=checkout_directory,\r\n            vcs_type=self.vcs,\r\n            subdirectory=self.subdirectory,\r\n        )\r\n        if not (self.link.scheme.startswith(\"file\") and self.editable):\r\n            vcsrepo.obtain()\r\n        return vcsrepo\r\n\r\n    @property\r\n    def vcsrepo(self):\r\n        # type: () -> Optional[VCSRepository]\r\n        if self._vcsrepo is None and self.is_vcs:\r\n            self._vcsrepo = self._get_vcsrepo()\r\n        return self._vcsrepo\r\n\r\n    @property\r\n    def parsed_url(self):\r\n        # type: () -> URI\r\n        if self._parsed_url is None:\r\n            self._parsed_url = URI.parse(self.line)\r\n        return self._parsed_url\r\n\r\n    @property\r\n    def is_direct_url(self):\r\n        # type: () -> bool\r\n        try:\r\n            return self.is_url and self.parsed_url.is_direct_url\r\n        except ValueError:\r\n            return self.is_url and bool(DIRECT_URL_RE.match(self.line))\r\n\r\n    @cached_property\r\n    def metadata(self):\r\n        # type: () -> Dict[Any, Any]\r\n        if self.is_local and self.path and is_installable_dir(self.path):\r\n            return get_metadata(self.path)\r\n        return {}\r\n\r\n    @cached_property\r\n    def parsed_setup_cfg(self):\r\n        # type: () -> Dict[Any, Any]\r\n        if not (\r\n            self.is_local\r\n            and self.path\r\n            and is_installable_dir(self.path)\r\n            and self.setup_cfg\r\n        ):\r\n            return {}\r\n        base_dir = os.path.dirname(os.path.abspath(self.setup_cfg))\r\n        setup_content = read_source(self.setup_cfg)\r\n        return parse_setup_cfg(setup_content, base_dir)\r\n\r\n    @cached_property\r\n    def parsed_setup_py(self):\r\n        # type: () -> Dict[Any, Any]\r\n        if self.is_local and self.path and is_installable_dir(self.path):\r\n            if self.setup_py:\r\n                return ast_parse_setup_py(self.setup_py)\r\n        return {}\r\n\r\n    @vcsrepo.setter\r\n    def vcsrepo(self, repo):\r\n        # type (VCSRepository) -> None\r\n        self._vcsrepo = repo\r\n        ireq = self.ireq\r\n        wheel_kwargs = self.wheel_kwargs.copy()\r\n        wheel_kwargs[\"src_dir\"] = repo.checkout_directory\r\n        with pip_shims.shims.global_tempdir_manager(), temp_path():\r\n            ireq.ensure_has_source_dir(wheel_kwargs[\"src_dir\"])\r\n            sys.path = [repo.checkout_directory, \"\", \".\", get_python_lib(plat_specific=0)]\r\n            setupinfo = SetupInfo.create(\r\n                repo.checkout_directory,\r\n                ireq=ireq,\r\n                subdirectory=self.subdirectory,\r\n                kwargs=wheel_kwargs,\r\n            )\r\n            self._setup_info = setupinfo\r\n            self._setup_info.reload()\r\n\r\n    def get_ireq(self):\r\n        # type: () -> InstallRequirement\r\n        line = self.line_for_ireq\r\n        if self.editable:\r\n            ireq = pip_shims.shims.install_req_from_editable(line)\r\n        else:\r\n            ireq = pip_shims.shims.install_req_from_line(line)\r\n        if self.is_named:\r\n            ireq = pip_shims.shims.install_req_from_line(self.line)\r\n        if self.is_file or self.is_remote_url:\r\n            ireq.link = self.link\r\n        if self.extras and not ireq.extras:\r\n            ireq.extras = set(self.extras)\r\n        if self.parsed_marker is not None and not ireq.markers:\r\n            ireq.markers = self.parsed_marker\r\n        if not ireq.req and self._requirement is not None:\r\n            ireq.req = copy.deepcopy(self._requirement)\r\n        return ireq\r\n\r\n    def parse_ireq(self):\r\n        # type: () -> None\r\n        if self._ireq is None:\r\n            self._ireq = self.get_ireq()\r\n        if self._ireq is not None:\r\n            if self.requirement is not None and self._ireq.req is None:\r\n                self._ireq.req = self.requirement\r\n\r\n    def _parse_wheel(self):\r\n        # type: () -> Optional[STRING_TYPE]\r\n        if not self.is_wheel:\r\n            pass\r\n        from pip_shims.shims import Wheel\r\n\r\n        _wheel = Wheel(self.link.filename)\r\n        name = _wheel.name\r\n        version = _wheel.version\r\n        self._specifier = \"=={0}\".format(version)\r\n        return name\r\n\r\n    def _parse_name_from_link(self):\r\n        # type: () -> Optional[STRING_TYPE]\r\n        if self.link is None:\r\n            return None\r\n        if getattr(self.link, \"egg_fragment\", None):\r\n            return self.link.egg_fragment\r\n        elif self.is_wheel:\r\n            return self._parse_wheel()\r\n        return None\r\n\r\n    def _parse_name_from_line(self):\r\n        # type: () -> Optional[STRING_TYPE]\r\n        if not self.is_named:\r\n            pass\r\n        try:\r\n            self._requirement = init_requirement(self.line)\r\n        except Exception:\r\n            raise RequirementError(\r\n                \"Failed parsing requirement from {0!r}\".format(self.line)\r\n            )\r\n        name = self._requirement.name\r\n        if not self._specifier and self._requirement and self._requirement.specifier:\r\n            self._specifier = specs_to_string(self._requirement.specifier)\r\n        if self._requirement.extras and not self.extras:\r\n            self.extras = self._requirement.extras\r\n        if not name:\r\n            name = self.line\r\n            specifier_match = next(\r\n                iter(spec for spec in SPECIFIERS_BY_LENGTH if spec in self.line), None\r\n            )\r\n            specifier = None  # type: Optional[STRING_TYPE]\r\n            if specifier_match:\r\n                specifier = \"{0!s}\".format(specifier_match)\r\n            if specifier is not None and specifier in name:\r\n                version = None  # type: Optional[STRING_TYPE]\r\n                name, specifier, version = name.partition(specifier)\r\n                self._specifier = \"{0}{1}\".format(specifier, version)\r\n        return name\r\n\r\n    def _parse_name_from_path(self):\r\n        # type: () -> Optional[S]\r\n        if self.path and self.is_local and is_installable_dir(self.path):\r\n            metadata = get_metadata(self.path)\r\n            if metadata:\r\n                name = metadata.get(\"name\", \"\")\r\n                if name and name != \"wheel\":\r\n                    return name\r\n            parsed_setup_cfg = self.parsed_setup_cfg\r\n            if parsed_setup_cfg:\r\n                name = parsed_setup_cfg.get(\"name\", \"\")\r\n                if name:\r\n                    return name\r\n\r\n            parsed_setup_py = self.parsed_setup_py\r\n            if parsed_setup_py:\r\n                name = parsed_setup_py.get(\"name\", \"\")\r\n                if name:\r\n                    return name\r\n        return None\r\n\r\n    def parse_name(self):\r\n        # type: () -> \"Line\"\r\n        if self._name is None:\r\n            name = None\r\n            if self.link is not None and self.line_is_installable:\r\n                name = self._parse_name_from_link()\r\n            if name is None and (\r\n                (self.is_remote_url or self.is_artifact or self.is_vcs)\r\n                and self._parsed_url\r\n            ):\r\n                if self._parsed_url.fragment:\r\n                    _, _, name = self._parsed_url.fragment.partition(\"egg=\")\r\n                    if \"&\" in name:\r\n                        # subdirectory fragments might also be in here\r\n                        name, _, _ = name.partition(\"&\")\r\n            if name is None and self.is_named:\r\n                name = self._parse_name_from_line()\r\n            elif name is None and self.is_file or self.is_remote_url or self.is_path:\r\n                if self.is_local:\r\n                    name = self._parse_name_from_path()\r\n            if name is not None:\r\n                name, extras = pip_shims.shims._strip_extras(name)\r\n                if extras is not None and not self.extras:\r\n                    self.extras = tuple(sorted(set(parse_extras(extras))))\r\n                self._name = name\r\n        return self\r\n\r\n    def _parse_requirement_from_vcs(self):\r\n        # type: () -> Optional[PackagingRequirement]\r\n        url = self.url if self.url else self.link.url\r\n        if url:\r\n            url = unquote(url)\r\n        if (\r\n            url\r\n            and self.uri != url\r\n            and \"git+ssh://\" in url\r\n            and (self.uri is not None and \"git+git@\" in self.uri)\r\n            and self._requirement is not None\r\n        ):\r\n            self._requirement.line = self.uri\r\n            self._requirement.url = self.url\r\n            vcs_uri = build_vcs_uri(  # type: ignore\r\n                vcs=self.vcs,\r\n                uri=self.url,\r\n                ref=self.ref,\r\n                subdirectory=self.subdirectory,\r\n                extras=self.extras,\r\n                name=self.name,\r\n            )\r\n            if vcs_uri:\r\n                self._requirement.link = create_link(vcs_uri)\r\n            elif self.link:\r\n                self._requirement.link = self.link\r\n        # else:\r\n        #     req.link = self.link\r\n        if self.ref and self._requirement is not None:\r\n            self._requirement.revision = self.ref\r\n            if self._vcsrepo is not None:\r\n                with pip_shims.shims.global_tempdir_manager():\r\n                    self._requirement.revision = self._vcsrepo.get_commit_hash()\r\n        return self._requirement\r\n\r\n    def parse_requirement(self):\r\n        # type: () -> \"Line\"\r\n        if self._name is None:\r\n            self.parse_name()\r\n            if not any([self._name, self.is_vcs, self.is_named]):\r\n                if self.setup_info and self.setup_info.name:\r\n                    self._name = self.setup_info.name\r\n        name, extras, url = self.requirement_info\r\n        if name:\r\n            self._requirement = init_requirement(name)  # type: PackagingRequirement\r\n            if extras:\r\n                self._requirement.extras = set(extras)\r\n            if url:\r\n                self._requirement.url = url\r\n            if self.is_direct_url:\r\n                url = self.link.url\r\n            if self.link:\r\n                self._requirement.link = self.link\r\n            self._requirement.editable = self.editable\r\n            if self.path and self.link and self.link.scheme.startswith(\"file\"):\r\n                self._requirement.local_file = True\r\n                self._requirement.path = self.path\r\n            if self.is_vcs:\r\n                self._requirement.vcs = self.vcs\r\n                self._requirement.line = self.link.url\r\n                self._parse_requirement_from_vcs()\r\n            else:\r\n                self._requirement.line = self.line\r\n            if self.parsed_marker is not None:\r\n                self._requirement.marker = self.parsed_marker\r\n            if self.specifiers:\r\n                self._requirement.specifier = self.specifiers\r\n                specs = []\r\n                spec = next(iter(s for s in self.specifiers._specs), None)\r\n                if spec:\r\n                    specs.append(spec._spec)\r\n                self._requirement.spec = spec\r\n        else:\r\n            if self.is_vcs:\r\n                raise ValueError(\r\n                    \"pipenv requires an #egg fragment for version controlled \"\r\n                    \"dependencies. Please install remote dependency \"\r\n                    \"in the form {0}#egg=<package-name>.\".format(url)\r\n                )\r\n        return self\r\n\r\n    def parse_link(self):\r\n        # type: () -> \"Line\"\r\n        parsed_url = None  # type: Optional[URI]\r\n        if (\r\n            not is_valid_url(self.line)\r\n            and is_installable_file(os.path.abspath(self.line))\r\n            and (\r\n                self.line.startswith(\"./\")\r\n                or (os.path.exists(self.line) or os.path.isabs(self.line))\r\n            )\r\n        ):\r\n            url = pip_shims.shims.path_to_url(os.path.abspath(self.line))\r\n            self._parsed_url = parsed_url = URI.parse(url)\r\n        elif any(\r\n            [\r\n                is_valid_url(self.line),\r\n                is_vcs(self.line),\r\n                is_file_url(self.line),\r\n                self.is_direct_url,\r\n            ]\r\n        ):\r\n            parsed_url = self.parsed_url\r\n        if parsed_url is None or (\r\n            parsed_url.is_file_url and not parsed_url.is_installable\r\n        ):\r\n            return None\r\n        if parsed_url.is_vcs:\r\n            self.vcs, _ = parsed_url.scheme.split(\"+\")\r\n        if parsed_url.is_file_url:\r\n            self.is_local = True\r\n        parsed_link = parsed_url.as_link\r\n        self._ref = parsed_url.ref\r\n        self.uri = parsed_url.bare_url\r\n        if parsed_url.name:\r\n            self._name = parsed_url.name\r\n        if parsed_url.extras:\r\n            self.extras = tuple(sorted(set(parsed_url.extras)))\r\n        self._link = parsed_link\r\n        vcs, prefer, relpath, path, uri, link = FileRequirement.get_link_from_line(\r\n            self.line\r\n        )\r\n        ref = None\r\n        if link is not None and \"@\" in unquote(link.path) and uri is not None:\r\n            uri, _, ref = unquote(uri).rpartition(\"@\")\r\n        if relpath is not None and \"@\" in relpath:\r\n            relpath, _, ref = relpath.rpartition(\"@\")\r\n        if path is not None and \"@\" in path:\r\n            path, _ = split_ref_from_uri(path)\r\n        link_url = link.url_without_fragment\r\n        if \"@\" in link_url:\r\n            link_url, _ = split_ref_from_uri(link_url)\r\n        self.preferred_scheme = prefer\r\n        self.relpath = relpath\r\n        self.path = path\r\n        # self.uri = uri\r\n        if prefer in (\"path\", \"relpath\") or uri.startswith(\"file\"):\r\n            self.is_local = True\r\n        if parsed_url.is_vcs or parsed_url.is_direct_url and parsed_link:\r\n            self._link = parsed_link\r\n        else:\r\n            self._link = link\r\n        return self\r\n\r\n    def parse_markers(self):\r\n        # type: () -> None\r\n        if self.markers:\r\n            marker_str = self.markers.replace('\"', \"'\")\r\n            markers = PackagingRequirement(\"fakepkg; {0}\".format(marker_str)).marker\r\n            self.parsed_marker = markers\r\n\r\n    @property\r\n    def requirement_info(self):\r\n        # type: () -> Tuple[Optional[S], Tuple[Optional[S], ...], Optional[S]]\r\n        \"\"\"\r\n        Generates a 3-tuple of the requisite *name*, *extras* and *url* to generate a\r\n        :class:`~packaging.requirements.Requirement` out of.\r\n\r\n        :return: A Tuple of an optional name, a Tuple of extras, and an optional URL.\r\n        :rtype: Tuple[Optional[S], Tuple[Optional[S], ...], Optional[S]]\r\n        \"\"\"\r\n\r\n        # Direct URLs can be converted to packaging requirements directly, but\r\n        # only if they are `file://` (with only two slashes)\r\n        name = None  # type: Optional[S]\r\n        extras = ()  # type: Tuple[Optional[S], ...]\r\n        url = None  # type: Optional[STRING_TYPE]\r\n        # if self.is_direct_url:\r\n        if self._name:\r\n            name = canonicalize_name(self._name)\r\n        if self.is_file or self.is_url or self.is_path or self.is_file_url or self.is_vcs:\r\n            url = \"\"\r\n            if self.is_vcs:\r\n                url = self.url if self.url else self.uri\r\n                if self.is_direct_url:\r\n                    url = self.link.url_without_fragment\r\n            else:\r\n                if self.link:\r\n                    url = self.link.url_without_fragment\r\n                elif self.url:\r\n                    url = self.url\r\n                    if self.ref:\r\n                        url = \"{0}@{1}\".format(url, self.ref)\r\n                else:\r\n                    url = self.uri\r\n            if self.link and name is None:\r\n                self._name = self.link.egg_fragment\r\n                if self._name:\r\n                    name = canonicalize_name(self._name)\r\n        return name, extras, url  # type: ignore\r\n\r\n    @property\r\n    def line_is_installable(self):\r\n        # type: () -> bool\r\n        \"\"\"This is a safeguard against decoy requirements when a user installs\r\n        a package whose name coincides with the name of a folder in the cwd,\r\n        e.g. install *alembic* when there is a folder called *alembic* in the\r\n        working directory.\r\n\r\n        In this case we first need to check that the given requirement\r\n        is a valid URL, VCS requirement, or installable filesystem path\r\n        before deciding to treat it as a file requirement over a named\r\n        requirement.\r\n        \"\"\"\r\n        line = self.line\r\n        direct_url_match = DIRECT_URL_RE.match(line)\r\n        if direct_url_match:\r\n            match_dict = direct_url_match.groupdict()\r\n            auth = \"\"\r\n            username = match_dict.get(\"username\", None)\r\n            password = match_dict.get(\"password\", None)\r\n            port = match_dict.get(\"port\", None)\r\n            path = match_dict.get(\"path\", None)\r\n            ref = match_dict.get(\"ref\", None)\r\n            if username is not None:\r\n                auth = \"{0}\".format(username)\r\n            if password:\r\n                auth = \"{0}:{1}\".format(auth, password) if auth else password\r\n            line = match_dict.get(\"host\", \"\")\r\n            if auth:\r\n                line = \"{auth}@{line}\".format(auth=auth, line=line)\r\n            if port:\r\n                line = \"{line}:{port}\".format(line=line, port=port)\r\n            if path:\r\n                line = \"{line}{pathsep}{path}\".format(\r\n                    line=line, pathsep=match_dict[\"pathsep\"], path=path\r\n                )\r\n            if ref:\r\n                line = \"{line}@{ref}\".format(line=line, ref=ref)\r\n            line = \"{scheme}{line}\".format(scheme=match_dict[\"scheme\"], line=line)\r\n        if is_file_url(line):\r\n            link = create_link(line)\r\n            line = link.url_without_fragment\r\n            line, _ = split_ref_from_uri(line)\r\n        if (\r\n            is_vcs(line)\r\n            or (not is_file_url(line) and is_valid_url(line))\r\n            or (is_file_url(line) and is_installable_file(line))\r\n            or is_installable_file(line)\r\n        ):\r\n            return True\r\n        return False\r\n\r\n    def parse(self):\r\n        # type: () -> None\r\n        self.line = self.line.strip()\r\n        if self.line.startswith('\"'):\r\n            self.line = self.line.strip('\"')\r\n        self.line, self.markers = split_markers_from_line(self.parse_hashes().line)\r\n        if self.markers:\r\n            self.markers = self.markers.replace('\"', \"'\")\r\n        self.parse_extras()\r\n        self.line = self.line.strip('\"').strip(\"'\").strip()\r\n        if self.line.startswith(\"git+file:/\") and not self.line.startswith(\r\n            \"git+file:///\"\r\n        ):\r\n            self.line = self.line.replace(\"git+file:/\", \"git+file:///\")\r\n        self.parse_markers()\r\n        if self.is_file_url:\r\n            if self.line_is_installable:\r\n                self.populate_setup_paths()\r\n            else:\r\n                raise RequirementError(\r\n                    \"Supplied requirement is not installable: {0!r}\".format(self.line)\r\n                )\r\n        elif self.is_named and self._name is None:\r\n            self.parse_name()\r\n        self.parse_link()\r\n        # self.parse_requirement()\r\n        # self.parse_ireq()\r\n\r\n\r\n@attr.s(slots=True, hash=True)\r\nclass NamedRequirement(object):\r\n    name = attr.ib()  # type: STRING_TYPE\r\n    version = attr.ib()  # type: Optional[STRING_TYPE]\r\n    req = attr.ib()  # type: PackagingRequirement\r\n    extras = attr.ib(default=attr.Factory(list))  # type: Tuple[STRING_TYPE, ...]\r\n    editable = attr.ib(default=False)  # type: bool\r\n    _parsed_line = attr.ib(default=None)  # type: Optional[Line]\r\n\r\n    @req.default\r\n    def get_requirement(self):\r\n        # type: () -> RequirementType\r\n        req = init_requirement(\r\n            \"{0}{1}\".format(canonicalize_name(self.name), self.version)\r\n        )\r\n        return req\r\n\r\n    @property\r\n    def parsed_line(self):\r\n        # type: () -> Optional[Line]\r\n        if self._parsed_line is None:\r\n            self._parsed_line = Line(self.line_part)\r\n        return self._parsed_line\r\n\r\n    @classmethod\r\n    def from_line(cls, line, parsed_line=None):\r\n        # type: (AnyStr, Optional[Line]) -> NamedRequirement\r\n        req = init_requirement(line)\r\n        specifiers = None  # type: Optional[STRING_TYPE]\r\n        if req.specifier:\r\n            specifiers = specs_to_string(req.specifier)\r\n        req.line = line\r\n        name = getattr(req, \"name\", None)\r\n        if not name:\r\n            name = getattr(req, \"project_name\", None)\r\n            req.name = name\r\n        if not name:\r\n            name = getattr(req, \"key\", line)\r\n            req.name = name\r\n        creation_kwargs = {\r\n            \"name\": name,\r\n            \"version\": specifiers,\r\n            \"req\": req,\r\n            \"parsed_line\": parsed_line,\r\n            \"extras\": None,\r\n        }\r\n        extras = None  # type: Optional[Tuple[STRING_TYPE, ...]]\r\n        if req.extras:\r\n            extras = tuple(req.extras)\r\n        creation_kwargs[\"extras\"] = extras\r\n        return cls(**creation_kwargs)\r\n\r\n    @classmethod\r\n    def from_pipfile(cls, name, pipfile):\r\n        # type: (S, TPIPFILE) -> NamedRequirement\r\n        creation_args = {}  # type: TPIPFILE\r\n        if hasattr(pipfile, \"keys\"):\r\n            attr_fields = [field.name for field in attr.fields(cls)]\r\n            creation_args = {\r\n                k: v for k, v in pipfile.items() if k in attr_fields\r\n            }  # type: ignore\r\n        creation_args[\"name\"] = name\r\n        version = get_version(pipfile)  # type: Optional[STRING_TYPE]\r\n        extras = creation_args.get(\"extras\", None)\r\n        creation_args[\"version\"] = version  # type: ignore\r\n        req = init_requirement(\"{0}{1}\".format(name, version))\r\n        if req and extras and req.extras and isinstance(req.extras, tuple):\r\n            if isinstance(extras, six.string_types):\r\n                req.extras = (extras) + tuple([\"{0}\".format(xtra) for xtra in req.extras])\r\n            elif isinstance(extras, (tuple, list)):\r\n                req.extras += tuple(extras)\r\n        creation_args[\"req\"] = req\r\n        return cls(**creation_args)  # type: ignore\r\n\r\n    @property\r\n    def line_part(self):\r\n        # type: () -> STRING_TYPE\r\n        # FIXME: This should actually be canonicalized but for now we have to\r\n        # simply lowercase it and replace underscores, since full canonicalization\r\n        # also replaces dots and that doesn't actually work when querying the index\r\n        return normalize_name(self.name)\r\n\r\n    @property\r\n    def pipfile_part(self):\r\n        # type: () -> Dict[STRING_TYPE, Any]\r\n        pipfile_dict = attr.asdict(self, filter=filter_none).copy()  # type: ignore\r\n        if \"version\" not in pipfile_dict:\r\n            pipfile_dict[\"version\"] = \"*\"\r\n        if \"_parsed_line\" in pipfile_dict:\r\n            pipfile_dict.pop(\"_parsed_line\")\r\n        name = pipfile_dict.pop(\"name\")\r\n        return {name: pipfile_dict}\r\n\r\n\r\nLinkInfo = collections.namedtuple(\r\n    \"LinkInfo\", [\"vcs_type\", \"prefer\", \"relpath\", \"path\", \"uri\", \"link\"]\r\n)\r\n\r\n\r\n@attr.s(slots=True, cmp=True, hash=True)\r\nclass FileRequirement(object):\r\n    \"\"\"File requirements for tar.gz installable files or wheels or setup.py\r\n    containing directories.\"\"\"\r\n\r\n    #: Path to the relevant `setup.py` location\r\n    setup_path = attr.ib(default=None, cmp=True)  # type: Optional[STRING_TYPE]\r\n    #: path to hit - without any of the VCS prefixes (like git+ / http+ / etc)\r\n    path = attr.ib(default=None, cmp=True)  # type: Optional[STRING_TYPE]\r\n    #: Whether the package is editable\r\n    editable = attr.ib(default=False, cmp=True)  # type: bool\r\n    #: Extras if applicable\r\n    extras = attr.ib(\r\n        default=attr.Factory(tuple), cmp=True\r\n    )  # type: Tuple[STRING_TYPE, ...]\r\n    _uri_scheme = attr.ib(default=None, cmp=True)  # type: Optional[STRING_TYPE]\r\n    #: URI of the package\r\n    uri = attr.ib(cmp=True)  # type: Optional[STRING_TYPE]\r\n    #: Link object representing the package to clone\r\n    link = attr.ib(cmp=True)  # type: Optional[Link]\r\n    #: PyProject Requirements\r\n    pyproject_requires = attr.ib(\r\n        factory=tuple, cmp=True\r\n    )  # type: Optional[Tuple[STRING_TYPE, ...]]\r\n    #: PyProject Build System\r\n    pyproject_backend = attr.ib(default=None, cmp=True)  # type: Optional[STRING_TYPE]\r\n    #: PyProject Path\r\n    pyproject_path = attr.ib(default=None, cmp=True)  # type: Optional[STRING_TYPE]\r\n    subdirectory = attr.ib(default=None)  # type: Optional[STRING_TYPE]\r\n    #: Setup metadata e.g. dependencies\r\n    _setup_info = attr.ib(default=None, cmp=True)  # type: Optional[SetupInfo]\r\n    _has_hashed_name = attr.ib(default=False, cmp=True)  # type: bool\r\n    _parsed_line = attr.ib(default=None, cmp=False, hash=True)  # type: Optional[Line]\r\n    #: Package name\r\n    name = attr.ib(cmp=True)  # type: Optional[STRING_TYPE]\r\n    #: A :class:`~pkg_resources.Requirement` instance\r\n    req = attr.ib(cmp=True)  # type: Optional[PackagingRequirement]\r\n\r\n    @classmethod\r\n    def get_link_from_line(cls, line):\r\n        # type: (STRING_TYPE) -> LinkInfo\r\n        \"\"\"Parse link information from given requirement line.\r\n\r\n        Return a 6-tuple:\r\n\r\n        - `vcs_type` indicates the VCS to use (e.g. \"git\"), or None.\r\n        - `prefer` is either \"file\", \"path\" or \"uri\", indicating how the\r\n            information should be used in later stages.\r\n        - `relpath` is the relative path to use when recording the dependency,\r\n            instead of the absolute path/URI used to perform installation.\r\n            This can be None (to prefer the absolute path or URI).\r\n        - `path` is the absolute file path to the package. This will always use\r\n            forward slashes. Can be None if the line is a remote URI.\r\n        - `uri` is the absolute URI to the package. Can be None if the line is\r\n            not a URI.\r\n        - `link` is an instance of :class:`pip._internal.index.Link`,\r\n            representing a URI parse result based on the value of `uri`.\r\n\r\n        This function is provided to deal with edge cases concerning URIs\r\n        without a valid netloc. Those URIs are problematic to a straight\r\n        ``urlsplit` call because they cannot be reliably reconstructed with\r\n        ``urlunsplit`` due to a bug in the standard library:\r\n\r\n        >>> from urllib.parse import urlsplit, urlunsplit\r\n        >>> urlunsplit(urlsplit('git+file:///this/breaks'))\r\n        'git+file:/this/breaks'\r\n        >>> urlunsplit(urlsplit('file:///this/works'))\r\n        'file:///this/works'\r\n\r\n        See `https://bugs.python.org/issue23505#msg277350`.\r\n        \"\"\"\r\n\r\n        # Git allows `git@github.com...` lines that are not really URIs.\r\n        # Add \"ssh://\" so we can parse correctly, and restore afterwards.\r\n        fixed_line = add_ssh_scheme_to_git_uri(line)  # type: STRING_TYPE\r\n        added_ssh_scheme = fixed_line != line  # type: bool\r\n\r\n        # We can assume a lot of things if this is a local filesystem path.\r\n        if \"://\" not in fixed_line:\r\n            p = Path(fixed_line).absolute()  # type: Path\r\n            path = p.as_posix()  # type: Optional[STRING_TYPE]\r\n            uri = p.as_uri()  # type: STRING_TYPE\r\n            link = create_link(uri)  # type: Link\r\n            relpath = None  # type: Optional[STRING_TYPE]\r\n            try:\r\n                relpath = get_converted_relative_path(path)\r\n            except ValueError:\r\n                relpath = None\r\n            return LinkInfo(None, \"path\", relpath, path, uri, link)\r\n\r\n        # This is an URI. We'll need to perform some elaborated parsing.\r\n\r\n        parsed_url = urllib_parse.urlsplit(fixed_line)  # type: SplitResult\r\n        original_url = parsed_url._replace()  # type: SplitResult\r\n\r\n        # Split the VCS part out if needed.\r\n        original_scheme = parsed_url.scheme  # type: STRING_TYPE\r\n        vcs_type = None  # type: Optional[STRING_TYPE]\r\n        if \"+\" in original_scheme:\r\n            scheme = None  # type: Optional[STRING_TYPE]\r\n            vcs_type, _, scheme = original_scheme.partition(\"+\")\r\n            parsed_url = parsed_url._replace(scheme=scheme)  # type: ignore\r\n            prefer = \"uri\"  # type: STRING_TYPE\r\n        else:\r\n            vcs_type = None\r\n            prefer = \"file\"\r\n\r\n        if parsed_url.scheme == \"file\" and parsed_url.path:\r\n            # This is a \"file://\" URI. Use url_to_path and path_to_url to\r\n            # ensure the path is absolute. Also we need to build relpath.\r\n            path = Path(\r\n                pip_shims.shims.url_to_path(urllib_parse.urlunsplit(parsed_url))\r\n            ).as_posix()\r\n            try:\r\n                relpath = get_converted_relative_path(path)\r\n            except ValueError:\r\n                relpath = None\r\n            uri = pip_shims.shims.path_to_url(path)\r\n        else:\r\n            # This is a remote URI. Simply use it.\r\n            path = None\r\n            relpath = None\r\n            # Cut the fragment, but otherwise this is fixed_line.\r\n            uri = urllib_parse.urlunsplit(\r\n                parsed_url._replace(scheme=original_scheme, fragment=\"\")  # type: ignore\r\n            )\r\n\r\n        if added_ssh_scheme:\r\n            original_uri = urllib_parse.urlunsplit(\r\n                original_url._replace(scheme=original_scheme, fragment=\"\")  # type: ignore\r\n            )\r\n            uri = strip_ssh_from_git_uri(original_uri)\r\n\r\n        # Re-attach VCS prefix to build a Link.\r\n        link = create_link(\r\n            urllib_parse.urlunsplit(\r\n                parsed_url._replace(scheme=original_scheme)\r\n            )  # type: ignore\r\n        )\r\n\r\n        return LinkInfo(vcs_type, prefer, relpath, path, uri, link)\r\n\r\n    @property\r\n    def setup_py_dir(self):\r\n        # type: () -> Optional[STRING_TYPE]\r\n        if self.setup_path:\r\n            return os.path.dirname(os.path.abspath(self.setup_path))\r\n        return None\r\n\r\n    @property\r\n    def dependencies(self):\r\n        # type: () -> Tuple[Dict[S, PackagingRequirement], List[Union[S, PackagingRequirement]], List[S]]\r\n        build_deps = []  # type: List[Union[S, PackagingRequirement]]\r\n        setup_deps = []  # type: List[S]\r\n        deps = {}  # type: Dict[S, PackagingRequirement]\r\n        if self.setup_info:\r\n            setup_info = self.setup_info.as_dict()\r\n            deps.update(setup_info.get(\"requires\", {}))\r\n            setup_deps.extend(setup_info.get(\"setup_requires\", []))\r\n            build_deps.extend(setup_info.get(\"build_requires\", []))\r\n            if self.extras and self.setup_info.extras:\r\n                for dep in self.extras:\r\n                    if dep not in self.setup_info.extras:\r\n                        continue\r\n                    extras_list = self.setup_info.extras.get(dep, [])  # type: ignore\r\n                    for req_instance in extras_list:  # type: ignore\r\n                        deps[req_instance.key] = req_instance\r\n        if self.pyproject_requires:\r\n            build_deps.extend(list(self.pyproject_requires))\r\n        setup_deps = list(set(setup_deps))\r\n        build_deps = list(set(build_deps))\r\n        return deps, setup_deps, build_deps\r\n\r\n    def __attrs_post_init__(self):\r\n        # type: () -> None\r\n        if self.name is None and self.parsed_line:\r\n            if self.parsed_line.setup_info:\r\n                self._setup_info = self.parsed_line.setup_info\r\n                if self.parsed_line.setup_info.name:\r\n                    self.name = self.parsed_line.setup_info.name\r\n        if self.req is None and (\r\n            self._parsed_line is not None and self._parsed_line.requirement is not None\r\n        ):\r\n            self.req = self._parsed_line.requirement\r\n        if (\r\n            self._parsed_line\r\n            and self._parsed_line.ireq\r\n            and not self._parsed_line.ireq.req\r\n        ):\r\n            if self.req is not None and self._parsed_line._ireq is not None:\r\n                self._parsed_line._ireq.req = self.req\r\n\r\n    @property\r\n    def setup_info(self):\r\n        # type: () -> Optional[SetupInfo]\r\n        if self._setup_info is None and self.parsed_line:\r\n            if self.parsed_line and self._parsed_line and self.parsed_line.setup_info:\r\n                if (\r\n                    self._parsed_line._setup_info\r\n                    and not self._parsed_line._setup_info.name\r\n                ):\r\n                    with pip_shims.shims.global_tempdir_manager():\r\n                        self._parsed_line._setup_info.get_info()\r\n                self._setup_info = self.parsed_line._setup_info\r\n            elif self.parsed_line and (\r\n                self.parsed_line.ireq and not self.parsed_line.is_wheel\r\n            ):\r\n                with pip_shims.shims.global_tempdir_manager():\r\n                    self._setup_info = SetupInfo.from_ireq(\r\n                        self.parsed_line.ireq, subdir=self.subdirectory\r\n                    )\r\n            else:\r\n                if self.link and not self.link.is_wheel:\r\n                    self._setup_info = Line(self.line_part).setup_info\r\n                    with pip_shims.shims.global_tempdir_manager():\r\n                        self._setup_info.get_info()\r\n        return self._setup_info\r\n\r\n    @setup_info.setter\r\n    def setup_info(self, setup_info):\r\n        # type: (SetupInfo) -> None\r\n        self._setup_info = setup_info\r\n        if self._parsed_line:\r\n            self._parsed_line._setup_info = setup_info\r\n\r\n    @uri.default\r\n    def get_uri(self):\r\n        # type: () -> STRING_TYPE\r\n        if self.path and not self.uri:\r\n            self._uri_scheme = \"path\"\r\n            return pip_shims.shims.path_to_url(os.path.abspath(self.path))\r\n        elif (\r\n            getattr(self, \"req\", None)\r\n            and self.req is not None\r\n            and getattr(self.req, \"url\")\r\n        ):\r\n            return self.req.url\r\n        elif self.link is not None:\r\n            return self.link.url_without_fragment\r\n        return \"\"\r\n\r\n    @name.default\r\n    def get_name(self):\r\n        # type: () -> STRING_TYPE\r\n        if self.parsed_line and self.parsed_line.name:\r\n            return self.parsed_line.name\r\n        elif self.link and self.link.egg_fragment:\r\n            return self.link.egg_fragment\r\n        elif self.setup_info and self.setup_info.name:\r\n            return self.setup_info.name\r\n\r\n    @link.default\r\n    def get_link(self):\r\n        # type: () -> pip_shims.shims.Link\r\n        target = \"{0}\".format(self.uri)\r\n        if hasattr(self, \"name\") and not self._has_hashed_name:\r\n            target = \"{0}#egg={1}\".format(target, self.name)\r\n        link = create_link(target)\r\n        return link\r\n\r\n    @req.default\r\n    def get_requirement(self):\r\n        # type: () -> RequirementType\r\n        if self.name is None:\r\n            if self._parsed_line is not None and self._parsed_line.name is not None:\r\n                self.name = self._parsed_line.name\r\n            else:\r\n                raise ValueError(\r\n                    \"Failed to generate a requirement: missing name for {0!r}\".format(\r\n                        self\r\n                    )\r\n                )\r\n        if self._parsed_line:\r\n            try:\r\n                # initialize specifiers to make sure we capture them\r\n                self._parsed_line.specifiers\r\n            except Exception:\r\n                pass\r\n            req = copy.deepcopy(self._parsed_line.requirement)\r\n            if req:\r\n                return req\r\n\r\n    @property\r\n    def parsed_line(self):\r\n        # type: () -> Optional[Line]\r\n        if self._parsed_line is None:\r\n            self._parsed_line = Line(self.line_part)\r\n        return self._parsed_line\r\n\r\n    @property\r\n    def is_local(self):\r\n        # type: () -> bool\r\n        uri = getattr(self, \"uri\", None)\r\n        if uri is None:\r\n            if getattr(self, \"path\", None) and self.path is not None:\r\n                uri = pip_shims.shims.path_to_url(os.path.abspath(self.path))\r\n            elif (\r\n                getattr(self, \"req\", None)\r\n                and self.req is not None\r\n                and (getattr(self.req, \"url\") and self.req.url is not None)\r\n            ):\r\n                uri = self.req.url\r\n            if uri and is_file_url(uri):\r\n                return True\r\n        return False\r\n\r\n    @property\r\n    def is_remote_artifact(self):\r\n        # type: () -> bool\r\n        if self.link is None:\r\n            return False\r\n        return (\r\n            self._parsed_line\r\n            and not self._parsed_line.is_local\r\n            and (self._parsed_line.is_artifact or self._parsed_line.is_wheel)\r\n            and not self.editable\r\n        )\r\n\r\n    @property\r\n    def is_direct_url(self):\r\n        # type: () -> bool\r\n        if self._parsed_line is not None and self._parsed_line.is_direct_url:\r\n            return True\r\n        return self.is_remote_artifact\r\n\r\n    @property\r\n    def formatted_path(self):\r\n        # type: () -> Optional[STRING_TYPE]\r\n        if self.path:\r\n            path = self.path\r\n            if not isinstance(path, Path):\r\n                path = Path(path)\r\n            return path.as_posix()\r\n        return None\r\n\r\n    @classmethod\r\n    def from_line(cls, line, editable=None, extras=None, parsed_line=None):\r\n        # type: (AnyStr, Optional[bool], Optional[Tuple[AnyStr, ...]], Optional[Line]) -> F\r\n        parsed_line = Line(line)\r\n        file_req_from_parsed_line(parsed_line)\r\n\r\n    @classmethod\r\n    def from_pipfile(cls, name, pipfile):\r\n        # type: (STRING_TYPE, Dict[STRING_TYPE, Union[Tuple[STRING_TYPE, ...], STRING_TYPE, bool]]) -> F\r\n        # Parse the values out. After this dance we should have two variables:\r\n        # path - Local filesystem path.\r\n        # uri - Absolute URI that is parsable with urlsplit.\r\n        # One of these will be a string; the other would be None.\r\n        uri = pipfile.get(\"uri\")\r\n        fil = pipfile.get(\"file\")\r\n        path = pipfile.get(\"path\")\r\n        if path and isinstance(path, six.string_types):\r\n            if isinstance(path, Path) and not path.is_absolute():\r\n                path = get_converted_relative_path(path.as_posix())\r\n            elif not os.path.isabs(path):\r\n                path = get_converted_relative_path(path)\r\n        if path and uri:\r\n            raise ValueError(\"do not specify both 'path' and 'uri'\")\r\n        if path and fil:\r\n            raise ValueError(\"do not specify both 'path' and 'file'\")\r\n        uri = uri or fil\r\n\r\n        # Decide that scheme to use.\r\n        # 'path' - local filesystem path.\r\n        # 'file' - A file:// URI (possibly with VCS prefix).\r\n        # 'uri' - Any other URI.\r\n        if path:\r\n            uri_scheme = \"path\"\r\n        else:\r\n            # URI is not currently a valid key in pipfile entries\r\n            # see https://github.com/pypa/pipfile/issues/110\r\n            uri_scheme = \"file\"\r\n\r\n        if not uri:\r\n            uri = pip_shims.shims.path_to_url(path)\r\n        link_info = None  # type: Optional[LinkInfo]\r\n        if uri and isinstance(uri, six.string_types):\r\n            link_info = cls.get_link_from_line(uri)\r\n        else:\r\n            raise ValueError(\r\n                \"Failed parsing requirement from pipfile: {0!r}\".format(pipfile)\r\n            )\r\n        link = None  # type: Optional[Link]\r\n        if link_info:\r\n            link = link_info.link\r\n            if link.url_without_fragment:\r\n                uri = unquote(link.url_without_fragment)\r\n        extras = ()  # type: Optional[Tuple[STRING_TYPE, ...]]\r\n        if \"extras\" in pipfile:\r\n            extras = tuple(pipfile[\"extras\"])  # type: ignore\r\n        editable = pipfile[\"editable\"] if \"editable\" in pipfile else False\r\n        arg_dict = {\r\n            \"name\": name,\r\n            \"path\": path,\r\n            \"uri\": uri,\r\n            \"editable\": editable,\r\n            \"link\": link,\r\n            \"uri_scheme\": uri_scheme,\r\n            \"extras\": extras if extras else None,\r\n        }\r\n\r\n        line = \"\"  # type: STRING_TYPE\r\n        extras_string = \"\" if not extras else extras_to_string(extras)\r\n        if editable and uri_scheme == \"path\":\r\n            line = \"{0}{1}\".format(path, extras_string)\r\n        else:\r\n            if name:\r\n                line_name = \"{0}{1}\".format(name, extras_string)\r\n                line = \"{0}#egg={1}\".format(unquote(link.url_without_fragment), line_name)\r\n            else:\r\n                if link:\r\n                    line = unquote(link.url)\r\n                elif uri and isinstance(uri, six.string_types):\r\n                    line = uri\r\n                else:\r\n                    raise ValueError(\r\n                        \"Failed parsing requirement from pipfile: {0!r}\".format(pipfile)\r\n                    )\r\n                line = \"{0}{1}\".format(line, extras_string)\r\n            if \"subdirectory\" in pipfile:\r\n                arg_dict[\"subdirectory\"] = pipfile[\"subdirectory\"]\r\n                line = \"{0}&subdirectory={1}\".format(line, pipfile[\"subdirectory\"])\r\n        if editable:\r\n            line = \"-e {0}\".format(line)\r\n        arg_dict[\"parsed_line\"] = Line(line)\r\n        arg_dict[\"setup_info\"] = arg_dict[\"parsed_line\"].setup_info\r\n        return cls(**arg_dict)  # type: ignore\r\n\r\n    @property\r\n    def line_part(self):\r\n        # type: () -> STRING_TYPE\r\n        link_url = None  # type: Optional[STRING_TYPE]\r\n        seed = None  # type: Optional[STRING_TYPE]\r\n        if self.link is not None:\r\n            link_url = unquote(self.link.url_without_fragment)\r\n        is_vcs = getattr(self.link, \"is_vcs\", not self.link.is_artifact)\r\n        if self._uri_scheme and self._uri_scheme == \"path\":\r\n            # We may need any one of these for passing to pip\r\n            seed = self.path or link_url or self.uri\r\n        elif (self._uri_scheme and self._uri_scheme == \"file\") or (\r\n            (self.link.is_wheel or not is_vcs) and self.link.url\r\n        ):\r\n            seed = link_url or self.uri\r\n        # add egg fragments to remote artifacts (valid urls only)\r\n        if not self._has_hashed_name and self.is_remote_artifact and seed is not None:\r\n            seed += \"#egg={0}\".format(self.name)\r\n        editable = \"-e \" if self.editable else \"\"\r\n        if seed is None:\r\n            raise ValueError(\"Could not calculate url for {0!r}\".format(self))\r\n        return \"{0}{1}\".format(editable, seed)\r\n\r\n    @property\r\n    def pipfile_part(self):\r\n        # type: () -> Dict[AnyStr, Dict[AnyStr, Any]]\r\n        excludes = [\r\n            \"_base_line\",\r\n            \"_has_hashed_name\",\r\n            \"setup_path\",\r\n            \"pyproject_path\",\r\n            \"_uri_scheme\",\r\n            \"pyproject_requires\",\r\n            \"pyproject_backend\",\r\n            \"_setup_info\",\r\n            \"_parsed_line\",\r\n        ]\r\n        filter_func = lambda k, v: bool(v) is True and k.name not in excludes  # noqa\r\n        pipfile_dict = attr.asdict(self, filter=filter_func).copy()  # type: Dict\r\n        name = pipfile_dict.pop(\"name\", None)\r\n        if name is None:\r\n            if self.name:\r\n                name = self.name\r\n            elif self.parsed_line and self.parsed_line.name:\r\n                name = self.name = self.parsed_line.name\r\n            elif self.setup_info and self.setup_info.name:\r\n                name = self.name = self.setup_info.name\r\n        if \"_uri_scheme\" in pipfile_dict:\r\n            pipfile_dict.pop(\"_uri_scheme\")\r\n        # For local paths and remote installable artifacts (zipfiles, etc)\r\n        collision_keys = {\"file\", \"uri\", \"path\"}\r\n        collision_order = [\"file\", \"uri\", \"path\"]  # type: List[STRING_TYPE]\r\n        collisions = []  # type: List[STRING_TYPE]\r\n        key_match = next(iter(k for k in collision_order if k in pipfile_dict.keys()))\r\n        is_vcs = None\r\n        if self.link is not None:\r\n            is_vcs = getattr(self.link, \"is_vcs\", not self.link.is_artifact)\r\n        if self._uri_scheme:\r\n            dict_key = self._uri_scheme\r\n            target_key = dict_key if dict_key in pipfile_dict else key_match\r\n            if target_key is not None:\r\n                winning_value = pipfile_dict.pop(target_key)\r\n                collisions = [k for k in collision_keys if k in pipfile_dict]\r\n                for key in collisions:\r\n                    pipfile_dict.pop(key)\r\n                pipfile_dict[dict_key] = winning_value\r\n        elif (\r\n            self.is_remote_artifact\r\n            or (is_vcs is not None and not is_vcs)\r\n            and (self._uri_scheme and self._uri_scheme == \"file\")\r\n        ):\r\n            dict_key = \"file\"\r\n            # Look for uri first because file is a uri format and this is designed\r\n            # to make sure we add file keys to the pipfile as a replacement of uri\r\n            if key_match is not None:\r\n                winning_value = pipfile_dict.pop(key_match)\r\n            key_to_remove = (k for k in collision_keys if k in pipfile_dict)\r\n            for key in key_to_remove:\r\n                pipfile_dict.pop(key)\r\n            pipfile_dict[dict_key] = winning_value\r\n        else:\r\n            collisions = [key for key in collision_order if key in pipfile_dict.keys()]\r\n            if len(collisions) > 1:\r\n                for k in collisions[1:]:\r\n                    pipfile_dict.pop(k)\r\n        return {name: pipfile_dict}\r\n\r\n\r\n@attr.s(slots=True, hash=True)\r\nclass VCSRequirement(FileRequirement):\r\n    #: Whether the repository is editable\r\n    editable = attr.ib(default=None)  # type: Optional[bool]\r\n    #: URI for the repository\r\n    uri = attr.ib(default=None)  # type: Optional[STRING_TYPE]\r\n    #: path to the repository, if it's local\r\n    path = attr.ib(\r\n        default=None, validator=attr.validators.optional(validate_path)\r\n    )  # type: Optional[STRING_TYPE]\r\n    #: vcs type, i.e. git/hg/svn\r\n    vcs = attr.ib(\r\n        validator=attr.validators.optional(validate_vcs), default=None\r\n    )  # type: Optional[STRING_TYPE]\r\n    #: vcs reference name (branch / commit / tag)\r\n    ref = attr.ib(default=None)  # type: Optional[STRING_TYPE]\r\n    #: Subdirectory to use for installation if applicable\r\n    _repo = attr.ib(default=None)  # type: Optional[VCSRepository]\r\n    _base_line = attr.ib(default=None)  # type: Optional[STRING_TYPE]\r\n    name = attr.ib()  # type: STRING_TYPE\r\n    link = attr.ib()  # type: Optional[pip_shims.shims.Link]\r\n    req = attr.ib()  # type: Optional[RequirementType]\r\n\r\n    def __attrs_post_init__(self):\r\n        # type: () -> None\r\n        if not self.uri:\r\n            if self.path:\r\n                self.uri = pip_shims.shims.path_to_url(self.path)\r\n        if self.uri is not None:\r\n            split = urllib_parse.urlsplit(self.uri)\r\n            scheme, rest = split[0], split[1:]\r\n            vcs_type = \"\"\r\n            if \"+\" in scheme:\r\n                vcs_type, scheme = scheme.split(\"+\", 1)\r\n                vcs_type = \"{0}+\".format(vcs_type)\r\n            new_uri = urllib_parse.urlunsplit((scheme,) + rest[:-1] + (\"\",))\r\n            new_uri = \"{0}{1}\".format(vcs_type, new_uri)\r\n            self.uri = new_uri\r\n\r\n    @property\r\n    def url(self):\r\n        # type: () -> STRING_TYPE\r\n        if self.link and self.link.url:\r\n            return self.link.url\r\n        elif self.uri:\r\n            return self.uri\r\n        raise ValueError(\"No valid url found for requirement {0!r}\".format(self))\r\n\r\n    @link.default\r\n    def get_link(self):\r\n        # type: () -> pip_shims.shims.Link\r\n        uri = self.uri if self.uri else pip_shims.shims.path_to_url(self.path)\r\n        vcs_uri = build_vcs_uri(\r\n            self.vcs,\r\n            add_ssh_scheme_to_git_uri(uri),\r\n            name=self.name,\r\n            ref=self.ref,\r\n            subdirectory=self.subdirectory,\r\n            extras=self.extras,\r\n        )\r\n        return self.get_link_from_line(vcs_uri).link\r\n\r\n    @name.default\r\n    def get_name(self):\r\n        # type: () -> STRING_TYPE\r\n        if self.link and self.link.egg_fragment:\r\n            return self.link.egg_fragment\r\n        if self.req and self.req.name:\r\n            return self.req.name\r\n        return super(VCSRequirement, self).get_name()\r\n\r\n    @property\r\n    def vcs_uri(self):\r\n        # type: () -> Optional[STRING_TYPE]\r\n        uri = self.uri\r\n        if uri and not any(uri.startswith(\"{0}+\".format(vcs)) for vcs in VCS_LIST):\r\n            if self.vcs:\r\n                uri = \"{0}+{1}\".format(self.vcs, uri)\r\n        return uri\r\n\r\n    @property\r\n    def setup_info(self):\r\n        if self._parsed_line and self._parsed_line.setup_info:\r\n            if not self._parsed_line.setup_info.name:\r\n                with pip_shims.shims.global_tempdir_manager():\r\n                    self._parsed_line._setup_info.get_info()\r\n            return self._parsed_line.setup_info\r\n        subdir = self.subdirectory or self.parsed_line.subdirectory\r\n        if self._repo:\r\n            with pip_shims.shims.global_tempdir_manager():\r\n                self._setup_info = SetupInfo.from_ireq(\r\n                    Line(self._repo.checkout_directory).ireq, subdir=subdir\r\n                )\r\n                self._setup_info.get_info()\r\n            return self._setup_info\r\n        ireq = self.parsed_line.ireq\r\n\r\n        with pip_shims.shims.global_tempdir_manager():\r\n            self._setup_info = SetupInfo.from_ireq(ireq, subdir=subdir)\r\n        return self._setup_info\r\n\r\n    @setup_info.setter\r\n    def setup_info(self, setup_info):\r\n        self._setup_info = setup_info\r\n        if self._parsed_line:\r\n            self._parsed_line.setup_info = setup_info\r\n\r\n    @req.default\r\n    def get_requirement(self):\r\n        # type: () -> PackagingRequirement\r\n        name = None  # type: Optional[STRING_TYPE]\r\n        if self.name:\r\n            name = self.name\r\n        elif self.link and self.link.egg_fragment:\r\n            name = self.link.egg_fragment\r\n        url = None\r\n        if self.uri:\r\n            url = self.uri\r\n        elif self.link is not None:\r\n            url = self.link.url_without_fragment\r\n        if not name:\r\n            raise ValueError(\r\n                \"pipenv requires an #egg fragment for version controlled \"\r\n                \"dependencies. Please install remote dependency \"\r\n                \"in the form {0}#egg=<package-name>.\".format(url)\r\n            )\r\n        req = init_requirement(canonicalize_name(self.name))\r\n        req.editable = self.editable\r\n        if not getattr(req, \"url\", None):\r\n            if url is not None:\r\n                url = add_ssh_scheme_to_git_uri(url)\r\n            elif self.uri is not None:\r\n                link = self.get_link_from_line(self.uri).link\r\n                if link:\r\n                    url = link.url_without_fragment\r\n            if (\r\n                url\r\n                and url.startswith(\"git+file:/\")\r\n                and not url.startswith(\"git+file:///\")\r\n            ):\r\n                url = url.replace(\"git+file:/\", \"git+file:///\")\r\n            if url:\r\n                req.url = url\r\n        line = url if url else self.vcs_uri\r\n        if self.editable:\r\n            line = \"-e {0}\".format(line)\r\n        req.line = line\r\n        if self.ref:\r\n            req.revision = self.ref\r\n        if self.extras:\r\n            req.extras = self.extras\r\n        req.vcs = self.vcs\r\n        if self.path and self.link and self.link.scheme.startswith(\"file\"):\r\n            req.local_file = True\r\n            req.path = self.path\r\n        req.link = self.link\r\n        if (\r\n            self.link\r\n            and self.link.url_without_fragment\r\n            and self.uri\r\n            and self.uri != unquote(self.link.url_without_fragment)\r\n            and \"git+ssh://\" in self.link.url\r\n            and \"git+git@\" in self.uri\r\n        ):\r\n            req.line = self.uri\r\n            url = self.link.url_without_fragment\r\n            if (\r\n                url\r\n                and url.startswith(\"git+file:/\")\r\n                and not url.startswith(\"git+file:///\")\r\n            ):\r\n                url = url.replace(\"git+file:/\", \"git+file:///\")\r\n            req.url = url\r\n        return req\r\n\r\n    @property\r\n    def repo(self):\r\n        # type: () -> VCSRepository\r\n        if self._repo is None:\r\n            if self._parsed_line and self._parsed_line.vcsrepo:\r\n                self._repo = self._parsed_line.vcsrepo\r\n            else:\r\n                self._repo = self.get_vcs_repo()\r\n                if self._parsed_line:\r\n                    self._parsed_line.vcsrepo = self._repo\r\n        return self._repo\r\n\r\n    def get_checkout_dir(self, src_dir=None):\r\n        # type: (Optional[S]) -> STRING_TYPE\r\n        src_dir = os.environ.get(\"PIP_SRC\", None) if not src_dir else src_dir\r\n        checkout_dir = None\r\n        if self.is_local:\r\n            path = self.path\r\n            if not path:\r\n                path = pip_shims.shims.url_to_path(self.uri)\r\n            if path and os.path.exists(path):\r\n                checkout_dir = os.path.abspath(path)\r\n                return checkout_dir\r\n        if src_dir is not None:\r\n            checkout_dir = os.path.join(os.path.abspath(src_dir), self.name)\r\n            mkdir_p(src_dir)\r\n            return checkout_dir\r\n        return os.path.join(create_tracked_tempdir(prefix=\"requirementslib\"), self.name)\r\n\r\n    def get_vcs_repo(self, src_dir=None, checkout_dir=None):\r\n        # type: (Optional[STRING_TYPE], STRING_TYPE) -> VCSRepository\r\n        from .vcs import VCSRepository\r\n\r\n        if checkout_dir is None:\r\n            checkout_dir = self.get_checkout_dir(src_dir=src_dir)\r\n        vcsrepo = VCSRepository(\r\n            url=self.url,\r\n            name=self.name,\r\n            ref=self.ref if self.ref else None,\r\n            checkout_directory=checkout_dir,\r\n            vcs_type=self.vcs,\r\n            subdirectory=self.subdirectory,\r\n        )\r\n        if not self.is_local:\r\n            vcsrepo.obtain()\r\n        pyproject_info = None\r\n        if self.subdirectory:\r\n            self.setup_path = os.path.join(checkout_dir, self.subdirectory, \"setup.py\")\r\n            self.pyproject_path = os.path.join(\r\n                checkout_dir, self.subdirectory, \"pyproject.toml\"\r\n            )\r\n            pyproject_info = get_pyproject(os.path.join(checkout_dir, self.subdirectory))\r\n        else:\r\n            self.setup_path = os.path.join(checkout_dir, \"setup.py\")\r\n            self.pyproject_path = os.path.join(checkout_dir, \"pyproject.toml\")\r\n            pyproject_info = get_pyproject(checkout_dir)\r\n        if pyproject_info is not None:\r\n            pyproject_requires, pyproject_backend = pyproject_info\r\n            self.pyproject_requires = tuple(pyproject_requires)\r\n            self.pyproject_backend = pyproject_backend\r\n        return vcsrepo\r\n\r\n    def get_commit_hash(self):\r\n        # type: () -> STRING_TYPE\r\n        with pip_shims.shims.global_tempdir_manager():\r\n            hash_ = self.repo.get_commit_hash()\r\n        return hash_\r\n\r\n    def update_repo(self, src_dir=None, ref=None):\r\n        # type: (Optional[STRING_TYPE], Optional[STRING_TYPE]) -> STRING_TYPE\r\n        if ref:\r\n            self.ref = ref\r\n        repo_hash = None\r\n        if not self.is_local and self.ref is not None:\r\n            self.repo.checkout_ref(self.ref)\r\n        repo_hash = self.get_commit_hash()\r\n        if self.req:\r\n            self.req.revision = repo_hash\r\n        return repo_hash\r\n\r\n    @contextmanager\r\n    def locked_vcs_repo(self, src_dir=None):\r\n        # type: (Optional[AnyStr]) -> Generator[VCSRepository, None, None]\r\n        if not src_dir:\r\n            src_dir = create_tracked_tempdir(prefix=\"requirementslib-\", suffix=\"-src\")\r\n        vcsrepo = self.get_vcs_repo(src_dir=src_dir)\r\n        if not self.req:\r\n            if self.parsed_line is not None:\r\n                self.req = self.parsed_line.requirement\r\n            else:\r\n                self.req = self.get_requirement()\r\n        with pip_shims.shims.global_tempdir_manager():\r\n            revision = self.req.revision = vcsrepo.get_commit_hash()\r\n\r\n        # Remove potential ref in the end of uri after ref is parsed\r\n        if self.link and \"@\" in self.link.show_url and self.uri and \"@\" in self.uri:\r\n            uri, ref = split_ref_from_uri(self.uri)\r\n            checkout = revision\r\n            if checkout and ref and ref in checkout:\r\n                self.uri = uri\r\n        orig_repo = self._repo\r\n        self._repo = vcsrepo\r\n        if self._parsed_line:\r\n            self._parsed_line.vcsrepo = vcsrepo\r\n        if self._setup_info:\r\n            self._setup_info = attr.evolve(\r\n                self._setup_info,\r\n                requirements=(),\r\n                _extras_requirements=(),\r\n                build_requires=(),\r\n                setup_requires=(),\r\n                version=None,\r\n                metadata=None,\r\n            )\r\n        if self.parsed_line and self._parsed_line:\r\n            self._parsed_line.vcsrepo = vcsrepo\r\n        if self.req and not self.editable:\r\n            self.req.specifier = SpecifierSet(\"=={0}\".format(self.setup_info.version))\r\n        try:\r\n            yield self._repo\r\n        except Exception:\r\n            self._repo = orig_repo\r\n            raise\r\n\r\n    @classmethod\r\n    def from_pipfile(cls, name, pipfile):\r\n        # type: (STRING_TYPE, Dict[S, Union[Tuple[S, ...], S, bool]]) -> F\r\n        creation_args = {}  # type: Dict[STRING_TYPE, CREATION_ARG_TYPES]\r\n        pipfile_keys = [\r\n            k\r\n            for k in (\r\n                \"ref\",\r\n                \"vcs\",\r\n                \"subdirectory\",\r\n                \"path\",\r\n                \"editable\",\r\n                \"file\",\r\n                \"uri\",\r\n                \"extras\",\r\n            )\r\n            + VCS_LIST\r\n            if k in pipfile\r\n        ]\r\n        # extras = None  # type: Optional[Tuple[STRING_TYPE, ...]]\r\n        for key in pipfile_keys:\r\n            if key == \"extras\" and key in pipfile:\r\n                extras = pipfile[key]\r\n                if isinstance(extras, (list, tuple)):\r\n                    pipfile[key] = tuple(sorted({extra.lower() for extra in extras}))\r\n                else:\r\n                    pipfile[key] = extras\r\n            if key in VCS_LIST and key in pipfile_keys:\r\n                creation_args[\"vcs\"] = key\r\n                target = pipfile[key]\r\n                if isinstance(target, six.string_types):\r\n                    drive, path = os.path.splitdrive(target)\r\n                    if (\r\n                        not drive\r\n                        and not os.path.exists(target)\r\n                        and (\r\n                            is_valid_url(target)\r\n                            or is_file_url(target)\r\n                            or target.startswith(\"git@\")\r\n                        )\r\n                    ):\r\n                        creation_args[\"uri\"] = target\r\n                    else:\r\n                        creation_args[\"path\"] = target\r\n                        if os.path.isabs(target):\r\n                            creation_args[\"uri\"] = pip_shims.shims.path_to_url(target)\r\n            elif key in pipfile_keys:\r\n                creation_args[key] = pipfile[key]\r\n        creation_args[\"name\"] = name\r\n        cls_inst = cls(**creation_args)  # type: ignore\r\n        return cls_inst\r\n\r\n    @classmethod\r\n    def from_line(cls, line, editable=None, extras=None, parsed_line=None):\r\n        # type: (AnyStr, Optional[bool], Optional[Tuple[AnyStr, ...]], Optional[Line]) -> F\r\n        parsed_line = Line(line)\r\n        return vcs_req_from_parsed_line(parsed_line)\r\n\r\n    @property\r\n    def line_part(self):\r\n        # type: () -> STRING_TYPE\r\n        \"\"\"requirements.txt compatible line part sans-extras.\"\"\"\r\n        base = \"\"  # type: STRING_TYPE\r\n        if self.is_local:\r\n            base_link = self.link\r\n            if not self.link:\r\n                base_link = self.get_link()\r\n            if base_link and base_link.egg_fragment:\r\n                final_format = \"{{0}}#egg={0}\".format(base_link.egg_fragment)\r\n            else:\r\n                final_format = \"{0}\"\r\n            base = final_format.format(self.vcs_uri)\r\n        elif self._parsed_line is not None and (\r\n            self._parsed_line.is_direct_url and self._parsed_line.line_with_prefix\r\n        ):\r\n            return self._parsed_line.line_with_prefix\r\n        elif getattr(self, \"_base_line\", None) and (\r\n            isinstance(self._base_line, six.string_types)\r\n        ):\r\n            base = self._base_line\r\n        else:\r\n            base = getattr(self, \"link\", self.get_link()).url\r\n        if base and self.extras and extras_to_string(self.extras) not in base:\r\n            if self.subdirectory:\r\n                base = \"{0}\".format(self.get_link().url)\r\n            else:\r\n                base = \"{0}{1}\".format(base, extras_to_string(sorted(self.extras)))\r\n        if \"git+file:/\" in base and \"git+file:///\" not in base:\r\n            base = base.replace(\"git+file:/\", \"git+file:///\")\r\n        if self.editable and not base.startswith(\"-e \"):\r\n            base = \"-e {0}\".format(base)\r\n        return base\r\n\r\n    @staticmethod\r\n    def _choose_vcs_source(pipfile):\r\n        # type: (Dict[S, Union[S, Any]]) -> Dict[S, Union[S, Any]]\r\n        src_keys = [k for k in pipfile.keys() if k in [\"path\", \"uri\", \"file\"]]\r\n        vcs_type = \"\"  # type: Optional[STRING_TYPE]\r\n        alt_type = \"\"  # type: Optional[STRING_TYPE]\r\n        vcs_value = \"\"  # type: STRING_TYPE\r\n        if src_keys:\r\n            chosen_key = next(iter(src_keys))\r\n            vcs_type = pipfile.pop(\"vcs\")\r\n            if chosen_key in pipfile:\r\n                vcs_value = pipfile[chosen_key]\r\n                alt_type, pipfile_url = split_vcs_method_from_uri(vcs_value)\r\n                if vcs_type is None:\r\n                    vcs_type = alt_type\r\n            if vcs_type and pipfile_url:\r\n                pipfile[vcs_type] = pipfile_url\r\n            for removed in src_keys:\r\n                pipfile.pop(removed)\r\n        return pipfile\r\n\r\n    @property\r\n    def pipfile_part(self):\r\n        # type: () -> Dict[S, Dict[S, Union[List[S], S, bool, RequirementType, pip_shims.shims.Link]]]\r\n        excludes = [\r\n            \"_repo\",\r\n            \"_base_line\",\r\n            \"setup_path\",\r\n            \"_has_hashed_name\",\r\n            \"pyproject_path\",\r\n            \"pyproject_requires\",\r\n            \"pyproject_backend\",\r\n            \"_setup_info\",\r\n            \"_parsed_line\",\r\n            \"_uri_scheme\",\r\n        ]\r\n        filter_func = lambda k, v: bool(v) is True and k.name not in excludes  # noqa\r\n        pipfile_dict = attr.asdict(self, filter=filter_func).copy()\r\n        name = pipfile_dict.pop(\"name\", None)\r\n        if name is None:\r\n            if self.name:\r\n                name = self.name\r\n            elif self.parsed_line and self.parsed_line.name:\r\n                name = self.name = self.parsed_line.name\r\n            elif self.setup_info and self.setup_info.name:\r\n                name = self.name = self.setup_info.name\r\n        if \"vcs\" in pipfile_dict:\r\n            pipfile_dict = self._choose_vcs_source(pipfile_dict)\r\n        name, _ = pip_shims.shims._strip_extras(name)\r\n        return {name: pipfile_dict}  # type: ignore\r\n\r\n\r\n@attr.s(cmp=True, hash=True)\r\nclass Requirement(object):\r\n    _name = attr.ib(cmp=True)  # type: STRING_TYPE\r\n    vcs = attr.ib(\r\n        default=None, validator=attr.validators.optional(validate_vcs), cmp=True\r\n    )  # type: Optional[STRING_TYPE]\r\n    req = attr.ib(\r\n        default=None, cmp=True\r\n    )  # type: Optional[Union[VCSRequirement, FileRequirement, NamedRequirement]]\r\n    markers = attr.ib(default=None, cmp=True)  # type: Optional[STRING_TYPE]\r\n    _specifiers = attr.ib(\r\n        validator=attr.validators.optional(validate_specifiers), cmp=True\r\n    )  # type: Optional[STRING_TYPE]\r\n    index = attr.ib(default=None, cmp=True)  # type: Optional[STRING_TYPE]\r\n    editable = attr.ib(default=None, cmp=True)  # type: Optional[bool]\r\n    hashes = attr.ib(\r\n        factory=frozenset, converter=frozenset, cmp=True\r\n    )  # type: FrozenSet[STRING_TYPE]\r\n    extras = attr.ib(factory=tuple, cmp=True)  # type: Tuple[STRING_TYPE, ...]\r\n    abstract_dep = attr.ib(default=None, cmp=False)  # type: Optional[AbstractDependency]\r\n    _line_instance = attr.ib(default=None, cmp=False)  # type: Optional[Line]\r\n    _ireq = attr.ib(\r\n        default=None, cmp=False\r\n    )  # type: Optional[pip_shims.InstallRequirement]\r\n\r\n    def __hash__(self):\r\n        return hash(self.as_line())\r\n\r\n    @_name.default\r\n    def get_name(self):\r\n        # type: () -> Optional[STRING_TYPE]\r\n        if self.req is not None:\r\n            return self.req.name\r\n        return None\r\n\r\n    @property\r\n    def name(self):\r\n        # type: () -> Optional[STRING_TYPE]\r\n        if self._name is not None:\r\n            return self._name\r\n        name = None\r\n        if self.req and self.req.name:\r\n            name = self.req.name\r\n        elif self.req and self.is_file_or_url and self.req.setup_info:\r\n            name = self.req.setup_info.name\r\n        self._name = name\r\n        return name\r\n\r\n    @property\r\n    def requirement(self):\r\n        # type: () -> Optional[PackagingRequirement]\r\n        if self.req:\r\n            return self.req.req\r\n        return None\r\n\r\n    def add_hashes(self, hashes):\r\n        # type: (Union[S, List[S], Set[S], Tuple[S, ...]]) -> Requirement\r\n        new_hashes = set()  # type: Set[STRING_TYPE]\r\n        if self.hashes is not None:\r\n            new_hashes |= set(self.hashes)\r\n        if isinstance(hashes, six.string_types):\r\n            new_hashes.add(hashes)\r\n        else:\r\n            new_hashes |= set(hashes)\r\n        return attr.evolve(self, hashes=tuple(new_hashes))\r\n\r\n    def get_hashes_as_pip(self, as_list=False):\r\n        # type: (bool) -> Union[STRING_TYPE, List[STRING_TYPE]]\r\n        hashes = \"\"  # type: Union[STRING_TYPE, List[STRING_TYPE]]\r\n        if as_list:\r\n            hashes = []\r\n            if self.hashes:\r\n                hashes = [HASH_STRING.format(h) for h in self.hashes]\r\n        else:\r\n            hashes = \"\"\r\n            if self.hashes:\r\n                hashes = \"\".join([HASH_STRING.format(h) for h in self.hashes])\r\n        return hashes\r\n\r\n    @property\r\n    def hashes_as_pip(self):\r\n        # type: () -> STRING_TYPE\r\n        hashes = self.get_hashes_as_pip()\r\n        assert isinstance(hashes, six.string_types)\r\n        return hashes\r\n\r\n    @property\r\n    def markers_as_pip(self):\r\n        # type: () -> S\r\n        if self.markers:\r\n            return \" ; {0}\".format(self.markers).replace('\"', \"'\")\r\n\r\n        return \"\"\r\n\r\n    @property\r\n    def extras_as_pip(self):\r\n        # type: () -> STRING_TYPE\r\n        if self.extras:\r\n            return \"[{0}]\".format(\r\n                \",\".join(sorted([extra.lower() for extra in self.extras]))  # type: ignore\r\n            )\r\n\r\n        return \"\"\r\n\r\n    @cached_property\r\n    def commit_hash(self):\r\n        # type: () -> Optional[S]\r\n        if self.req is None or not isinstance(self.req, VCSRequirement):\r\n            return None\r\n        commit_hash = None\r\n        if self.req is not None:\r\n            with self.req.locked_vcs_repo() as repo:\r\n                commit_hash = repo.get_commit_hash()\r\n        return commit_hash\r\n\r\n    @_specifiers.default\r\n    def get_specifiers(self):\r\n        # type: () -> S\r\n        if self.req and self.req.req and self.req.req.specifier:\r\n            return specs_to_string(self.req.req.specifier)\r\n        return \"\"\r\n\r\n    def update_name_from_path(self, path):\r\n        metadata = get_metadata(path)\r\n        name = self.name\r\n        if metadata is not None:\r\n            metadata_name = metadata.get(\"name\")\r\n            if metadata_name and metadata_name != \"wheel\":\r\n                name = metadata_name\r\n        if name is not None:\r\n            if self.req.name is None:\r\n                self.req.name = name\r\n            if self.req.req and self.req.req.name is None:\r\n                self.req.req.name = name\r\n            if self._line_instance._name is None:\r\n                self._line_instance.name = name\r\n            if self.req._parsed_line._name is None:\r\n                self.req._parsed_line.name = name\r\n            if self.req._setup_info and self.req._setup_info.name is None:\r\n                self.req._setup_info.name = name\r\n\r\n    def get_line_instance(self):\r\n        # type: () -> Line\r\n        line_parts = []\r\n        if self.req:\r\n            if self.req.line_part.startswith(\"-e \"):\r\n                line_parts.extend(self.req.line_part.split(\" \", 1))\r\n            else:\r\n                line_parts.append(self.req.line_part)\r\n        if not self.is_vcs and not self.vcs and self.extras_as_pip:\r\n            line_parts.append(self.extras_as_pip)\r\n        if self._specifiers and not (self.is_file_or_url or self.is_vcs):\r\n            line_parts.append(self._specifiers)\r\n        if self.markers:\r\n            line_parts.append(\"; {0}\".format(self.markers.replace('\"', \"'\")))\r\n        if self.hashes_as_pip and not (self.editable or self.vcs or self.is_vcs):\r\n            line_parts.append(self.hashes_as_pip)\r\n        if self.editable:\r\n            if line_parts[0] == \"-e\":\r\n                line = \"\".join(line_parts[1:])\r\n            else:\r\n                line = \"\".join(line_parts)\r\n            if self.markers:\r\n                line = '\"{0}\"'.format(line)\r\n            line = \"-e {0}\".format(line)\r\n        else:\r\n            line = \"\".join(line_parts)\r\n        return Line(line)\r\n\r\n    @property\r\n    def line_instance(self):\r\n        # type: () -> Optional[Line]\r\n        if self._line_instance is None:\r\n            self.line_instance = self.get_line_instance()\r\n        return self._line_instance\r\n\r\n    @line_instance.setter\r\n    def line_instance(self, line_instance):\r\n        # type: (Line) -> None\r\n        if self.req:\r\n            self.req._parsed_line = line_instance\r\n        self._line_instance = line_instance\r\n\r\n    @property\r\n    def specifiers(self):\r\n        # type: () -> Optional[STRING_TYPE]\r\n        if self._specifiers:\r\n            return self._specifiers\r\n        else:\r\n            specs = self.get_specifiers()\r\n            if specs:\r\n                self._specifiers = specs\r\n                return specs\r\n        if not self._specifiers and (\r\n            self.req is not None\r\n            and isinstance(self.req, NamedRequirement)\r\n            and self.req.version\r\n        ):\r\n            self._specifiers = self.req.version\r\n        elif (\r\n            not self.editable\r\n            and self.req\r\n            and (not isinstance(self.req, NamedRequirement) and self.req.setup_info)\r\n        ):\r\n            if (\r\n                self.line_instance\r\n                and self.line_instance.setup_info\r\n                and self.line_instance.setup_info.version\r\n            ):\r\n                self._specifiers = \"=={0}\".format(self.req.setup_info.version)\r\n        elif not self._specifiers:\r\n            if self.req and self.req.parsed_line and self.req.parsed_line.specifiers:\r\n                self._specifiers = specs_to_string(self.req.parsed_line.specifiers)\r\n            elif self.line_instance and self.line_instance.specifiers:\r\n                self._specifiers = specs_to_string(self.line_instance.specifiers)\r\n            elif self.is_file_or_url or self.is_vcs:\r\n                try:\r\n                    setupinfo_dict = self.run_requires()\r\n                except Exception:\r\n                    setupinfo_dict = None\r\n                if setupinfo_dict is not None:\r\n                    self._specifiers = \"=={0}\".format(setupinfo_dict.get(\"version\"))\r\n        if self._specifiers:\r\n            specset = SpecifierSet(self._specifiers)\r\n            if self.line_instance and not self.line_instance.specifiers:\r\n                self.line_instance.specifiers = specset\r\n            if self.req:\r\n                if self.req._parsed_line and not self.req._parsed_line.specifiers:\r\n                    self.req._parsed_line.specifiers = specset\r\n                elif not self.req._parsed_line and self.line_instance:\r\n                    self.req._parsed_line = self.line_instance\r\n            if self.req and self.req.req and not self.req.req.specifier:\r\n                self.req.req.specifier = specset\r\n        return self._specifiers\r\n\r\n    @property\r\n    def is_vcs(self):\r\n        # type: () -> bool\r\n        return isinstance(self.req, VCSRequirement)\r\n\r\n    @property\r\n    def build_backend(self):\r\n        # type: () -> Optional[STRING_TYPE]\r\n        if self.req is not None and (\r\n            not isinstance(self.req, NamedRequirement) and self.req.is_local\r\n        ):\r\n            with pip_shims.shims.global_tempdir_manager():\r\n                setup_info = self.run_requires()\r\n            build_backend = setup_info.get(\"build_backend\")\r\n            return build_backend\r\n        return \"setuptools.build_meta\"\r\n\r\n    @property\r\n    def uses_pep517(self):\r\n        # type: () -> bool\r\n        if self.build_backend:\r\n            return True\r\n        return False\r\n\r\n    @property\r\n    def is_file_or_url(self):\r\n        # type: () -> bool\r\n        return isinstance(self.req, FileRequirement)\r\n\r\n    @property\r\n    def is_named(self):\r\n        # type: () -> bool\r\n        return isinstance(self.req, NamedRequirement)\r\n\r\n    @property\r\n    def is_wheel(self):\r\n        # type: () -> bool\r\n        if (\r\n            self.req\r\n            and not isinstance(self.req, NamedRequirement)\r\n            and (self.req.link is not None and self.req.link.is_wheel)\r\n        ):\r\n            return True\r\n        return False\r\n\r\n    @property\r\n    def normalized_name(self):\r\n        # type: () -> S\r\n        return canonicalize_name(self.name)\r\n\r\n    def copy(self):\r\n        return attr.evolve(self)\r\n\r\n    @classmethod\r\n    @lru_cache()\r\n    def from_line(cls, line):\r\n        # type: (AnyStr) -> Requirement\r\n        if isinstance(line, pip_shims.shims.InstallRequirement):\r\n            line = format_requirement(line)\r\n        parsed_line = Line(line)\r\n        r = (\r\n            None\r\n        )  # type: Optional[Union[VCSRequirement, FileRequirement, NamedRequirement]]\r\n        if (\r\n            (parsed_line.is_file and parsed_line.is_installable)\r\n            or parsed_line.is_remote_url\r\n        ) and not parsed_line.is_vcs:\r\n            r = file_req_from_parsed_line(parsed_line)\r\n        elif parsed_line.is_vcs:\r\n            r = vcs_req_from_parsed_line(parsed_line)\r\n        elif line == \".\" and not is_installable_file(line):\r\n            raise RequirementError(\r\n                \"Error parsing requirement %s -- are you sure it is installable?\" % line\r\n            )\r\n        else:\r\n            r = named_req_from_parsed_line(parsed_line)\r\n        req_markers = None\r\n        if parsed_line.markers:\r\n            req_markers = PackagingRequirement(\"fakepkg; {0}\".format(parsed_line.markers))\r\n        if r is not None and r.req is not None:\r\n            r.req.marker = getattr(req_markers, \"marker\", None) if req_markers else None\r\n        args = {}  # type: Dict[STRING_TYPE, CREATION_ARG_TYPES]\r\n        args = {\r\n            \"name\": r.name,\r\n            \"vcs\": parsed_line.vcs,\r\n            \"req\": r,\r\n            \"markers\": parsed_line.markers,\r\n            \"editable\": parsed_line.editable,\r\n            \"line_instance\": parsed_line,\r\n        }\r\n        if parsed_line.extras:\r\n            extras = ()  # type: Tuple[STRING_TYPE, ...]\r\n            extras = tuple(sorted(dedup([extra.lower() for extra in parsed_line.extras])))\r\n            args[\"extras\"] = extras\r\n            if r is not None:\r\n                r.extras = extras\r\n            elif r is not None and r.extras is not None:\r\n                args[\"extras\"] = tuple(\r\n                    sorted(dedup([extra.lower() for extra in r.extras]))\r\n                )  # type: ignore\r\n            if r.req is not None:\r\n                r.req.extras = args[\"extras\"]\r\n        if parsed_line.hashes:\r\n            args[\"hashes\"] = tuple(parsed_line.hashes)  # type: ignore\r\n        cls_inst = cls(**args)  # type: ignore\r\n        return cls_inst\r\n\r\n    @classmethod\r\n    def from_ireq(cls, ireq):\r\n        return cls.from_line(format_requirement(ireq))\r\n\r\n    @classmethod\r\n    def from_metadata(cls, name, version, extras, markers):\r\n        return cls.from_ireq(\r\n            make_install_requirement(name, version, extras=extras, markers=markers)\r\n        )\r\n\r\n    @classmethod\r\n    def from_pipfile(cls, name, pipfile):\r\n        from .markers import PipenvMarkers\r\n\r\n        _pipfile = {}\r\n        if hasattr(pipfile, \"keys\"):\r\n            _pipfile = dict(pipfile).copy()\r\n        _pipfile[\"version\"] = get_version(pipfile)\r\n        vcs = next(iter([vcs for vcs in VCS_LIST if vcs in _pipfile]), None)\r\n        if vcs:\r\n            _pipfile[\"vcs\"] = vcs\r\n            r = VCSRequirement.from_pipfile(name, pipfile)\r\n        elif any(key in _pipfile for key in [\"path\", \"file\", \"uri\"]):\r\n            r = FileRequirement.from_pipfile(name, pipfile)\r\n        else:\r\n            r = NamedRequirement.from_pipfile(name, pipfile)\r\n        markers = PipenvMarkers.from_pipfile(name, _pipfile)\r\n        req_markers = None\r\n        if markers:\r\n            markers = str(markers)\r\n            req_markers = PackagingRequirement(\"fakepkg; {0}\".format(markers))\r\n            if r.req is not None:\r\n                r.req.marker = req_markers.marker\r\n        extras = _pipfile.get(\"extras\")\r\n        if r.req:\r\n            if r.req.specifier:\r\n                r.req.specifier = SpecifierSet(_pipfile[\"version\"])\r\n            r.req.extras = (\r\n                tuple(sorted(dedup([extra.lower() for extra in extras])))\r\n                if extras\r\n                else ()\r\n            )\r\n        args = {\r\n            \"name\": r.name,\r\n            \"vcs\": vcs,\r\n            \"req\": r,\r\n            \"markers\": markers,\r\n            \"extras\": tuple(_pipfile.get(\"extras\", ())),\r\n            \"editable\": _pipfile.get(\"editable\", False),\r\n            \"index\": _pipfile.get(\"index\"),\r\n        }\r\n        if any(key in _pipfile for key in [\"hash\", \"hashes\"]):\r\n            args[\"hashes\"] = _pipfile.get(\"hashes\", [pipfile.get(\"hash\")])\r\n        cls_inst = cls(**args)\r\n        return cls_inst\r\n\r\n    def as_line(\r\n        self,\r\n        sources=None,\r\n        include_hashes=True,\r\n        include_extras=True,\r\n        include_markers=True,\r\n        as_list=False,\r\n    ):\r\n        \"\"\"Format this requirement as a line in requirements.txt.\r\n\r\n        If ``sources`` provided, it should be an sequence of mappings, containing\r\n        all possible sources to be used for this requirement.\r\n\r\n        If ``sources`` is omitted or falsy, no index information will be included\r\n        in the requirement line.\r\n        \"\"\"\r\n\r\n        assert self.line_instance is not None\r\n        parts = self.line_instance.get_line(\r\n            with_prefix=True,\r\n            with_hashes=include_hashes,\r\n            with_markers=include_markers,\r\n            as_list=as_list,\r\n        )\r\n        if sources and self.requirement and not (self.line_instance.is_local or self.vcs):\r\n            from ..utils import prepare_pip_source_args\r\n\r\n            if self.index:\r\n                sources = [s for s in sources if s.get(\"name\") == self.index]\r\n            source_list = prepare_pip_source_args(sources)\r\n            if as_list:\r\n                parts.extend(sources)\r\n            else:\r\n                index_string = \" \".join(source_list)\r\n                parts = \"{0} {1}\".format(parts, index_string)\r\n        return parts\r\n\r\n    def get_markers(self):\r\n        # type: () -> Marker\r\n        markers = self.markers\r\n        if markers:\r\n            fake_pkg = PackagingRequirement(\"fakepkg; {0}\".format(markers))\r\n            markers = fake_pkg.marker\r\n        return markers\r\n\r\n    def get_specifier(self):\r\n        # type: () -> Union[SpecifierSet, LegacySpecifier]\r\n        try:\r\n            return Specifier(self.specifiers)\r\n        except InvalidSpecifier:\r\n            return LegacySpecifier(self.specifiers)\r\n\r\n    def get_version(self):\r\n        return pip_shims.shims.parse_version(self.get_specifier().version)\r\n\r\n    def get_requirement(self):\r\n        req_line = self.req.req.line\r\n        if req_line.startswith(\"-e \"):\r\n            _, req_line = req_line.split(\" \", 1)\r\n        req = init_requirement(self.name)\r\n        req.line = req_line\r\n        req.specifier = SpecifierSet(self.specifiers if self.specifiers else \"\")\r\n        if self.is_vcs or self.is_file_or_url:\r\n            req.url = getattr(self.req.req, \"url\", self.req.link.url_without_fragment)\r\n        req.marker = self.get_markers()\r\n        req.extras = set(self.extras) if self.extras else set()\r\n        return req\r\n\r\n    @property\r\n    def constraint_line(self):\r\n        return self.as_line()\r\n\r\n    @property\r\n    def is_direct_url(self):\r\n        return (\r\n            self.is_file_or_url\r\n            and self.req.is_direct_url\r\n            or (self.line_instance.is_direct_url or self.req.parsed_line.is_direct_url)\r\n        )\r\n\r\n    def as_pipfile(self):\r\n        good_keys = (\r\n            \"hashes\",\r\n            \"extras\",\r\n            \"markers\",\r\n            \"editable\",\r\n            \"version\",\r\n            \"index\",\r\n        ) + VCS_LIST\r\n        req_dict = {\r\n            k: v\r\n            for k, v in attr.asdict(self, recurse=False, filter=filter_none).items()\r\n            if k in good_keys\r\n        }\r\n        name = self.name\r\n        if \"markers\" in req_dict and req_dict[\"markers\"]:\r\n            req_dict[\"markers\"] = req_dict[\"markers\"].replace('\"', \"'\")\r\n        if not self.req.name:\r\n            name_carriers = (self.req, self, self.line_instance, self.req.parsed_line)\r\n            name_options = [\r\n                getattr(carrier, \"name\", None)\r\n                for carrier in name_carriers\r\n                if carrier is not None\r\n            ]\r\n            req_name = next(iter(n for n in name_options if n is not None), None)\r\n            self.req.name = req_name\r\n        req_name, dict_from_subreq = self.req.pipfile_part.popitem()\r\n        base_dict = {\r\n            k: v\r\n            for k, v in dict_from_subreq.items()\r\n            if k not in [\"req\", \"link\", \"_setup_info\"]\r\n        }\r\n        base_dict.update(req_dict)\r\n        conflicting_keys = (\"file\", \"path\", \"uri\")\r\n        if \"file\" in base_dict and any(k in base_dict for k in conflicting_keys[1:]):\r\n            conflicts = [k for k in (conflicting_keys[1:],) if k in base_dict]\r\n            for k in conflicts:\r\n                base_dict.pop(k)\r\n        if \"hashes\" in base_dict:\r\n            _hashes = base_dict.pop(\"hashes\")\r\n            hashes = []\r\n            for _hash in _hashes:\r\n                try:\r\n                    hashes.append(_hash.as_line())\r\n                except AttributeError:\r\n                    hashes.append(_hash)\r\n            base_dict[\"hashes\"] = sorted(hashes)\r\n        if \"extras\" in base_dict:\r\n            base_dict[\"extras\"] = list(base_dict[\"extras\"])\r\n        if len(base_dict.keys()) == 1 and \"version\" in base_dict:\r\n            base_dict = base_dict.get(\"version\")\r\n        return {name: base_dict}\r\n\r\n    def as_ireq(self):\r\n        if self.line_instance and self.line_instance.ireq:\r\n            return self.line_instance.ireq\r\n        elif getattr(self.req, \"_parsed_line\", None) and self.req._parsed_line.ireq:\r\n            return self.req._parsed_line.ireq\r\n        kwargs = {\"include_hashes\": False}\r\n        if (self.is_file_or_url and self.req.is_local) or self.is_vcs:\r\n            kwargs[\"include_markers\"] = False\r\n        ireq_line = self.as_line(**kwargs)\r\n        ireq = Line(ireq_line).ireq\r\n        if not getattr(ireq, \"req\", None):\r\n            ireq.req = self.req.req\r\n            if (self.is_file_or_url and self.req.is_local) or self.is_vcs:\r\n                if getattr(ireq, \"req\", None) and getattr(ireq.req, \"marker\", None):\r\n                    ireq.req.marker = None\r\n        else:\r\n            ireq.req.extras = self.req.req.extras\r\n            if not ((self.is_file_or_url and self.req.is_local) or self.is_vcs):\r\n                ireq.req.marker = self.req.req.marker\r\n        return ireq\r\n\r\n    @property\r\n    def pipfile_entry(self):\r\n        return self.as_pipfile().copy().popitem()\r\n\r\n    @property\r\n    def ireq(self):\r\n        return self.as_ireq()\r\n\r\n    def get_dependencies(self, sources=None):\r\n        \"\"\"Retrieve the dependencies of the current requirement.\r\n\r\n        Retrieves dependencies of the current requirement.  This only works on pinned\r\n        requirements.\r\n\r\n        :param sources: Pipfile-formatted sources, defaults to None\r\n        :param sources: list[dict], optional\r\n        :return: A set of requirement strings of the dependencies of this requirement.\r\n        :rtype: set(str)\r\n        \"\"\"\r\n\r\n        from .dependencies import get_dependencies\r\n\r\n        if not sources:\r\n            sources = [\r\n                {\"name\": \"pypi\", \"url\": \"https://pypi.org/simple\", \"verify_ssl\": True}\r\n            ]\r\n        return get_dependencies(self.as_ireq(), sources=sources)\r\n\r\n    def get_abstract_dependencies(self, sources=None):\r\n        \"\"\"Retrieve the abstract dependencies of this requirement.\r\n\r\n        Returns the abstract dependencies of the current requirement in order to resolve.\r\n\r\n        :param sources: A list of sources (pipfile format), defaults to None\r\n        :param sources: list, optional\r\n        :return: A list of abstract (unpinned) dependencies\r\n        :rtype: list[ :class:`~requirementslib.models.dependency.AbstractDependency` ]\r\n        \"\"\"\r\n\r\n        from .dependencies import (\r\n            AbstractDependency,\r\n            get_dependencies,\r\n            get_abstract_dependencies,\r\n        )\r\n\r\n        if not self.abstract_dep:\r\n            parent = getattr(self, \"parent\", None)\r\n            self.abstract_dep = AbstractDependency.from_requirement(self, parent=parent)\r\n        if not sources:\r\n            sources = [\r\n                {\"url\": \"https://pypi.org/simple\", \"name\": \"pypi\", \"verify_ssl\": True}\r\n            ]\r\n        if is_pinned_requirement(self.ireq):\r\n            deps = self.get_dependencies()\r\n        else:\r\n            ireq = sorted(self.find_all_matches(), key=lambda k: k.version)\r\n            deps = get_dependencies(ireq.pop(), sources=sources)\r\n        return get_abstract_dependencies(deps, sources=sources, parent=self.abstract_dep)\r\n\r\n    def find_all_matches(self, sources=None, finder=None):\r\n        # type: (Optional[List[Dict[S, Union[S, bool]]]], Optional[PackageFinder]) -> List[InstallationCandidate]\r\n        \"\"\"Find all matching candidates for the current requirement.\r\n\r\n        Consults a finder to find all matching candidates.\r\n\r\n        :param sources: Pipfile-formatted sources, defaults to None\r\n        :param sources: list[dict], optional\r\n        :param PackageFinder finder: A **PackageFinder** instance from pip's repository implementation\r\n        :return: A list of Installation Candidates\r\n        :rtype: list[ :class:`~pip._internal.index.InstallationCandidate` ]\r\n        \"\"\"\r\n\r\n        from .dependencies import get_finder, find_all_matches\r\n\r\n        if not finder:\r\n            _, finder = get_finder(sources=sources)\r\n        return find_all_matches(finder, self.as_ireq())\r\n\r\n    def run_requires(self, sources=None, finder=None):\r\n        if self.req and self.req.setup_info is not None:\r\n            info_dict = self.req.setup_info.as_dict()\r\n        elif self.line_instance and self.line_instance.setup_info is not None:\r\n            info_dict = self.line_instance.setup_info.as_dict()\r\n        else:\r\n\r\n            if not finder:\r\n                from .dependencies import get_finder\r\n\r\n                finder = get_finder(sources=sources)\r\n            with pip_shims.shims.global_tempdir_manager():\r\n                info = SetupInfo.from_requirement(self, finder=finder)\r\n                if info is None:\r\n                    return {}\r\n                info_dict = info.get_info()\r\n            if self.req and not self.req.setup_info:\r\n                self.req._setup_info = info\r\n        if self.req._has_hashed_name and info_dict.get(\"name\"):\r\n            self.req.name = self.name = info_dict[\"name\"]\r\n            if self.req.req.name != info_dict[\"name\"]:\r\n                self.req.req.name = info_dict[\"name\"]\r\n        return info_dict\r\n\r\n    def merge_markers(self, markers):\r\n        # type: (Union[AnyStr, Marker]) -> None\r\n        if not markers:\r\n            return self\r\n        if not isinstance(markers, Marker):\r\n            markers = Marker(markers)\r\n        _markers = []  # type: List[Marker]\r\n        ireq = self.as_ireq()\r\n        if ireq and ireq.markers:\r\n            ireq_marker = ireq.markers\r\n            _markers.append(str(ireq_marker))\r\n        _markers.append(str(markers))\r\n        marker_str = \" and \".join([normalize_marker_str(m) for m in _markers if m])\r\n        new_marker = Marker(marker_str)\r\n        line = copy.deepcopy(self._line_instance)\r\n        line.markers = marker_str\r\n        line.parsed_marker = new_marker\r\n        if getattr(line, \"_requirement\", None) is not None:\r\n            line._requirement.marker = new_marker\r\n        if getattr(line, \"_ireq\", None) is not None and line._ireq.req:\r\n            line._ireq.req.marker = new_marker\r\n        new_ireq = getattr(self, \"ireq\", None)\r\n        if new_ireq and new_ireq.req:\r\n            new_ireq.req.marker = new_marker\r\n        req = self.req\r\n        if req.req:\r\n            req_requirement = req.req\r\n            req_requirement.marker = new_marker\r\n            req = attr.evolve(req, req=req_requirement, parsed_line=line)\r\n        return attr.evolve(\r\n            self, markers=str(new_marker), ireq=new_ireq, req=req, line_instance=line\r\n        )\r\n\r\n\r\ndef file_req_from_parsed_line(parsed_line):\r\n    # type: (Line) -> FileRequirement\r\n    path = parsed_line.relpath if parsed_line.relpath else parsed_line.path\r\n    pyproject_requires = None  # type: Optional[Tuple[STRING_TYPE, ...]]\r\n    if parsed_line.pyproject_requires is not None:\r\n        pyproject_requires = tuple(parsed_line.pyproject_requires)\r\n    pyproject_path = (\r\n        Path(parsed_line.pyproject_toml) if parsed_line.pyproject_toml else None\r\n    )\r\n    req_dict = {\r\n        \"setup_path\": parsed_line.setup_py,\r\n        \"path\": path,\r\n        \"editable\": parsed_line.editable,\r\n        \"extras\": parsed_line.extras,\r\n        \"uri_scheme\": parsed_line.preferred_scheme,\r\n        \"link\": parsed_line.link,\r\n        \"uri\": parsed_line.uri,\r\n        \"pyproject_requires\": pyproject_requires,\r\n        \"pyproject_backend\": parsed_line.pyproject_backend,\r\n        \"pyproject_path\": pyproject_path,\r\n        \"parsed_line\": parsed_line,\r\n        \"req\": parsed_line.requirement,\r\n    }\r\n    if parsed_line.name is not None:\r\n        req_dict[\"name\"] = parsed_line.name\r\n    return FileRequirement(**req_dict)  # type: ignore\r\n\r\n\r\ndef vcs_req_from_parsed_line(parsed_line):\r\n    # type: (Line) -> VCSRequirement\r\n    line = \"{0}\".format(parsed_line.line)\r\n    if parsed_line.editable:\r\n        line = \"-e {0}\".format(line)\r\n    if parsed_line.url is not None:\r\n        link = create_link(\r\n            build_vcs_uri(\r\n                vcs=parsed_line.vcs,\r\n                uri=parsed_line.url,\r\n                name=parsed_line.name,\r\n                ref=parsed_line.ref,\r\n                subdirectory=parsed_line.subdirectory,\r\n                extras=list(parsed_line.extras),\r\n            )\r\n        )\r\n    else:\r\n        link = parsed_line.link\r\n    pyproject_requires = ()  # type: Optional[Tuple[STRING_TYPE, ...]]\r\n    if parsed_line.pyproject_requires is not None:\r\n        pyproject_requires = tuple(parsed_line.pyproject_requires)\r\n    vcs_dict = {\r\n        \"setup_path\": parsed_line.setup_py,\r\n        \"path\": parsed_line.path,\r\n        \"editable\": parsed_line.editable,\r\n        \"vcs\": parsed_line.vcs,\r\n        \"ref\": parsed_line.ref,\r\n        \"subdirectory\": parsed_line.subdirectory,\r\n        \"extras\": parsed_line.extras,\r\n        \"uri_scheme\": parsed_line.preferred_scheme,\r\n        \"link\": link,\r\n        \"uri\": parsed_line.uri,\r\n        \"pyproject_requires\": pyproject_requires,\r\n        \"pyproject_backend\": parsed_line.pyproject_backend,\r\n        \"pyproject_path\": Path(parsed_line.pyproject_toml)\r\n        if parsed_line.pyproject_toml\r\n        else None,\r\n        \"parsed_line\": parsed_line,\r\n        \"req\": parsed_line.requirement,\r\n        \"base_line\": line,\r\n    }\r\n    if parsed_line.name:\r\n        vcs_dict[\"name\"] = parsed_line.name\r\n    return VCSRequirement(**vcs_dict)  # type: ignore\r\n\r\n\r\ndef named_req_from_parsed_line(parsed_line):\r\n    # type: (Line) -> NamedRequirement\r\n    if parsed_line.name is not None:\r\n        return NamedRequirement(\r\n            name=parsed_line.name,\r\n            version=parsed_line.specifier,\r\n            req=parsed_line.requirement,\r\n            extras=parsed_line.extras,\r\n            editable=parsed_line.editable,\r\n            parsed_line=parsed_line,\r\n        )\r\n    return NamedRequirement.from_line(parsed_line.line)\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    line = Line(\"vistir@ git+https://github.com/sarugaku/vistir.git@master\")\r\n    print(line)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- env/Lib/site-packages/pipenv/vendor/requirementslib/models/requirements.py	(revision 7de091c5b19e7b06e80c151f7100df6d0f893820)
+++ env/Lib/site-packages/pipenv/vendor/requirementslib/models/requirements.py	(date 1591098443924)
@@ -1013,7 +1013,7 @@
             parsed_setup_py = self.parsed_setup_py
             if parsed_setup_py:
                 name = parsed_setup_py.get("name", "")
-                if name:
+                if name and isinstance(name, six.string_types):
                     return name
         return None
 
Index: env/Lib/site-packages/pipenv/vendor/pythonfinder/utils.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># -*- coding=utf-8 -*-\r\nfrom __future__ import absolute_import, print_function\r\n\r\nimport io\r\nimport itertools\r\nimport os\r\nimport re\r\nimport subprocess\r\nfrom collections import OrderedDict\r\nfrom fnmatch import fnmatch\r\nfrom threading import Timer\r\n\r\nfrom pipenv.vendor import attr\r\nimport six\r\nfrom packaging.version import LegacyVersion, Version\r\n\r\nfrom .compat import Path, lru_cache, TimeoutError  # noqa\r\nfrom .environment import MYPY_RUNNING, PYENV_ROOT, SUBPROCESS_TIMEOUT\r\nfrom .exceptions import InvalidPythonVersion\r\n\r\nsix.add_move(\r\n    six.MovedAttribute(\"Iterable\", \"collections\", \"collections.abc\")\r\n)  # type: ignore  # noqa\r\nsix.add_move(\r\n    six.MovedAttribute(\"Sequence\", \"collections\", \"collections.abc\")\r\n)  # type: ignore  # noqa\r\n# fmt: off\r\nfrom six.moves import Iterable  # type: ignore  # noqa  # isort:skip\r\nfrom six.moves import Sequence  # type: ignore  # noqa  # isort:skip\r\n# fmt: on\r\n\r\nif MYPY_RUNNING:\r\n    from typing import Any, Union, List, Callable, Set, Tuple, Dict, Optional, Iterator\r\n    from attr.validators import _OptionalValidator  # type: ignore\r\n    from .models.path import PathEntry\r\n\r\n\r\nversion_re_str = (\r\n    r\"(?P<major>\\d+)(?:\\.(?P<minor>\\d+))?(?:\\.(?P<patch>(?<=\\.)[0-9]+))?\\.?\"\r\n    r\"(?:(?P<prerel>[abc]|rc|dev)(?:(?P<prerelversion>\\d+(?:\\.\\d+)*))?)\"\r\n    r\"?(?P<postdev>(\\.post(?P<post>\\d+))?(\\.dev(?P<dev>\\d+))?)?\"\r\n)\r\nversion_re = re.compile(version_re_str)\r\n\r\n\r\nPYTHON_IMPLEMENTATIONS = (\r\n    \"python\",\r\n    \"ironpython\",\r\n    \"jython\",\r\n    \"pypy\",\r\n    \"anaconda\",\r\n    \"miniconda\",\r\n    \"stackless\",\r\n    \"activepython\",\r\n    \"pyston\",\r\n    \"micropython\",\r\n)\r\nif os.name == \"nt\":\r\n    KNOWN_EXTS = {\"exe\", \"py\", \"bat\", \"\"}\r\nelse:\r\n    KNOWN_EXTS = {\"sh\", \"bash\", \"csh\", \"zsh\", \"fish\", \"py\", \"\"}\r\nKNOWN_EXTS = KNOWN_EXTS | set(\r\n    filter(None, os.environ.get(\"PATHEXT\", \"\").split(os.pathsep))\r\n)\r\nPY_MATCH_STR = r\"((?P<implementation>{0})(?:\\d?(?:\\.\\d[cpm]{{0,3}}))?(?:-?[\\d\\.]+)*[^zw])\".format(\r\n    \"|\".join(PYTHON_IMPLEMENTATIONS)\r\n)\r\nEXE_MATCH_STR = r\"{0}(?:\\.(?P<ext>{1}))?\".format(PY_MATCH_STR, \"|\".join(KNOWN_EXTS))\r\nRE_MATCHER = re.compile(r\"({0}|{1})\".format(version_re_str, PY_MATCH_STR))\r\nEXE_MATCHER = re.compile(EXE_MATCH_STR)\r\nRULES_BASE = [\r\n    \"*{0}\",\r\n    \"*{0}?\",\r\n    \"*{0}?.?\",\r\n    \"*{0}?.?m\",\r\n    \"{0}?-?.?\",\r\n    \"{0}?-?.?.?\",\r\n    \"{0}?.?-?.?.?\",\r\n]\r\nRULES = [rule.format(impl) for impl in PYTHON_IMPLEMENTATIONS for rule in RULES_BASE]\r\n\r\nMATCH_RULES = []\r\nfor rule in RULES:\r\n    MATCH_RULES.extend(\r\n        [\"{0}.{1}\".format(rule, ext) if ext else \"{0}\".format(rule) for ext in KNOWN_EXTS]\r\n    )\r\n\r\n\r\n@lru_cache(maxsize=1024)\r\ndef get_python_version(path):\r\n    # type: (str) -> str\r\n    \"\"\"Get python version string using subprocess from a given path.\"\"\"\r\n    version_cmd = [\r\n        path,\r\n        \"-c\",\r\n        \"import sys; print('.'.join([str(i) for i in sys.version_info[:3]]))\",\r\n    ]\r\n    subprocess_kwargs = {\r\n        \"env\": os.environ.copy(),\r\n        \"universal_newlines\": True,\r\n        \"stdout\": subprocess.PIPE,\r\n        \"stderr\": subprocess.PIPE,\r\n        \"shell\": False,\r\n    }\r\n    c = subprocess.Popen(version_cmd, **subprocess_kwargs)\r\n    timer = Timer(SUBPROCESS_TIMEOUT, c.kill)\r\n    try:\r\n        out, _ = c.communicate()\r\n    except (SystemExit, KeyboardInterrupt, TimeoutError):\r\n        c.terminate()\r\n        out, _ = c.communicate()\r\n        raise\r\n    except OSError:\r\n        raise InvalidPythonVersion(\"%s is not a valid python path\" % path)\r\n    if not out:\r\n        raise InvalidPythonVersion(\"%s is not a valid python path\" % path)\r\n    return out.strip()\r\n\r\n\r\n@lru_cache(maxsize=1024)\r\ndef parse_python_version(version_str):\r\n    # type: (str) -> Dict[str, Union[str, int, Version]]\r\n    from packaging.version import parse as parse_version\r\n\r\n    is_debug = False\r\n    if version_str.endswith(\"-debug\"):\r\n        is_debug = True\r\n        version_str, _, _ = version_str.rpartition(\"-\")\r\n    match = version_re.match(version_str)\r\n    if not match:\r\n        raise InvalidPythonVersion(\"%s is not a python version\" % version_str)\r\n    version_dict = match.groupdict()  # type: Dict[str, str]\r\n    major = int(version_dict.get(\"major\", 0)) if version_dict.get(\"major\") else None\r\n    minor = int(version_dict.get(\"minor\", 0)) if version_dict.get(\"minor\") else None\r\n    patch = int(version_dict.get(\"patch\", 0)) if version_dict.get(\"patch\") else None\r\n    is_postrelease = True if version_dict.get(\"post\") else False\r\n    is_prerelease = True if version_dict.get(\"prerel\") else False\r\n    is_devrelease = True if version_dict.get(\"dev\") else False\r\n    if patch:\r\n        patch = int(patch)\r\n    version = None  # type: Optional[Union[Version, LegacyVersion]]\r\n    try:\r\n        version = parse_version(version_str)\r\n    except TypeError:\r\n        version = None\r\n    if isinstance(version, LegacyVersion) or version is None:\r\n        v_dict = version_dict.copy()\r\n        pre = \"\"\r\n        if v_dict.get(\"prerel\") and v_dict.get(\"prerelversion\"):\r\n            pre = v_dict.pop(\"prerel\")\r\n            pre = \"{0}{1}\".format(pre, v_dict.pop(\"prerelversion\"))\r\n        v_dict[\"pre\"] = pre\r\n        keys = [\"major\", \"minor\", \"patch\", \"pre\", \"postdev\", \"post\", \"dev\"]\r\n        values = [v_dict.get(val) for val in keys]\r\n        version_str = \".\".join([str(v) for v in values if v])\r\n        version = parse_version(version_str)\r\n    return {\r\n        \"major\": major,\r\n        \"minor\": minor,\r\n        \"patch\": patch,\r\n        \"is_postrelease\": is_postrelease,\r\n        \"is_prerelease\": is_prerelease,\r\n        \"is_devrelease\": is_devrelease,\r\n        \"is_debug\": is_debug,\r\n        \"version\": version,\r\n    }\r\n\r\n\r\ndef optional_instance_of(cls):\r\n    # type: (Any) -> _OptionalValidator\r\n    \"\"\"\r\n    Return an validator to determine whether an input is an optional instance of a class.\r\n\r\n    :return: A validator to determine optional instance membership.\r\n    :rtype: :class:`~attr.validators._OptionalValidator`\r\n    \"\"\"\r\n\r\n    return attr.validators.optional(attr.validators.instance_of(cls))\r\n\r\n\r\ndef path_is_executable(path):\r\n    # type: (str) -> bool\r\n    \"\"\"\r\n    Determine whether the supplied path is executable.\r\n\r\n    :return: Whether the provided path is executable.\r\n    :rtype: bool\r\n    \"\"\"\r\n\r\n    return os.access(str(path), os.X_OK)\r\n\r\n\r\n@lru_cache(maxsize=1024)\r\ndef path_is_known_executable(path):\r\n    # type: (Path) -> bool\r\n    \"\"\"\r\n    Returns whether a given path is a known executable from known executable extensions\r\n    or has the executable bit toggled.\r\n\r\n    :param path: The path to the target executable.\r\n    :type path: :class:`~Path`\r\n    :return: True if the path has chmod +x, or is a readable, known executable extension.\r\n    :rtype: bool\r\n    \"\"\"\r\n\r\n    return (\r\n        path_is_executable(path)\r\n        or os.access(str(path), os.R_OK)\r\n        and path.suffix in KNOWN_EXTS\r\n    )\r\n\r\n\r\n@lru_cache(maxsize=1024)\r\ndef looks_like_python(name):\r\n    # type: (str) -> bool\r\n    \"\"\"\r\n    Determine whether the supplied filename looks like a possible name of python.\r\n\r\n    :param str name: The name of the provided file.\r\n    :return: Whether the provided name looks like python.\r\n    :rtype: bool\r\n    \"\"\"\r\n\r\n    if not any(name.lower().startswith(py_name) for py_name in PYTHON_IMPLEMENTATIONS):\r\n        return False\r\n    match = RE_MATCHER.match(name)\r\n    if match:\r\n        return any(fnmatch(name, rule) for rule in MATCH_RULES)\r\n    return False\r\n\r\n\r\n@lru_cache(maxsize=1024)\r\ndef path_is_python(path):\r\n    # type: (Path) -> bool\r\n    \"\"\"\r\n    Determine whether the supplied path is executable and looks like a possible path to python.\r\n\r\n    :param path: The path to an executable.\r\n    :type path: :class:`~Path`\r\n    :return: Whether the provided path is an executable path to python.\r\n    :rtype: bool\r\n    \"\"\"\r\n\r\n    return path_is_executable(path) and looks_like_python(path.name)\r\n\r\n\r\n@lru_cache(maxsize=1024)\r\ndef guess_company(path):\r\n    # type: (str) -> Optional[str]\r\n    \"\"\"Given a path to python, guess the company who created it\r\n\r\n    :param str path: The path to guess about\r\n    :return: The guessed company\r\n    :rtype: Optional[str]\r\n    \"\"\"\r\n    non_core_pythons = [impl for impl in PYTHON_IMPLEMENTATIONS if impl != \"python\"]\r\n    return next(\r\n        iter(impl for impl in non_core_pythons if impl in path.lower()), \"PythonCore\"\r\n    )\r\n\r\n\r\n@lru_cache(maxsize=1024)\r\ndef path_is_pythoncore(path):\r\n    # type: (str) -> bool\r\n    \"\"\"Given a path, determine whether it appears to be pythoncore.\r\n\r\n    Does not verify whether the path is in fact a path to python, but simply\r\n    does an exclusionary check on the possible known python implementations\r\n    to see if their names are present in the path (fairly dumb check).\r\n\r\n    :param str path: The path to check\r\n    :return: Whether that path is a PythonCore path or not\r\n    :rtype: bool\r\n    \"\"\"\r\n    company = guess_company(path)\r\n    if company:\r\n        return company == \"PythonCore\"\r\n    return False\r\n\r\n\r\n@lru_cache(maxsize=1024)\r\ndef ensure_path(path):\r\n    # type: (Union[Path, str]) -> Path\r\n    \"\"\"\r\n    Given a path (either a string or a Path object), expand variables and return a Path object.\r\n\r\n    :param path: A string or a :class:`~pathlib.Path` object.\r\n    :type path: str or :class:`~pathlib.Path`\r\n    :return: A fully expanded Path object.\r\n    :rtype: :class:`~pathlib.Path`\r\n    \"\"\"\r\n\r\n    if isinstance(path, Path):\r\n        return path\r\n    path = Path(os.path.expandvars(path))\r\n    return path.absolute()\r\n\r\n\r\ndef _filter_none(k, v):\r\n    # type: (Any, Any) -> bool\r\n    if v:\r\n        return True\r\n    return False\r\n\r\n\r\n# TODO: Reimplement in vistir\r\ndef normalize_path(path):\r\n    # type: (str) -> str\r\n    return os.path.normpath(\r\n        os.path.normcase(\r\n            os.path.abspath(os.path.expandvars(os.path.expanduser(str(path))))\r\n        )\r\n    )\r\n\r\n\r\n@lru_cache(maxsize=1024)\r\ndef filter_pythons(path):\r\n    # type: (Union[str, Path]) -> Iterable\r\n    \"\"\"Return all valid pythons in a given path\"\"\"\r\n    if not isinstance(path, Path):\r\n        path = Path(str(path))\r\n    if not path.is_dir():\r\n        return path if path_is_python(path) else None\r\n    return filter(path_is_python, path.iterdir())\r\n\r\n\r\n# TODO: Port to vistir\r\ndef unnest(item):\r\n    # type: (Any) -> Iterable[Any]\r\n    target = None  # type: Optional[Iterable]\r\n    if isinstance(item, Iterable) and not isinstance(item, six.string_types):\r\n        item, target = itertools.tee(item, 2)\r\n    else:\r\n        target = item\r\n    if getattr(target, \"__iter__\", None):\r\n        for el in target:\r\n            if isinstance(el, Iterable) and not isinstance(el, six.string_types):\r\n                el, el_copy = itertools.tee(el, 2)\r\n                for sub in unnest(el_copy):\r\n                    yield sub\r\n            else:\r\n                yield el\r\n    else:\r\n        yield target\r\n\r\n\r\ndef parse_pyenv_version_order(filename=\"version\"):\r\n    # type: (str) -> List[str]\r\n    version_order_file = normalize_path(os.path.join(PYENV_ROOT, filename))\r\n    if os.path.exists(version_order_file) and os.path.isfile(version_order_file):\r\n        with io.open(version_order_file, encoding=\"utf-8\") as fh:\r\n            contents = fh.read()\r\n        version_order = [v for v in contents.splitlines()]\r\n        return version_order\r\n    return []\r\n\r\n\r\ndef parse_asdf_version_order(filename=\".tool-versions\"):\r\n    # type: (str) -> List[str]\r\n    version_order_file = normalize_path(os.path.join(\"~\", filename))\r\n    if os.path.exists(version_order_file) and os.path.isfile(version_order_file):\r\n        with io.open(version_order_file, encoding=\"utf-8\") as fh:\r\n            contents = fh.read()\r\n        python_section = next(\r\n            iter(line for line in contents.splitlines() if line.startswith(\"python\")),\r\n            None,\r\n        )\r\n        if python_section:\r\n            # python_key, _, versions\r\n            _, _, versions = python_section.partition(\" \")\r\n            if versions:\r\n                return versions.split()\r\n    return []\r\n\r\n\r\ndef split_version_and_name(\r\n    major=None,  # type: Optional[Union[str, int]]\r\n    minor=None,  # type: Optional[Union[str, int]]\r\n    patch=None,  # type: Optional[Union[str, int]]\r\n    name=None,  # type: Optional[str]\r\n):\r\n    # type: (...) -> Tuple[Optional[Union[str, int]], Optional[Union[str, int]], Optional[Union[str, int]], Optional[str]]  # noqa\r\n    if isinstance(major, six.string_types) and not minor and not patch:\r\n        # Only proceed if this is in the format \"x.y.z\" or similar\r\n        if major.isdigit() or (major.count(\".\") > 0 and major[0].isdigit()):\r\n            version = major.split(\".\", 2)\r\n            if isinstance(version, (tuple, list)):\r\n                if len(version) > 3:\r\n                    major, minor, patch, _ = version\r\n                elif len(version) == 3:\r\n                    major, minor, patch = version\r\n                elif len(version) == 2:\r\n                    major, minor = version\r\n                else:\r\n                    major = major[0]\r\n            else:\r\n                major = major\r\n                name = None\r\n        else:\r\n            name = \"{0!s}\".format(major)\r\n            major = None\r\n    return (major, minor, patch, name)\r\n\r\n\r\n# TODO: Reimplement in vistir\r\ndef is_in_path(path, parent):\r\n    return normalize_path(str(path)).startswith(normalize_path(str(parent)))\r\n\r\n\r\ndef expand_paths(path, only_python=True):\r\n    # type: (Union[Sequence, PathEntry], bool) -> Iterator\r\n    \"\"\"\r\n    Recursively expand a list or :class:`~pythonfinder.models.path.PathEntry` instance\r\n\r\n    :param Union[Sequence, PathEntry] path: The path or list of paths to expand\r\n    :param bool only_python: Whether to filter to include only python paths, default True\r\n    :returns: An iterator over the expanded set of path entries\r\n    :rtype: Iterator[PathEntry]\r\n    \"\"\"\r\n\r\n    if path is not None and (\r\n        isinstance(path, Sequence)\r\n        and not getattr(path.__class__, \"__name__\", \"\") == \"PathEntry\"\r\n    ):\r\n        for p in unnest(path):\r\n            if p is None:\r\n                continue\r\n            for expanded in itertools.chain.from_iterable(\r\n                expand_paths(p, only_python=only_python)\r\n            ):\r\n                yield expanded\r\n    elif path is not None and path.is_dir:\r\n        for p in path.children.values():\r\n            if p is not None and p.is_python and p.as_python is not None:\r\n                for sub_path in itertools.chain.from_iterable(\r\n                    expand_paths(p, only_python=only_python)\r\n                ):\r\n                    yield sub_path\r\n    else:\r\n        if path is not None and path.is_python and path.as_python is not None:\r\n            yield path\r\n\r\n\r\ndef dedup(iterable):\r\n    # type: (Iterable) -> Iterable\r\n    \"\"\"Deduplicate an iterable object like iter(set(iterable)) but\r\n    order-reserved.\r\n    \"\"\"\r\n    return iter(OrderedDict.fromkeys(iterable))\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- env/Lib/site-packages/pipenv/vendor/pythonfinder/utils.py	(revision 7de091c5b19e7b06e80c151f7100df6d0f893820)
+++ env/Lib/site-packages/pipenv/vendor/pythonfinder/utils.py	(date 1591098443238)
@@ -422,7 +422,7 @@
         isinstance(path, Sequence)
         and not getattr(path.__class__, "__name__", "") == "PathEntry"
     ):
-        for p in unnest(path):
+        for p in path:
             if p is None:
                 continue
             for expanded in itertools.chain.from_iterable(
@@ -437,7 +437,9 @@
                 ):
                     yield sub_path
     else:
-        if path is not None and path.is_python and path.as_python is not None:
+        if path is not None and (
+            not only_python or (path.is_python and path.as_python is not None)
+        ):
             yield path
 
 
Index: env/Lib/site-packages/pipenv/cli/options.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># -*- coding=utf-8 -*-\r\nfrom __future__ import absolute_import\r\n\r\nimport os\r\n\r\nimport click.types\r\n\r\nfrom click import (\r\n    BadParameter, BadArgumentUsage, Group, Option, argument, echo, make_pass_decorator, option\r\n)\r\nfrom click_didyoumean import DYMMixin\r\n\r\nfrom .. import environments\r\nfrom ..utils import is_valid_url\r\n\r\n\r\nCONTEXT_SETTINGS = {\r\n    \"help_option_names\": [\"-h\", \"--help\"],\r\n    \"auto_envvar_prefix\": \"PIPENV\"\r\n}\r\n\r\n\r\nclass PipenvGroup(DYMMixin, Group):\r\n    \"\"\"Custom Group class provides formatted main help\"\"\"\r\n\r\n    def get_help_option(self, ctx):\r\n        from ..core import format_help\r\n\r\n        \"\"\"Override for showing formatted main help via --help and -h options\"\"\"\r\n        help_options = self.get_help_option_names(ctx)\r\n        if not help_options or not self.add_help_option:\r\n            return\r\n\r\n        def show_help(ctx, param, value):\r\n            if value and not ctx.resilient_parsing:\r\n                if not ctx.invoked_subcommand:\r\n                    # legit main help\r\n                    echo(format_help(ctx.get_help()))\r\n                else:\r\n                    # legit sub-command help\r\n                    echo(ctx.get_help(), color=ctx.color)\r\n                ctx.exit()\r\n\r\n        return Option(\r\n            help_options,\r\n            is_flag=True,\r\n            is_eager=True,\r\n            expose_value=False,\r\n            callback=show_help,\r\n            help=\"Show this message and exit.\",\r\n        )\r\n\r\n\r\nclass State(object):\r\n    def __init__(self):\r\n        self.index = None\r\n        self.extra_index_urls = []\r\n        self.verbose = False\r\n        self.quiet = False\r\n        self.pypi_mirror = None\r\n        self.python = None\r\n        self.two = None\r\n        self.three = None\r\n        self.site_packages = None\r\n        self.clear = False\r\n        self.system = False\r\n        self.installstate = InstallState()\r\n        self.lockoptions = LockOptions()\r\n\r\n\r\nclass InstallState(object):\r\n    def __init__(self):\r\n        self.dev = False\r\n        self.pre = False\r\n        self.selective_upgrade = False\r\n        self.keep_outdated = False\r\n        self.skip_lock = False\r\n        self.ignore_pipfile = False\r\n        self.sequential = False\r\n        self.code = False\r\n        self.requirementstxt = None\r\n        self.deploy = False\r\n        self.packages = []\r\n        self.editables = []\r\n\r\nclass LockOptions(object):\r\n    def __init__(self):\r\n        self.dev_only = False\r\n        self.emit_requirements = False\r\n        self.emit_requirements_header = False\r\n\r\npass_state = make_pass_decorator(State, ensure=True)\r\n\r\n\r\ndef index_option(f):\r\n    def callback(ctx, param, value):\r\n        state = ctx.ensure_object(State)\r\n        state.index = value\r\n        return value\r\n    return option('-i', '--index', expose_value=False, envvar=\"PIP_INDEX_URL\",\r\n                  help='Target PyPI-compatible package index url.', nargs=1,\r\n                  callback=callback)(f)\r\n\r\n\r\ndef extra_index_option(f):\r\n    def callback(ctx, param, value):\r\n        state = ctx.ensure_object(State)\r\n        state.extra_index_urls.extend(list(value))\r\n        return value\r\n    return option(\"--extra-index-url\", multiple=True, expose_value=False,\r\n                  help=u\"URLs to the extra PyPI compatible indexes to query for package look-ups.\",\r\n                  callback=callback, envvar=\"PIP_EXTRA_INDEX_URL\")(f)\r\n\r\n\r\ndef editable_option(f):\r\n    def callback(ctx, param, value):\r\n        state = ctx.ensure_object(State)\r\n        state.installstate.editables.extend(value)\r\n        return value\r\n    return option('-e', '--editable', expose_value=False, multiple=True,\r\n                  callback=callback, type=click.types.STRING, help=(\r\n                      \"An editable Python package URL or path, often to a VCS \"\r\n                      \"repository.\"\r\n                  ))(f)\r\n\r\n\r\ndef sequential_option(f):\r\n    def callback(ctx, param, value):\r\n        state = ctx.ensure_object(State)\r\n        state.installstate.sequential = value\r\n        return value\r\n    return option(\"--sequential\", is_flag=True, default=False, expose_value=False,\r\n                  help=\"Install dependencies one-at-a-time, instead of concurrently.\",\r\n                  callback=callback, type=click.types.BOOL, show_envvar=True)(f)\r\n\r\n\r\ndef skip_lock_option(f):\r\n    def callback(ctx, param, value):\r\n        state = ctx.ensure_object(State)\r\n        state.installstate.skip_lock = value\r\n        return value\r\n    return option(\"--skip-lock\", is_flag=True, default=False, expose_value=False,\r\n                  help=u\"Skip locking mechanisms and use the Pipfile instead during operation.\",\r\n                  envvar=\"PIPENV_SKIP_LOCK\", callback=callback, type=click.types.BOOL,\r\n                  show_envvar=True)(f)\r\n\r\n\r\ndef keep_outdated_option(f):\r\n    def callback(ctx, param, value):\r\n        state = ctx.ensure_object(State)\r\n        state.installstate.keep_outdated = value\r\n        return value\r\n    return option(\"--keep-outdated\", is_flag=True, default=False, expose_value=False,\r\n                  help=u\"Keep out-dated dependencies from being updated in Pipfile.lock.\",\r\n                  callback=callback, type=click.types.BOOL, show_envvar=True)(f)\r\n\r\n\r\ndef selective_upgrade_option(f):\r\n    def callback(ctx, param, value):\r\n        state = ctx.ensure_object(State)\r\n        state.installstate.selective_upgrade = value\r\n        return value\r\n    return option(\"--selective-upgrade\", is_flag=True, default=False, type=click.types.BOOL,\r\n                  help=\"Update specified packages.\", callback=callback,\r\n                  expose_value=False)(f)\r\n\r\n\r\ndef ignore_pipfile_option(f):\r\n    def callback(ctx, param, value):\r\n        state = ctx.ensure_object(State)\r\n        state.installstate.ignore_pipfile = value\r\n        return value\r\n    return option(\"--ignore-pipfile\", is_flag=True, default=False, expose_value=False,\r\n                  help=\"Ignore Pipfile when installing, using the Pipfile.lock.\",\r\n                  callback=callback, type=click.types.BOOL, show_envvar=True)(f)\r\n\r\n\r\ndef _dev_option(f, help_text):\r\n    def callback(ctx, param, value):\r\n        state = ctx.ensure_object(State)\r\n        state.installstate.dev = value\r\n        return value\r\n    return option(\"--dev\", \"-d\", is_flag=True, default=False, type=click.types.BOOL,\r\n                  help=help_text, callback=callback,\r\n                  expose_value=False, show_envvar=True)(f)\r\n\r\n\r\ndef install_dev_option(f):\r\n    return _dev_option(f, \"Install both develop and default packages\")\r\n\r\n\r\ndef lock_dev_option(f):\r\n    return _dev_option(f, \"Generate both develop and default requirements\")\r\n\r\n\r\ndef uninstall_dev_option(f):\r\n    return _dev_option(f, \"Deprecated (as it has no effect). May be removed in a future release.\")\r\n\r\n\r\ndef pre_option(f):\r\n    def callback(ctx, param, value):\r\n        state = ctx.ensure_object(State)\r\n        state.installstate.pre = value\r\n        return value\r\n    return option(\"--pre\", is_flag=True, default=False, help=u\"Allow pre-releases.\",\r\n                  callback=callback, type=click.types.BOOL, expose_value=False)(f)\r\n\r\n\r\ndef package_arg(f):\r\n    def callback(ctx, param, value):\r\n        state = ctx.ensure_object(State)\r\n        state.installstate.packages.extend(value)\r\n        return value\r\n    return argument('packages', nargs=-1, callback=callback, expose_value=False,\r\n                    type=click.types.STRING)(f)\r\n\r\n\r\ndef three_option(f):\r\n    def callback(ctx, param, value):\r\n        state = ctx.ensure_object(State)\r\n        if value is not None:\r\n            state.three = value\r\n            state.two = not value\r\n        return value\r\n    return option(\"--three/--two\", is_flag=True, default=None,\r\n                  help=\"Use Python 3/2 when creating virtualenv.\", callback=callback,\r\n                  expose_value=False)(f)\r\n\r\n\r\ndef python_option(f):\r\n    def callback(ctx, param, value):\r\n        state = ctx.ensure_object(State)\r\n        if value is not None:\r\n            state.python = validate_python_path(ctx, param, value)\r\n        return value\r\n    return option(\"--python\", default=False, nargs=1, callback=callback,\r\n                  help=\"Specify which version of Python virtualenv should use.\",\r\n                  expose_value=False, allow_from_autoenv=False)(f)\r\n\r\n\r\ndef pypi_mirror_option(f):\r\n    def callback(ctx, param, value):\r\n        state = ctx.ensure_object(State)\r\n        if value is not None:\r\n            state.pypi_mirror = validate_pypi_mirror(ctx, param, value)\r\n        return value\r\n    return option(\"--pypi-mirror\", default=environments.PIPENV_PYPI_MIRROR, nargs=1,\r\n                  callback=callback, help=\"Specify a PyPI mirror.\", expose_value=False)(f)\r\n\r\n\r\ndef verbose_option(f):\r\n    def callback(ctx, param, value):\r\n        state = ctx.ensure_object(State)\r\n        if value:\r\n            if state.quiet:\r\n                raise BadArgumentUsage(\r\n                    \"--verbose and --quiet are mutually exclusive! Please choose one!\",\r\n                    ctx=ctx\r\n                )\r\n            state.verbose = True\r\n            setup_verbosity(ctx, param, 1)\r\n    return option(\"--verbose\", \"-v\", is_flag=True, expose_value=False,\r\n                  callback=callback, help=\"Verbose mode.\", type=click.types.BOOL)(f)\r\n\r\n\r\ndef quiet_option(f):\r\n    def callback(ctx, param, value):\r\n        state = ctx.ensure_object(State)\r\n        if value:\r\n            if state.verbose:\r\n                raise BadArgumentUsage(\r\n                    \"--verbose and --quiet are mutually exclusive! Please choose one!\",\r\n                    ctx=ctx\r\n                )\r\n            state.quiet = True\r\n            setup_verbosity(ctx, param, -1)\r\n    return option(\"--quiet\", \"-q\", is_flag=True, expose_value=False,\r\n                  callback=callback, help=\"Quiet mode.\", type=click.types.BOOL)(f)\r\n\r\n\r\ndef site_packages_option(f):\r\n    def callback(ctx, param, value):\r\n        state = ctx.ensure_object(State)\r\n        validate_bool_or_none(ctx, param, value)\r\n        state.site_packages = value\r\n        return value\r\n    return option(\"--site-packages/--no-site-packages\", is_flag=True, default=None,\r\n                  help=\"Enable site-packages for the virtualenv.\", callback=callback,\r\n                  expose_value=False, show_envvar=True)(f)\r\n\r\n\r\ndef clear_option(f):\r\n    def callback(ctx, param, value):\r\n        state = ctx.ensure_object(State)\r\n        state.clear = value\r\n        return value\r\n    return option(\"--clear\", is_flag=True, callback=callback, type=click.types.BOOL,\r\n                  help=\"Clears caches (pipenv, pip, and pip-tools).\",\r\n                  expose_value=False, show_envvar=True)(f)\r\n\r\n\r\ndef system_option(f):\r\n    def callback(ctx, param, value):\r\n        state = ctx.ensure_object(State)\r\n        if value is not None:\r\n            state.system = value\r\n        return value\r\n    return option(\"--system\", is_flag=True, default=False, help=\"System pip management.\",\r\n                  callback=callback, type=click.types.BOOL, expose_value=False,\r\n                  show_envvar=True)(f)\r\n\r\n\r\ndef requirementstxt_option(f):\r\n    def callback(ctx, param, value):\r\n        state = ctx.ensure_object(State)\r\n        if value:\r\n            state.installstate.requirementstxt = value\r\n        return value\r\n    return option(\"--requirements\", \"-r\", nargs=1, default=False, expose_value=False,\r\n                  help=\"Import a requirements.txt file.\", callback=callback)(f)\r\n\r\n\r\ndef emit_requirements_flag(f):\r\n    def callback(ctx, param, value):\r\n        state = ctx.ensure_object(State)\r\n        if value:\r\n            state.lockoptions.emit_requirements = value\r\n        return value\r\n    return option(\"--requirements\", \"-r\", default=False, is_flag=True, expose_value=False,\r\n                  help=\"Generate output in requirements.txt format.\", callback=callback)(f)\r\n\r\ndef emit_requirements_header_flag(f):\r\n    def callback(ctx, param, value):\r\n        state = ctx.ensure_object(State)\r\n        if value:\r\n            state.lockoptions.emit_requirements_header = value\r\n        return value\r\n    return option(\"--header/--no-header\", default=True, is_flag=True, expose_value=False,\r\n                  help=\"Add header to generated requirements\", callback=callback)(f)\r\n\r\ndef dev_only_flag(f):\r\n    def callback(ctx, param, value):\r\n        state = ctx.ensure_object(State)\r\n        if value:\r\n            state.lockoptions.dev_only = value\r\n        return value\r\n    return option(\"--dev-only\", default=False, is_flag=True, expose_value=False,\r\n                  help=\"Emit development dependencies *only* (overrides --dev)\", callback=callback)(f)\r\n\r\ndef code_option(f):\r\n    def callback(ctx, param, value):\r\n        state = ctx.ensure_object(State)\r\n        if value:\r\n            state.installstate.code = value\r\n        return value\r\n    return option(\"--code\", \"-c\", nargs=1, default=False, help=\"Install packages \"\r\n                  \"automatically discovered from import statements.\", callback=callback,\r\n                  expose_value=False)(f)\r\n\r\n\r\ndef deploy_option(f):\r\n    def callback(ctx, param, value):\r\n        state = ctx.ensure_object(State)\r\n        state.installstate.deploy = value\r\n        return value\r\n    return option(\"--deploy\", is_flag=True, default=False, type=click.types.BOOL,\r\n                  help=u\"Abort if the Pipfile.lock is out-of-date, or Python version is\"\r\n                  \" wrong.\", callback=callback, expose_value=False)(f)\r\n\r\n\r\ndef setup_verbosity(ctx, param, value):\r\n    if not value:\r\n        return\r\n    import logging\r\n    loggers = (\"pip\", \"piptools\")\r\n    if value == 1:\r\n        for logger in loggers:\r\n            logging.getLogger(logger).setLevel(logging.INFO)\r\n    elif value == -1:\r\n        for logger in loggers:\r\n            logging.getLogger(logger).setLevel(logging.CRITICAL)\r\n    environments.PIPENV_VERBOSITY = value\r\n\r\n\r\ndef validate_python_path(ctx, param, value):\r\n    # Validating the Python path is complicated by accepting a number of\r\n    # friendly options: the default will be boolean False to enable\r\n    # autodetection but it may also be a value which will be searched in\r\n    # the path or an absolute path. To report errors as early as possible\r\n    # we'll report absolute paths which do not exist:\r\n    if isinstance(value, (str, bytes)):\r\n        if os.path.isabs(value) and not os.path.isfile(value):\r\n            raise BadParameter(\"Expected Python at path %s does not exist\" % value)\r\n    return value\r\n\r\n\r\ndef validate_bool_or_none(ctx, param, value):\r\n    if value is not None:\r\n        return click.types.BOOL(value)\r\n    return False\r\n\r\n\r\ndef validate_pypi_mirror(ctx, param, value):\r\n    if value and not is_valid_url(value):\r\n        raise BadParameter(\"Invalid PyPI mirror URL: %s\" % value)\r\n    return value\r\n\r\n\r\ndef common_options(f):\r\n    f = pypi_mirror_option(f)\r\n    f = verbose_option(f)\r\n    f = clear_option(f)\r\n    f = three_option(f)\r\n    f = python_option(f)\r\n    return f\r\n\r\n\r\ndef install_base_options(f):\r\n    f = common_options(f)\r\n    f = pre_option(f)\r\n    f = keep_outdated_option(f)\r\n    return f\r\n\r\n\r\ndef uninstall_options(f):\r\n    f = install_base_options(f)\r\n    f = uninstall_dev_option(f)\r\n    f = skip_lock_option(f)\r\n    f = editable_option(f)\r\n    f = package_arg(f)\r\n    return f\r\n\r\n\r\ndef lock_options(f):\r\n    f = install_base_options(f)\r\n    f = lock_dev_option(f)\r\n    f = emit_requirements_flag(f)\r\n    f = dev_only_flag(f)\r\n    return f\r\n\r\n\r\ndef sync_options(f):\r\n    f = install_base_options(f)\r\n    f = install_dev_option(f)\r\n    f = sequential_option(f)\r\n    return f\r\n\r\n\r\ndef install_options(f):\r\n    f = sync_options(f)\r\n    f = index_option(f)\r\n    f = extra_index_option(f)\r\n    f = requirementstxt_option(f)\r\n    f = selective_upgrade_option(f)\r\n    f = ignore_pipfile_option(f)\r\n    f = editable_option(f)\r\n    f = package_arg(f)\r\n    return f\r\n\r\n\r\ndef general_options(f):\r\n    f = common_options(f)\r\n    f = site_packages_option(f)\r\n    return f\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- env/Lib/site-packages/pipenv/cli/options.py	(revision 7de091c5b19e7b06e80c151f7100df6d0f893820)
+++ env/Lib/site-packages/pipenv/cli/options.py	(date 1591098437588)
@@ -83,12 +83,14 @@
         self.packages = []
         self.editables = []
 
+
 class LockOptions(object):
     def __init__(self):
         self.dev_only = False
         self.emit_requirements = False
         self.emit_requirements_header = False
 
+
 pass_state = make_pass_decorator(State, ensure=True)
 
 
@@ -329,6 +331,7 @@
     return option("--requirements", "-r", default=False, is_flag=True, expose_value=False,
                   help="Generate output in requirements.txt format.", callback=callback)(f)
 
+
 def emit_requirements_header_flag(f):
     def callback(ctx, param, value):
         state = ctx.ensure_object(State)
@@ -338,6 +341,7 @@
     return option("--header/--no-header", default=True, is_flag=True, expose_value=False,
                   help="Add header to generated requirements", callback=callback)(f)
 
+
 def dev_only_flag(f):
     def callback(ctx, param, value):
         state = ctx.ensure_object(State)
@@ -347,6 +351,7 @@
     return option("--dev-only", default=False, is_flag=True, expose_value=False,
                   help="Emit development dependencies *only* (overrides --dev)", callback=callback)(f)
 
+
 def code_option(f):
     def callback(ctx, param, value):
         state = ctx.ensure_object(State)
Index: env/Lib/site-packages/pipenv/environments.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># -*- coding=utf-8 -*-\r\n\r\nimport os\r\nimport sys\r\n\r\nfrom io import UnsupportedOperation\r\n\r\nfrom appdirs import user_cache_dir\r\n\r\nfrom ._compat import fix_utf8\r\nfrom .vendor.vistir.misc import _isatty, fs_str\r\n\r\n\r\n# HACK: avoid resolver.py uses the wrong byte code files.\r\n# I hope I can remove this one day.\r\nos.environ[\"PYTHONDONTWRITEBYTECODE\"] = fs_str(\"1\")\r\n_false_values = (\"0\", \"false\", \"no\", \"off\")\r\n_true_values = (\"1\", \"true\", \"yes\", \"on\")\r\n\r\n\r\ndef env_to_bool(val):\r\n    \"\"\"\r\n    Convert **val** to boolean, returning True if truthy or False if falsey\r\n\r\n    :param Any val: The value to convert\r\n    :return: False if Falsey, True if truthy\r\n    :rtype: bool\r\n    \"\"\"\r\n    if isinstance(val, bool):\r\n        return val\r\n    if val.lower() in _false_values:\r\n        return False\r\n    if val.lower() in _true_values:\r\n        return True\r\n    raise ValueError(\"Value is not a valid boolean-like: {0}\".format(val))\r\n\r\n\r\ndef _is_env_truthy(name):\r\n    \"\"\"An environment variable is truthy if it exists and isn't one of (0, false, no, off)\r\n    \"\"\"\r\n    if name not in os.environ:\r\n        return False\r\n    return os.environ.get(name).lower() not in _false_values\r\n\r\n\r\ndef get_from_env(arg, prefix=\"PIPENV\", check_for_negation=True):\r\n    \"\"\"\r\n    Check the environment for a variable, returning its truthy or stringified value\r\n\r\n    For example, setting ``PIPENV_NO_RESOLVE_VCS=1`` would mean that\r\n    ``get_from_env(\"RESOLVE_VCS\", prefix=\"PIPENV\")`` would return ``False``.\r\n\r\n    :param str arg: The name of the variable to look for\r\n    :param str prefix: The prefix to attach to the variable, defaults to \"PIPENV\"\r\n    :param bool check_for_negation: Whether to check for ``<PREFIX>_NO_<arg>``, defaults\r\n        to True\r\n    :return: The value from the environment if available\r\n    :rtype: Optional[Union[str, bool]]\r\n    \"\"\"\r\n    negative_lookup = \"NO_{0}\".format(arg)\r\n    positive_lookup = arg\r\n    if prefix:\r\n        positive_lookup = \"{0}_{1}\".format(prefix, arg)\r\n        negative_lookup = \"{0}_{1}\".format(prefix, negative_lookup)\r\n    if positive_lookup in os.environ:\r\n        value = os.environ[positive_lookup]\r\n        try:\r\n            return env_to_bool(value)\r\n        except ValueError:\r\n            return value\r\n    if check_for_negation and negative_lookup in os.environ:\r\n        value = os.environ[negative_lookup]\r\n        try:\r\n            return not env_to_bool(value)\r\n        except ValueError:\r\n            return value\r\n    return None\r\n\r\n\r\nPIPENV_IS_CI = bool(\"CI\" in os.environ or \"TF_BUILD\" in os.environ)\r\n\r\n# HACK: Prevent invalid shebangs with Homebrew-installed Python:\r\n# https://bugs.python.org/issue22490\r\nos.environ.pop(\"__PYVENV_LAUNCHER__\", None)\r\n\r\n# Load patched pip instead of system pip\r\nos.environ[\"PIP_SHIMS_BASE_MODULE\"] = fs_str(\"pipenv.patched.notpip\")\r\n\r\nPIPENV_CACHE_DIR = os.environ.get(\"PIPENV_CACHE_DIR\", user_cache_dir(\"pipenv\"))\r\n\"\"\"Location for Pipenv to store it's package cache.\r\n\r\nDefault is to use appdir's user cache directory.\r\n\"\"\"\r\n\r\nPIPENV_COLORBLIND = bool(os.environ.get(\"PIPENV_COLORBLIND\"))\r\n\"\"\"If set, disable terminal colors.\r\n\r\nSome people don't like colors in their terminals, for some reason. Default is\r\nto show colors.\r\n\"\"\"\r\n\r\n# Tells Pipenv which Python to default to, when none is provided.\r\nPIPENV_DEFAULT_PYTHON_VERSION = os.environ.get(\"PIPENV_DEFAULT_PYTHON_VERSION\")\r\n\"\"\"Use this Python version when creating new virtual environments by default.\r\n\r\nThis can be set to a version string, e.g. ``3.6``, or a path. Default is to use\r\nwhatever Python Pipenv is installed under (i.e. ``sys.executable``). Command\r\nline flags (e.g. ``--python``, ``--three``, and ``--two``) are prioritized over\r\nthis configuration.\r\n\"\"\"\r\n\r\nPIPENV_DONT_LOAD_ENV = bool(os.environ.get(\"PIPENV_DONT_LOAD_ENV\"))\r\n\"\"\"If set, Pipenv does not load the ``.env`` file.\r\n\r\nDefault is to load ``.env`` for ``run`` and ``shell`` commands.\r\n\"\"\"\r\n\r\nPIPENV_DONT_USE_PYENV = bool(os.environ.get(\"PIPENV_DONT_USE_PYENV\"))\r\n\"\"\"If set, Pipenv does not attempt to install Python with pyenv.\r\n\r\nDefault is to install Python automatically via pyenv when needed, if possible.\r\n\"\"\"\r\n\r\nPIPENV_DONT_USE_ASDF = bool(os.environ.get(\"PIPENV_DONT_USE_ASDF\"))\r\n\"\"\"If set, Pipenv does not attempt to install Python with asdf.\r\n\r\nDefault is to install Python automatically via asdf when needed, if possible.\r\n\"\"\"\r\n\r\nPIPENV_DOTENV_LOCATION = os.environ.get(\"PIPENV_DOTENV_LOCATION\")\r\n\"\"\"If set, Pipenv loads the ``.env`` file at the specified location.\r\n\r\nDefault is to load ``.env`` from the project root, if found.\r\n\"\"\"\r\n\r\nPIPENV_EMULATOR = os.environ.get(\"PIPENV_EMULATOR\", \"\")\r\n\"\"\"If set, the terminal emulator's name for ``pipenv shell`` to use.\r\n\r\nDefault is to detect emulators automatically. This should be set if your\r\nemulator, e.g. Cmder, cannot be detected correctly.\r\n\"\"\"\r\n\r\nPIPENV_HIDE_EMOJIS = (\r\n    os.environ.get(\"PIPENV_HIDE_EMOJIS\") is None\r\n    and (os.name == \"nt\" or PIPENV_IS_CI)\r\n    or _is_env_truthy(\"PIPENV_HIDE_EMOJIS\")\r\n)\r\n\"\"\"Disable emojis in output.\r\n\r\nDefault is to show emojis. This is automatically set on Windows.\r\n\"\"\"\r\n\r\nPIPENV_IGNORE_VIRTUALENVS = bool(os.environ.get(\"PIPENV_IGNORE_VIRTUALENVS\"))\r\n\"\"\"If set, Pipenv will always assign a virtual environment for this project.\r\n\r\nBy default, Pipenv tries to detect whether it is run inside a virtual\r\nenvironment, and reuses it if possible. This is usually the desired behavior,\r\nand enables the user to use any user-built environments with Pipenv.\r\n\"\"\"\r\n\r\nPIPENV_INSTALL_TIMEOUT = int(os.environ.get(\"PIPENV_INSTALL_TIMEOUT\", 60 * 15))\r\n\"\"\"Max number of seconds to wait for package installation.\r\n\r\nDefaults to 900 (15 minutes), a very long arbitrary time.\r\n\"\"\"\r\n\r\n# NOTE: +1 because of a temporary bug in Pipenv.\r\nPIPENV_MAX_DEPTH = int(os.environ.get(\"PIPENV_MAX_DEPTH\", \"3\")) + 1\r\n\"\"\"Maximum number of directories to recursively search for a Pipfile.\r\n\r\nDefault is 3. See also ``PIPENV_NO_INHERIT``.\r\n\"\"\"\r\n\r\nPIPENV_MAX_RETRIES = int(\r\n    os.environ.get(\"PIPENV_MAX_RETRIES\", \"1\" if PIPENV_IS_CI else \"0\")\r\n)\r\n\"\"\"Specify how many retries Pipenv should attempt for network requests.\r\n\r\nDefault is 0. Automatically set to 1 on CI environments for robust testing.\r\n\"\"\"\r\n\r\nPIPENV_MAX_ROUNDS = int(os.environ.get(\"PIPENV_MAX_ROUNDS\", \"16\"))\r\n\"\"\"Tells Pipenv how many rounds of resolving to do for Pip-Tools.\r\n\r\nDefault is 16, an arbitrary number that works most of the time.\r\n\"\"\"\r\n\r\nPIPENV_MAX_SUBPROCESS = int(os.environ.get(\"PIPENV_MAX_SUBPROCESS\", \"8\"))\r\n\"\"\"How many subprocesses should Pipenv use when installing.\r\n\r\nDefault is 16, an arbitrary number that seems to work.\r\n\"\"\"\r\n\r\nPIPENV_NO_INHERIT = \"PIPENV_NO_INHERIT\" in os.environ\r\n\"\"\"Tell Pipenv not to inherit parent directories.\r\n\r\nThis is useful for deployment to avoid using the wrong current directory.\r\nOverwrites ``PIPENV_MAX_DEPTH``.\r\n\"\"\"\r\nif PIPENV_NO_INHERIT:\r\n    PIPENV_MAX_DEPTH = 2\r\n\r\nPIPENV_NOSPIN = bool(os.environ.get(\"PIPENV_NOSPIN\"))\r\n\"\"\"If set, disable terminal spinner.\r\n\r\nThis can make the logs cleaner. Automatically set on Windows, and in CI\r\nenvironments.\r\n\"\"\"\r\nif PIPENV_IS_CI:\r\n    PIPENV_NOSPIN = True\r\n\r\nPIPENV_SPINNER = \"dots\" if not os.name == \"nt\" else \"bouncingBar\"\r\nPIPENV_SPINNER = os.environ.get(\"PIPENV_SPINNER\", PIPENV_SPINNER)\r\n\"\"\"Sets the default spinner type.\r\n\r\nSpinners are identical to the ``node.js`` spinners and can be found at\r\nhttps://github.com/sindresorhus/cli-spinners\r\n\"\"\"\r\n\r\nPIPENV_PIPFILE = os.environ.get(\"PIPENV_PIPFILE\")\r\n\"\"\"If set, this specifies a custom Pipfile location.\r\n\r\nWhen running pipenv from a location other than the same directory where the\r\nPipfile is located, instruct pipenv to find the Pipfile in the location\r\nspecified by this environment variable.\r\n\r\nDefault is to find Pipfile automatically in the current and parent directories.\r\nSee also ``PIPENV_MAX_DEPTH``.\r\n\"\"\"\r\n\r\nPIPENV_PYPI_MIRROR = os.environ.get(\"PIPENV_PYPI_MIRROR\")\r\n\"\"\"If set, tells pipenv to override PyPI index urls with a mirror.\r\n\r\nDefault is to not mirror PyPI, i.e. use the real one, pypi.org. The\r\n``--pypi-mirror`` command line flag overwrites this.\r\n\"\"\"\r\n\r\nPIPENV_QUIET = bool(os.environ.get(\"PIPENV_QUIET\"))\r\n\"\"\"If set, makes Pipenv quieter.\r\n\r\nDefault is unset, for normal verbosity. ``PIPENV_VERBOSE`` overrides this.\r\n\"\"\"\r\n\r\nPIPENV_SHELL = os.environ.get(\"PIPENV_SHELL\")\r\n\"\"\"An absolute path to the preferred shell for ``pipenv shell``.\r\n\r\nDefault is to detect automatically what shell is currently in use.\r\n\"\"\"\r\n# Hack because PIPENV_SHELL is actually something else. Internally this\r\n# variable is called PIPENV_SHELL_EXPLICIT instead.\r\nPIPENV_SHELL_EXPLICIT = PIPENV_SHELL\r\ndel PIPENV_SHELL\r\n\r\nPIPENV_SHELL_FANCY = bool(os.environ.get(\"PIPENV_SHELL_FANCY\"))\r\n\"\"\"If set, always use fancy mode when invoking ``pipenv shell``.\r\n\r\nDefault is to use the compatibility shell if possible.\r\n\"\"\"\r\n\r\nPIPENV_TIMEOUT = int(os.environ.get(\"PIPENV_TIMEOUT\", 120))\r\n\"\"\"Max number of seconds Pipenv will wait for virtualenv creation to complete.\r\n\r\nDefault is 120 seconds, an arbitrary number that seems to work.\r\n\"\"\"\r\n\r\nPIPENV_VENV_IN_PROJECT = bool(os.environ.get(\"PIPENV_VENV_IN_PROJECT\"))\r\n\"\"\"If set, creates ``.venv`` in your project directory.\r\n\r\nDefault is to create new virtual environments in a global location.\r\n\"\"\"\r\n\r\nPIPENV_VERBOSE = bool(os.environ.get(\"PIPENV_VERBOSE\"))\r\n\"\"\"If set, makes Pipenv more wordy.\r\n\r\nDefault is unset, for normal verbosity. This takes precedence over\r\n``PIPENV_QUIET``.\r\n\"\"\"\r\n\r\nPIPENV_YES = bool(os.environ.get(\"PIPENV_YES\"))\r\n\"\"\"If set, Pipenv automatically assumes \"yes\" at all prompts.\r\n\r\nDefault is to prompt the user for an answer if the current command line session\r\nif interactive.\r\n\"\"\"\r\n\r\nPIPENV_SKIP_LOCK = False\r\n\"\"\"If set, Pipenv won't lock dependencies automatically.\r\n\r\nThis might be desirable if a project has large number of dependencies,\r\nbecause locking is an inherently slow operation.\r\n\r\nDefault is to lock dependencies and update ``Pipfile.lock`` on each run.\r\n\r\nNOTE: This only affects the ``install`` and ``uninstall`` commands.\r\n\"\"\"\r\n\r\nPIP_EXISTS_ACTION = os.environ.get(\"PIP_EXISTS_ACTION\", \"w\")\r\n\"\"\"Specifies the value for pip's --exists-action option\r\n\r\nDefaults to ``(w)ipe``\r\n\"\"\"\r\n\r\nPIPENV_RESOLVE_VCS = (\r\n    os.environ.get(\"PIPENV_RESOLVE_VCS\") is None\r\n    or _is_env_truthy(\"PIPENV_RESOLVE_VCS\")\r\n)\r\n\r\n\"\"\"Tells Pipenv whether to resolve all VCS dependencies in full.\r\n\r\nAs of Pipenv 2018.11.26, only editable VCS dependencies were resolved in full.\r\nTo retain this behavior and avoid handling any conflicts that arise from the new\r\napproach, you may set this to '0', 'off', or 'false'.\r\n\"\"\"\r\n\r\nPIPENV_PYUP_API_KEY = os.environ.get(\r\n    \"PIPENV_PYUP_API_KEY\", None\r\n)\r\n\r\n# Internal, support running in a different Python from sys.executable.\r\nPIPENV_PYTHON = os.environ.get(\"PIPENV_PYTHON\")\r\n\r\n# Internal, overwrite all index funcitonality.\r\nPIPENV_TEST_INDEX = os.environ.get(\"PIPENV_TEST_INDEX\")\r\n\r\n# Internal, tells Pipenv about the surrounding environment.\r\nPIPENV_USE_SYSTEM = False\r\nPIPENV_VIRTUALENV = None\r\nif \"PIPENV_ACTIVE\" not in os.environ and not PIPENV_IGNORE_VIRTUALENVS:\r\n    PIPENV_VIRTUALENV = os.environ.get(\"VIRTUAL_ENV\")\r\n    PIPENV_USE_SYSTEM = bool(PIPENV_VIRTUALENV)\r\n\r\n# Internal, tells Pipenv to skip case-checking (slow internet connections).\r\n# This is currently always set to True for performance reasons.\r\nPIPENV_SKIP_VALIDATION = True\r\n\r\n# Internal, the default shell to use if shell detection fails.\r\nPIPENV_SHELL = (\r\n    os.environ.get(\"SHELL\")\r\n    or os.environ.get(\"PYENV_SHELL\")\r\n    or os.environ.get(\"COMSPEC\")\r\n)\r\n\r\n# Internal, to tell whether the command line session is interactive.\r\ntry:\r\n    SESSION_IS_INTERACTIVE = _isatty(sys.stdout.fileno())\r\nexcept UnsupportedOperation:\r\n    SESSION_IS_INTERACTIVE = _isatty(sys.stdout)\r\n\r\n\r\n# Internal, consolidated verbosity representation as an integer. The default\r\n# level is 0, increased for wordiness and decreased for terseness.\r\nPIPENV_VERBOSITY = os.environ.get(\"PIPENV_VERBOSITY\", \"\")\r\ntry:\r\n    PIPENV_VERBOSITY = int(PIPENV_VERBOSITY)\r\nexcept (ValueError, TypeError):\r\n    if PIPENV_VERBOSE:\r\n        PIPENV_VERBOSITY = 1\r\n    elif PIPENV_QUIET:\r\n        PIPENV_VERBOSITY = -1\r\n    else:\r\n        PIPENV_VERBOSITY = 0\r\ndel PIPENV_QUIET\r\ndel PIPENV_VERBOSE\r\n\r\n\r\ndef is_verbose(threshold=1):\r\n    return PIPENV_VERBOSITY >= threshold\r\n\r\n\r\ndef is_quiet(threshold=-1):\r\n    return PIPENV_VERBOSITY <= threshold\r\n\r\n\r\ndef is_in_virtualenv():\r\n    \"\"\"\r\n    Check virtualenv membership dynamically\r\n\r\n    :return: True or false depending on whether we are in a regular virtualenv or not\r\n    :rtype: bool\r\n    \"\"\"\r\n\r\n    pipenv_active = os.environ.get(\"PIPENV_ACTIVE\", False)\r\n    virtual_env = None\r\n    use_system = False\r\n    ignore_virtualenvs = bool(os.environ.get(\"PIPENV_IGNORE_VIRTUALENVS\", False))\r\n\r\n    if not pipenv_active and not ignore_virtualenvs:\r\n        virtual_env = os.environ.get(\"VIRTUAL_ENV\")\r\n        use_system = bool(virtual_env)\r\n    return (use_system or virtual_env) and not (pipenv_active or ignore_virtualenvs)\r\n\r\n\r\nPIPENV_SPINNER_FAIL_TEXT = fix_utf8(u\"✘ {0}\") if not PIPENV_HIDE_EMOJIS else (\"{0}\")\r\n\r\nPIPENV_SPINNER_OK_TEXT = fix_utf8(u\"✔ {0}\") if not PIPENV_HIDE_EMOJIS else (\"{0}\")\r\n\r\n\r\ndef is_type_checking():\r\n    try:\r\n        from typing import TYPE_CHECKING\r\n    except ImportError:\r\n        return False\r\n    return TYPE_CHECKING\r\n\r\n\r\nMYPY_RUNNING = is_type_checking()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- env/Lib/site-packages/pipenv/environments.py	(revision 7de091c5b19e7b06e80c151f7100df6d0f893820)
+++ env/Lib/site-packages/pipenv/environments.py	(date 1591098437573)
@@ -81,7 +81,7 @@
 
 # HACK: Prevent invalid shebangs with Homebrew-installed Python:
 # https://bugs.python.org/issue22490
-os.environ.pop("__PYVENV_LAUNCHER__", None)
+_OSX_VENV = os.environ.pop("__PYVENV_LAUNCHER__", None)
 
 # Load patched pip instead of system pip
 os.environ["PIP_SHIMS_BASE_MODULE"] = fs_str("pipenv.patched.notpip")
@@ -326,7 +326,7 @@
 PIPENV_USE_SYSTEM = False
 PIPENV_VIRTUALENV = None
 if "PIPENV_ACTIVE" not in os.environ and not PIPENV_IGNORE_VIRTUALENVS:
-    PIPENV_VIRTUALENV = os.environ.get("VIRTUAL_ENV")
+    PIPENV_VIRTUALENV = os.environ.get("VIRTUAL_ENV") or _OSX_VENV
     PIPENV_USE_SYSTEM = bool(PIPENV_VIRTUALENV)
 
 # Internal, tells Pipenv to skip case-checking (slow internet connections).
@@ -341,12 +341,8 @@
 )
 
 # Internal, to tell whether the command line session is interactive.
-try:
-    SESSION_IS_INTERACTIVE = _isatty(sys.stdout.fileno())
-except UnsupportedOperation:
-    SESSION_IS_INTERACTIVE = _isatty(sys.stdout)
+SESSION_IS_INTERACTIVE = _isatty(sys.stdout)
 
-
 # Internal, consolidated verbosity representation as an integer. The default
 # level is 0, increased for wordiness and decreased for terseness.
 PIPENV_VERBOSITY = os.environ.get("PIPENV_VERBOSITY", "")
@@ -371,6 +367,18 @@
     return PIPENV_VERBOSITY <= threshold
 
 
+def _is_using_venv():
+    # type: () -> bool
+    """Check for venv-based virtual environment which sets sys.base_prefix"""
+    return _OSX_VENV is not None or sys.prefix != getattr(sys, "base_prefix", sys.prefix)
+
+
+def _is_using_virtualenv():
+    # type: () -> bool
+    """Check for virtualenv-based environment which sets sys.real_prefix"""
+    return getattr(sys, "real_prefix", None) is not None
+
+
 def is_in_virtualenv():
     """
     Check virtualenv membership dynamically
@@ -385,7 +393,9 @@
     ignore_virtualenvs = bool(os.environ.get("PIPENV_IGNORE_VIRTUALENVS", False))
 
     if not pipenv_active and not ignore_virtualenvs:
-        virtual_env = os.environ.get("VIRTUAL_ENV")
+        virtual_env = any([
+            _is_using_virtualenv(), _is_using_venv(), os.environ.get("VIRTUAL_ENV")
+        ])
         use_system = bool(virtual_env)
     return (use_system or virtual_env) and not (pipenv_active or ignore_virtualenvs)
 
Index: env/Lib/site-packages/pipenv/cli/command.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># -*- coding: utf-8 -*-\r\nfrom __future__ import absolute_import\r\n\r\nimport os\r\nimport sys\r\n\r\nfrom click import (\r\n    argument, echo, edit, group, option, pass_context, secho, version_option, Choice\r\n)\r\n\r\nfrom ..__version__ import __version__\r\nfrom ..patched import crayons\r\nfrom ..vendor import click_completion, delegator\r\nfrom .options import (\r\n    CONTEXT_SETTINGS, PipenvGroup, code_option, common_options, deploy_option,\r\n    general_options, install_options, lock_options, pass_state,\r\n    pypi_mirror_option, python_option, site_packages_option, skip_lock_option,\r\n    sync_options, system_option, three_option, uninstall_options,\r\n    verbose_option\r\n)\r\n\r\n\r\n# Enable shell completion.\r\nclick_completion.init()\r\n\r\nsubcommand_context = CONTEXT_SETTINGS.copy()\r\nsubcommand_context.update({\r\n    \"ignore_unknown_options\": True,\r\n    \"allow_extra_args\": True\r\n})\r\nsubcommand_context_no_interspersion = subcommand_context.copy()\r\nsubcommand_context_no_interspersion[\"allow_interspersed_args\"] = False\r\n\r\n\r\n@group(cls=PipenvGroup, invoke_without_command=True, context_settings=CONTEXT_SETTINGS)\r\n@option(\"--where\", is_flag=True, default=False, help=\"Output project home information.\")\r\n@option(\"--venv\", is_flag=True, default=False, help=\"Output virtualenv information.\")\r\n@option(\"--py\", is_flag=True, default=False, help=\"Output Python interpreter information.\")\r\n@option(\"--envs\", is_flag=True, default=False, help=\"Output Environment Variable options.\")\r\n@option(\"--rm\", is_flag=True, default=False, help=\"Remove the virtualenv.\")\r\n@option(\"--bare\", is_flag=True, default=False, help=\"Minimal output.\")\r\n@option(\r\n    \"--completion\",\r\n    is_flag=True,\r\n    default=False,\r\n    help=\"Output completion (to be executed by the shell).\",\r\n)\r\n@option(\"--man\", is_flag=True, default=False, help=\"Display manpage.\")\r\n@option(\r\n    \"--support\",\r\n    is_flag=True,\r\n    help=\"Output diagnostic information for use in GitHub issues.\",\r\n)\r\n@general_options\r\n@version_option(prog_name=crayons.normal(\"pipenv\", bold=True), version=__version__)\r\n@pass_state\r\n@pass_context\r\ndef cli(\r\n    ctx,\r\n    state,\r\n    where=False,\r\n    venv=False,\r\n    py=False,\r\n    envs=False,\r\n    rm=False,\r\n    bare=False,\r\n    completion=False,\r\n    man=False,\r\n    support=None,\r\n    help=False,\r\n    site_packages=None,\r\n    **kwargs\r\n):\r\n    # Handle this ASAP to make shell startup fast.\r\n    if completion:\r\n        from .. import shells\r\n\r\n        try:\r\n            shell = shells.detect_info()[0]\r\n        except shells.ShellDetectionFailure:\r\n            echo(\r\n                \"Fail to detect shell. Please provide the {0} environment \"\r\n                \"variable.\".format(crayons.normal(\"PIPENV_SHELL\", bold=True)),\r\n                err=True,\r\n            )\r\n            ctx.abort()\r\n        print(click_completion.get_code(shell=shell, prog_name=\"pipenv\"))\r\n        return 0\r\n\r\n    from ..core import (\r\n        system_which,\r\n        do_py,\r\n        warn_in_virtualenv,\r\n        do_where,\r\n        project,\r\n        cleanup_virtualenv,\r\n        ensure_project,\r\n        format_help,\r\n        do_clear,\r\n    )\r\n    from ..utils import create_spinner\r\n\r\n    if man:\r\n        if system_which(\"man\"):\r\n            path = os.path.join(os.path.dirname(os.path.dirname(__file__)), \"pipenv.1\")\r\n            os.execle(system_which(\"man\"), \"man\", path, os.environ)\r\n            return 0\r\n        else:\r\n            secho(\"man does not appear to be available on your system.\", fg=\"yellow\", bold=True, err=True)\r\n            return 1\r\n    if envs:\r\n        echo(\"The following environment variables can be set, to do various things:\\n\")\r\n        from .. import environments\r\n        for key in environments.__dict__:\r\n            if key.startswith(\"PIPENV\"):\r\n                echo(\"  - {0}\".format(crayons.normal(key, bold=True)))\r\n        echo(\r\n            \"\\nYou can learn more at:\\n   {0}\".format(\r\n                crayons.green(\r\n                    \"https://pipenv.pypa.io/en/latest/advanced/#configuration-with-environment-variables\"\r\n                )\r\n            )\r\n        )\r\n        return 0\r\n    warn_in_virtualenv()\r\n    if ctx.invoked_subcommand is None:\r\n        # --where was passed…\r\n        if where:\r\n            do_where(bare=True)\r\n            return 0\r\n        elif py:\r\n            do_py()\r\n            return 0\r\n        # --support was passed…\r\n        elif support:\r\n            from ..help import get_pipenv_diagnostics\r\n\r\n            get_pipenv_diagnostics()\r\n            return 0\r\n        # --clear was passed…\r\n        elif state.clear:\r\n            do_clear()\r\n            return 0\r\n        # --venv was passed…\r\n        elif venv:\r\n            # There is no virtualenv yet.\r\n            if not project.virtualenv_exists:\r\n                echo(\r\n                    \"{}({}){}\".format(\r\n                        crayons.red(\"No virtualenv has been created for this project\"),\r\n                        crayons.white(project.project_directory, bold=True),\r\n                        crayons.red(\" yet!\")\r\n                    ),\r\n                    err=True,\r\n                )\r\n                ctx.abort()\r\n            else:\r\n                echo(project.virtualenv_location)\r\n                return 0\r\n        # --rm was passed…\r\n        elif rm:\r\n            # Abort if --system (or running in a virtualenv).\r\n            from ..environments import PIPENV_USE_SYSTEM\r\n            if PIPENV_USE_SYSTEM:\r\n                echo(\r\n                    crayons.red(\r\n                        \"You are attempting to remove a virtualenv that \"\r\n                        \"Pipenv did not create. Aborting.\"\r\n                    )\r\n                )\r\n                ctx.abort()\r\n            if project.virtualenv_exists:\r\n                loc = project.virtualenv_location\r\n                echo(\r\n                    crayons.normal(\r\n                        u\"{0} ({1})…\".format(\r\n                            crayons.normal(\"Removing virtualenv\", bold=True),\r\n                            crayons.green(loc),\r\n                        )\r\n                    )\r\n                )\r\n                with create_spinner(text=\"Running...\"):\r\n                    # Remove the virtualenv.\r\n                    cleanup_virtualenv(bare=True)\r\n                return 0\r\n            else:\r\n                echo(\r\n                    crayons.red(\r\n                        \"No virtualenv has been created for this project yet!\",\r\n                        bold=True,\r\n                    ),\r\n                    err=True,\r\n                )\r\n                ctx.abort()\r\n    # --two / --three was passed…\r\n    if (state.python or state.three is not None) or state.site_packages:\r\n        ensure_project(\r\n            three=state.three,\r\n            python=state.python,\r\n            warn=True,\r\n            site_packages=state.site_packages,\r\n            pypi_mirror=state.pypi_mirror,\r\n            clear=state.clear,\r\n        )\r\n    # Check this again before exiting for empty ``pipenv`` command.\r\n    elif ctx.invoked_subcommand is None:\r\n        # Display help to user, if no commands were passed.\r\n        echo(format_help(ctx.get_help()))\r\n\r\n\r\n@cli.command(\r\n    short_help=\"Installs provided packages and adds them to Pipfile, or (if no packages are given), installs all packages from Pipfile.\",\r\n    context_settings=subcommand_context,\r\n)\r\n@system_option\r\n@code_option\r\n@deploy_option\r\n@site_packages_option\r\n@skip_lock_option\r\n@install_options\r\n@pass_state\r\n@pass_context\r\ndef install(\r\n    ctx,\r\n    state,\r\n    **kwargs\r\n):\r\n    \"\"\"Installs provided packages and adds them to Pipfile, or (if no packages are given), installs all packages from Pipfile.\"\"\"\r\n    from ..core import do_install\r\n\r\n    retcode = do_install(\r\n        dev=state.installstate.dev,\r\n        three=state.three,\r\n        python=state.python,\r\n        pypi_mirror=state.pypi_mirror,\r\n        system=state.system,\r\n        lock=not state.installstate.skip_lock,\r\n        ignore_pipfile=state.installstate.ignore_pipfile,\r\n        skip_lock=state.installstate.skip_lock,\r\n        requirementstxt=state.installstate.requirementstxt,\r\n        sequential=state.installstate.sequential,\r\n        pre=state.installstate.pre,\r\n        code=state.installstate.code,\r\n        deploy=state.installstate.deploy,\r\n        keep_outdated=state.installstate.keep_outdated,\r\n        selective_upgrade=state.installstate.selective_upgrade,\r\n        index_url=state.index,\r\n        extra_index_url=state.extra_index_urls,\r\n        packages=state.installstate.packages,\r\n        editable_packages=state.installstate.editables,\r\n        site_packages=state.site_packages\r\n    )\r\n    if retcode:\r\n        ctx.abort()\r\n\r\n\r\n@cli.command(\r\n    short_help=\"Uninstalls a provided package and removes it from Pipfile.\",\r\n    context_settings=subcommand_context\r\n)\r\n@option(\r\n    \"--all-dev\",\r\n    is_flag=True,\r\n    default=False,\r\n    help=\"Uninstall all package from [dev-packages].\",\r\n)\r\n@option(\r\n    \"--all\",\r\n    is_flag=True,\r\n    default=False,\r\n    help=\"Purge all package(s) from virtualenv. Does not edit Pipfile.\",\r\n)\r\n@uninstall_options\r\n@pass_state\r\n@pass_context\r\ndef uninstall(\r\n    ctx,\r\n    state,\r\n    all_dev=False,\r\n    all=False,\r\n    **kwargs\r\n):\r\n    \"\"\"Uninstalls a provided package and removes it from Pipfile.\"\"\"\r\n    from ..core import do_uninstall\r\n    retcode = do_uninstall(\r\n        packages=state.installstate.packages,\r\n        editable_packages=state.installstate.editables,\r\n        three=state.three,\r\n        python=state.python,\r\n        system=state.system,\r\n        lock=not state.installstate.skip_lock,\r\n        all_dev=all_dev,\r\n        all=all,\r\n        keep_outdated=state.installstate.keep_outdated,\r\n        pypi_mirror=state.pypi_mirror,\r\n        ctx=ctx\r\n    )\r\n    if retcode:\r\n        sys.exit(retcode)\r\n\r\nLOCK_HEADER = \"\"\"\\\r\n#\r\n# These requirements were autogenerated by pipenv\r\n# To regenerate from the project's Pipfile, run:\r\n#\r\n#    pipenv lock {options}\r\n#\r\n\"\"\"\r\n\r\nLOCK_DEV_NOTE=\"\"\"\\\r\n# Note: in pipenv 2020.x, \"--dev\" changed to emit both default and development\r\n# requirements. To emit only development requirements, pass \"--dev-only\".\r\n\"\"\"\r\n\r\n@cli.command(short_help=\"Generates Pipfile.lock.\", context_settings=CONTEXT_SETTINGS)\r\n@lock_options\r\n@pass_state\r\n@pass_context\r\ndef lock(\r\n    ctx,\r\n    state,\r\n    **kwargs\r\n):\r\n    \"\"\"Generates Pipfile.lock.\"\"\"\r\n    from ..core import ensure_project, do_init, do_lock\r\n    # Ensure that virtualenv is available.\r\n    # Note that we don't pass clear on to ensure_project as it is also\r\n    # handled in do_lock\r\n    ensure_project(\r\n        three=state.three, python=state.python, pypi_mirror=state.pypi_mirror,\r\n        warn=(not state.quiet), site_packages=state.site_packages,\r\n    )\r\n    emit_requirements = state.lockoptions.emit_requirements\r\n    dev = state.installstate.dev\r\n    dev_only = state.lockoptions.dev_only\r\n    pre = state.installstate.pre\r\n    if emit_requirements:\r\n        # Emit requirements file header (unless turned off with --no-header)\r\n        if state.lockoptions.emit_requirements_header:\r\n            header_options = [\"--requirements\"]\r\n            if dev_only:\r\n                header_options.append(\"--dev-only\")\r\n            elif dev:\r\n                header_options.append(\"--dev\")\r\n            click.echo(LOCK_HEADER.format(options=\" \".join(header_options)))\r\n            # TODO: Emit pip-compile style header\r\n            if dev and not dev_only:\r\n                click.echo(LOCK_DEV_NOTE)\r\n        # Setting \"emit_requirements=True\" means do_init() just emits the\r\n        # install requirements file to stdout, it doesn't install anything\r\n        do_init(\r\n            dev=dev,\r\n            dev_only=dev_only,\r\n            emit_requirements=emit_requirements,\r\n            pypi_mirror=state.pypi_mirror,\r\n            pre=state.installstate.pre,\r\n        )\r\n    elif state.lockoptions.dev_only:\r\n        raise exceptions.PipenvOptionsError(\r\n            \"--dev-only\",\r\n            \"--dev-only is only permitted in combination with --requirements. \"\r\n            \"Aborting.\"\r\n        )\r\n    do_lock(\r\n        ctx=ctx,\r\n        clear=state.clear,\r\n        pre=state.installstate.pre,\r\n        keep_outdated=state.installstate.keep_outdated,\r\n        pypi_mirror=state.pypi_mirror,\r\n        write=not state.quiet,\r\n    )\r\n\r\n\r\n@cli.command(\r\n    short_help=\"Spawns a shell within the virtualenv.\",\r\n    context_settings=subcommand_context,\r\n)\r\n@option(\r\n    \"--fancy\",\r\n    is_flag=True,\r\n    default=False,\r\n    help=\"Run in shell in fancy mode. Make sure the shell have no path manipulating\"\r\n         \" scripts. Run $pipenv shell for issues with compatibility mode.\",\r\n)\r\n@option(\r\n    \"--anyway\",\r\n    is_flag=True,\r\n    default=False,\r\n    help=\"Always spawn a sub-shell, even if one is already spawned.\",\r\n)\r\n@argument(\"shell_args\", nargs=-1)\r\n@pypi_mirror_option\r\n@three_option\r\n@python_option\r\n@pass_state\r\ndef shell(\r\n    state,\r\n    fancy=False,\r\n    shell_args=None,\r\n    anyway=False,\r\n):\r\n    \"\"\"Spawns a shell within the virtualenv.\"\"\"\r\n    from ..core import load_dot_env, do_shell\r\n\r\n    # Prevent user from activating nested environments.\r\n    if \"PIPENV_ACTIVE\" in os.environ:\r\n        # If PIPENV_ACTIVE is set, VIRTUAL_ENV should always be set too.\r\n        venv_name = os.environ.get(\"VIRTUAL_ENV\", \"UNKNOWN_VIRTUAL_ENVIRONMENT\")\r\n        if not anyway:\r\n            echo(\r\n                \"{0} {1} {2}\\nNo action taken to avoid nested environments.\".format(\r\n                    crayons.normal(\"Shell for\"),\r\n                    crayons.green(venv_name, bold=True),\r\n                    crayons.normal(\"already activated.\", bold=True),\r\n                ),\r\n                err=True,\r\n            )\r\n            sys.exit(1)\r\n    # Load .env file.\r\n    load_dot_env()\r\n    # Use fancy mode for Windows.\r\n    if os.name == \"nt\":\r\n        fancy = True\r\n    do_shell(\r\n        three=state.three,\r\n        python=state.python,\r\n        fancy=fancy,\r\n        shell_args=shell_args,\r\n        pypi_mirror=state.pypi_mirror,\r\n    )\r\n\r\n\r\n@cli.command(\r\n    short_help=\"Spawns a command installed into the virtualenv.\",\r\n    context_settings=subcommand_context_no_interspersion,\r\n)\r\n@common_options\r\n@argument(\"command\")\r\n@argument(\"args\", nargs=-1)\r\n@pass_state\r\ndef run(state, command, args):\r\n    \"\"\"Spawns a command installed into the virtualenv.\"\"\"\r\n    from ..core import do_run\r\n    do_run(\r\n        command=command, args=args, three=state.three, python=state.python, pypi_mirror=state.pypi_mirror\r\n    )\r\n\r\n\r\n@cli.command(\r\n    short_help=\"Checks for PyUp Safety security vulnerabilities and against\"\r\n               \" PEP 508 markers provided in Pipfile.\",\r\n    context_settings=subcommand_context\r\n)\r\n@option(\r\n    \"--unused\",\r\n    nargs=1,\r\n    default=False,\r\n    help=\"Given a code path, show potentially unused dependencies.\",\r\n)\r\n@option(\r\n    \"--db\",\r\n    nargs=1,\r\n    default=lambda: os.environ.get('PIPENV_SAFETY_DB', False),\r\n    help=\"Path to a local PyUp Safety vulnerabilities database.\"\r\n         \" Default: ENV PIPENV_SAFETY_DB or None.\",\r\n)\r\n@option(\r\n    \"--ignore\",\r\n    \"-i\",\r\n    multiple=True,\r\n    help=\"Ignore specified vulnerability during PyUp Safety checks.\",\r\n)\r\n@option(\r\n    \"--output\",\r\n    type=Choice([\"default\", \"json\", \"full-report\", \"bare\"]),\r\n    default=\"default\",\r\n    help=\"Translates to --json, --full-report or --bare from PyUp Safety check\",\r\n)\r\n@option(\r\n    \"--key\",\r\n    help=\"Safety API key from PyUp.io for scanning dependencies against a live\"\r\n         \" vulnerabilities database. Leave blank for scanning against a\"\r\n         \" database that only updates once a month.\",\r\n)\r\n@option(\r\n    \"--quiet\",\r\n    is_flag=True,\r\n    help=\"Quiet standard output, except vulnerability report.\"\r\n)\r\n@common_options\r\n@system_option\r\n@argument(\"args\", nargs=-1)\r\n@pass_state\r\ndef check(\r\n    state,\r\n    unused=False,\r\n    db=False,\r\n    style=False,\r\n    ignore=None,\r\n    output=\"default\",\r\n    key=None,\r\n    quiet=False,\r\n    args=None,\r\n    **kwargs\r\n):\r\n    \"\"\"Checks for PyUp Safety security vulnerabilities and against PEP 508 markers provided in Pipfile.\"\"\"\r\n    from ..core import do_check\r\n\r\n    do_check(\r\n        three=state.three,\r\n        python=state.python,\r\n        system=state.system,\r\n        unused=unused,\r\n        db=db,\r\n        ignore=ignore,\r\n        output=output,\r\n        key=key,\r\n        quiet=quiet,\r\n        args=args,\r\n        pypi_mirror=state.pypi_mirror,\r\n    )\r\n\r\n\r\n@cli.command(short_help=\"Runs lock, then sync.\", context_settings=CONTEXT_SETTINGS)\r\n@option(\"--bare\", is_flag=True, default=False, help=\"Minimal output.\")\r\n@option(\r\n    \"--outdated\", is_flag=True, default=False, help=u\"List out-of-date dependencies.\"\r\n)\r\n@option(\"--dry-run\", is_flag=True, default=None, help=u\"List out-of-date dependencies.\")\r\n@install_options\r\n@pass_state\r\n@pass_context\r\ndef update(\r\n    ctx,\r\n    state,\r\n    bare=False,\r\n    dry_run=None,\r\n    outdated=False,\r\n    **kwargs\r\n):\r\n    \"\"\"Runs lock, then sync.\"\"\"\r\n    from ..core import (\r\n        ensure_project,\r\n        do_outdated,\r\n        do_lock,\r\n        do_sync,\r\n        project,\r\n    )\r\n    ensure_project(\r\n        three=state.three, python=state.python, pypi_mirror=state.pypi_mirror,\r\n        warn=(not state.quiet), site_packages=state.site_packages, clear=state.clear\r\n    )\r\n    if not outdated:\r\n        outdated = bool(dry_run)\r\n    if outdated:\r\n        do_outdated(clear=state.clear, pre=state.installstate.pre, pypi_mirror=state.pypi_mirror)\r\n    packages = [p for p in state.installstate.packages if p]\r\n    editable = [p for p in state.installstate.editables if p]\r\n    if not packages:\r\n        echo(\r\n            \"{0} {1} {2} {3}{4}\".format(\r\n                crayons.white(\"Running\", bold=True),\r\n                crayons.red(\"$ pipenv lock\", bold=True),\r\n                crayons.white(\"then\", bold=True),\r\n                crayons.red(\"$ pipenv sync\", bold=True),\r\n                crayons.white(\".\", bold=True),\r\n            )\r\n        )\r\n    else:\r\n        for package in packages + editable:\r\n            if package not in project.all_packages:\r\n                echo(\r\n                    \"{0}: {1} was not found in your Pipfile! Aborting.\"\r\n                    \"\".format(\r\n                        crayons.red(\"Warning\", bold=True),\r\n                        crayons.green(package, bold=True),\r\n                    ),\r\n                    err=True,\r\n                )\r\n                ctx.abort()\r\n    do_lock(\r\n        ctx=ctx,\r\n        clear=state.clear,\r\n        pre=state.installstate.pre,\r\n        keep_outdated=state.installstate.keep_outdated,\r\n        pypi_mirror=state.pypi_mirror,\r\n        write=not state.quiet,\r\n    )\r\n    do_sync(\r\n        ctx=ctx,\r\n        dev=state.installstate.dev,\r\n        three=state.three,\r\n        python=state.python,\r\n        bare=bare,\r\n        dont_upgrade=not state.installstate.keep_outdated,\r\n        user=False,\r\n        clear=state.clear,\r\n        unused=False,\r\n        sequential=state.installstate.sequential,\r\n        pypi_mirror=state.pypi_mirror,\r\n    )\r\n\r\n\r\n@cli.command(\r\n    short_help=u\"Displays currently-installed dependency graph information.\",\r\n    context_settings=CONTEXT_SETTINGS\r\n)\r\n@option(\"--bare\", is_flag=True, default=False, help=\"Minimal output.\")\r\n@option(\"--json\", is_flag=True, default=False, help=\"Output JSON.\")\r\n@option(\"--json-tree\", is_flag=True, default=False, help=\"Output JSON in nested tree.\")\r\n@option(\"--reverse\", is_flag=True, default=False, help=\"Reversed dependency graph.\")\r\ndef graph(bare=False, json=False, json_tree=False, reverse=False):\r\n    \"\"\"Displays currently-installed dependency graph information.\"\"\"\r\n    from ..core import do_graph\r\n\r\n    do_graph(bare=bare, json=json, json_tree=json_tree, reverse=reverse)\r\n\r\n\r\n@cli.command(\r\n    short_help=\"View a given module in your editor.\", name=\"open\",\r\n    context_settings=CONTEXT_SETTINGS\r\n)\r\n@common_options\r\n@argument(\"module\", nargs=1)\r\n@pass_state\r\ndef run_open(state, module, *args, **kwargs):\r\n    \"\"\"View a given module in your editor.\r\n\r\n    This uses the EDITOR environment variable. You can temporarily override it,\r\n    for example:\r\n\r\n        EDITOR=atom pipenv open requests\r\n    \"\"\"\r\n    from ..core import which, ensure_project, inline_activate_virtual_environment\r\n\r\n    # Ensure that virtualenv is available.\r\n    ensure_project(\r\n        three=state.three, python=state.python,\r\n        validate=False, pypi_mirror=state.pypi_mirror,\r\n    )\r\n    c = delegator.run(\r\n        '{0} -c \"import {1}; print({1}.__file__);\"'.format(which(\"python\"), module)\r\n    )\r\n    try:\r\n        assert c.return_code == 0\r\n    except AssertionError:\r\n        echo(crayons.red(\"Module not found!\"))\r\n        sys.exit(1)\r\n    if \"__init__.py\" in c.out:\r\n        p = os.path.dirname(c.out.strip().rstrip(\"cdo\"))\r\n    else:\r\n        p = c.out.strip().rstrip(\"cdo\")\r\n    echo(crayons.normal(\"Opening {0!r} in your EDITOR.\".format(p), bold=True))\r\n    inline_activate_virtual_environment()\r\n    edit(filename=p)\r\n    return 0\r\n\r\n\r\n@cli.command(\r\n    short_help=\"Installs all packages specified in Pipfile.lock.\",\r\n    context_settings=CONTEXT_SETTINGS\r\n)\r\n@option(\"--bare\", is_flag=True, default=False, help=\"Minimal output.\")\r\n@sync_options\r\n@pass_state\r\n@pass_context\r\ndef sync(\r\n    ctx,\r\n    state,\r\n    bare=False,\r\n    user=False,\r\n    unused=False,\r\n    **kwargs\r\n):\r\n    \"\"\"Installs all packages specified in Pipfile.lock.\"\"\"\r\n    from ..core import do_sync\r\n\r\n    retcode = do_sync(\r\n        ctx=ctx,\r\n        dev=state.installstate.dev,\r\n        three=state.three,\r\n        python=state.python,\r\n        bare=bare,\r\n        dont_upgrade=(not state.installstate.keep_outdated),\r\n        user=user,\r\n        clear=state.clear,\r\n        unused=unused,\r\n        sequential=state.installstate.sequential,\r\n        pypi_mirror=state.pypi_mirror,\r\n    )\r\n    if retcode:\r\n        ctx.abort()\r\n\r\n\r\n@cli.command(\r\n    short_help=\"Uninstalls all packages not specified in Pipfile.lock.\",\r\n    context_settings=CONTEXT_SETTINGS\r\n)\r\n@option(\"--bare\", is_flag=True, default=False, help=\"Minimal output.\")\r\n@option(\"--dry-run\", is_flag=True, default=False, help=\"Just output unneeded packages.\")\r\n@verbose_option\r\n@three_option\r\n@python_option\r\n@pass_state\r\n@pass_context\r\ndef clean(ctx, state, dry_run=False, bare=False, user=False):\r\n    \"\"\"Uninstalls all packages not specified in Pipfile.lock.\"\"\"\r\n    from ..core import do_clean\r\n    do_clean(ctx=ctx, three=state.three, python=state.python, dry_run=dry_run,\r\n             system=state.system)\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    cli()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- env/Lib/site-packages/pipenv/cli/command.py	(revision 7de091c5b19e7b06e80c151f7100df6d0f893820)
+++ env/Lib/site-packages/pipenv/cli/command.py	(date 1591098437587)
@@ -9,6 +9,7 @@
 )
 
 from ..__version__ import __version__
+from ..exceptions import PipenvOptionsError
 from ..patched import crayons
 from ..vendor import click_completion, delegator
 from .options import (
@@ -298,6 +299,7 @@
     if retcode:
         sys.exit(retcode)
 
+
 LOCK_HEADER = """\
 #
 # These requirements were autogenerated by pipenv
@@ -307,11 +309,13 @@
 #
 """
 
-LOCK_DEV_NOTE="""\
+
+LOCK_DEV_NOTE = """\
 # Note: in pipenv 2020.x, "--dev" changed to emit both default and development
 # requirements. To emit only development requirements, pass "--dev-only".
 """
 
+
 @cli.command(short_help="Generates Pipfile.lock.", context_settings=CONTEXT_SETTINGS)
 @lock_options
 @pass_state
@@ -342,10 +346,10 @@
                 header_options.append("--dev-only")
             elif dev:
                 header_options.append("--dev")
-            click.echo(LOCK_HEADER.format(options=" ".join(header_options)))
+            echo(LOCK_HEADER.format(options=" ".join(header_options)))
             # TODO: Emit pip-compile style header
             if dev and not dev_only:
-                click.echo(LOCK_DEV_NOTE)
+                echo(LOCK_DEV_NOTE)
         # Setting "emit_requirements=True" means do_init() just emits the
         # install requirements file to stdout, it doesn't install anything
         do_init(
@@ -353,10 +357,10 @@
             dev_only=dev_only,
             emit_requirements=emit_requirements,
             pypi_mirror=state.pypi_mirror,
-            pre=state.installstate.pre,
+            pre=pre,
         )
     elif state.lockoptions.dev_only:
-        raise exceptions.PipenvOptionsError(
+        raise PipenvOptionsError(
             "--dev-only",
             "--dev-only is only permitted in combination with --requirements. "
             "Aborting."
@@ -364,7 +368,7 @@
     do_lock(
         ctx=ctx,
         clear=state.clear,
-        pre=state.installstate.pre,
+        pre=pre,
         keep_outdated=state.installstate.keep_outdated,
         pypi_mirror=state.pypi_mirror,
         write=not state.quiet,
Index: env/Lib/site-packages/pipenv/environment.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># -*- coding=utf-8 -*-\r\nfrom __future__ import absolute_import, print_function\r\n\r\nimport contextlib\r\nimport importlib\r\nimport io\r\nimport json\r\nimport operator\r\nimport os\r\nimport site\r\nimport sys\r\n\r\nfrom sysconfig import get_paths, get_python_version\r\n\r\nimport itertools\r\nimport pkg_resources\r\nimport six\r\n\r\nimport pipenv\r\n\r\nfrom .vendor.cached_property import cached_property\r\nfrom .vendor.packaging.utils import canonicalize_name\r\nfrom .vendor import vistir\r\n\r\nfrom .utils import normalize_path, make_posix\r\n\r\n\r\nBASE_WORKING_SET = pkg_resources.WorkingSet(sys.path)\r\n# TODO: Unittests for this class\r\n\r\n\r\nclass Environment(object):\r\n    def __init__(self, prefix=None, is_venv=False, base_working_set=None, pipfile=None,\r\n                 sources=None, project=None):\r\n        super(Environment, self).__init__()\r\n        self._modules = {'pkg_resources': pkg_resources, 'pipenv': pipenv}\r\n        self.base_working_set = base_working_set if base_working_set else BASE_WORKING_SET\r\n        prefix = normalize_path(prefix)\r\n        self.is_venv = is_venv or prefix != normalize_path(sys.prefix)\r\n        if not sources:\r\n            sources = []\r\n        self.project = project\r\n        if project and not sources:\r\n            sources = project.sources\r\n        self.sources = sources\r\n        if project and not pipfile:\r\n            pipfile = project.parsed_pipfile\r\n        self.pipfile = pipfile\r\n        self.extra_dists = []\r\n        prefix = prefix if prefix else sys.prefix\r\n        self.prefix = vistir.compat.Path(prefix)\r\n        self._base_paths = {}\r\n        if self.is_venv:\r\n            self._base_paths = self.get_paths()\r\n        self.sys_paths = get_paths()\r\n\r\n    def safe_import(self, name):\r\n        \"\"\"Helper utility for reimporting previously imported modules while inside the env\"\"\"\r\n        module = None\r\n        if name not in self._modules:\r\n            self._modules[name] = importlib.import_module(name)\r\n        module = self._modules[name]\r\n        if not module:\r\n            dist = next(iter(\r\n                dist for dist in self.base_working_set if dist.project_name == name\r\n            ), None)\r\n            if dist:\r\n                dist.activate()\r\n            module = importlib.import_module(name)\r\n        if name in sys.modules:\r\n            try:\r\n                six.moves.reload_module(module)\r\n                six.moves.reload_module(sys.modules[name])\r\n            except TypeError:\r\n                del sys.modules[name]\r\n                sys.modules[name] = self._modules[name]\r\n        return module\r\n\r\n    @classmethod\r\n    def resolve_dist(cls, dist, working_set):\r\n        \"\"\"Given a local distribution and a working set, returns all dependencies from the set.\r\n\r\n        :param dist: A single distribution to find the dependencies of\r\n        :type dist: :class:`pkg_resources.Distribution`\r\n        :param working_set: A working set to search for all packages\r\n        :type working_set: :class:`pkg_resources.WorkingSet`\r\n        :return: A set of distributions which the package depends on, including the package\r\n        :rtype: set(:class:`pkg_resources.Distribution`)\r\n        \"\"\"\r\n\r\n        deps = set()\r\n        deps.add(dist)\r\n        try:\r\n            reqs = dist.requires()\r\n        # KeyError = limited metadata can be found\r\n        except (KeyError, AttributeError, OSError, IOError):  # The METADATA file can't be found\r\n            return deps\r\n        for req in reqs:\r\n            dist = working_set.find(req)\r\n            deps |= cls.resolve_dist(dist, working_set)\r\n        return deps\r\n\r\n    def extend_dists(self, dist):\r\n        extras = self.resolve_dist(dist, self.base_working_set)\r\n        self.extra_dists.append(dist)\r\n        if extras:\r\n            self.extra_dists.extend(extras)\r\n\r\n    def add_dist(self, dist_name):\r\n        dist = pkg_resources.get_distribution(pkg_resources.Requirement(dist_name))\r\n        self.extend_dists(dist)\r\n\r\n    @cached_property\r\n    def python_version(self):\r\n        with self.activated():\r\n            sysconfig = self.safe_import(\"sysconfig\")\r\n            py_version = sysconfig.get_python_version()\r\n            return py_version\r\n\r\n    def find_libdir(self):\r\n        libdir = self.prefix / \"lib\"\r\n        return next(iter(list(libdir.iterdir())), None)\r\n\r\n    @property\r\n    def python_info(self):\r\n        include_dir = self.prefix / \"include\"\r\n        if not os.path.exists(include_dir):\r\n            include_dirs = self.get_include_path()\r\n            if include_dirs:\r\n                include_path = include_dirs.get(\"include\", include_dirs.get(\"platinclude\"))\r\n                if not include_path:\r\n                    return {}\r\n                include_dir = vistir.compat.Path(include_path)\r\n        python_path = next(iter(list(include_dir.iterdir())), None)\r\n        if python_path and python_path.name.startswith(\"python\"):\r\n            python_version = python_path.name.replace(\"python\", \"\")\r\n            py_version_short, abiflags = python_version[:3], python_version[3:]\r\n            return {\"py_version_short\": py_version_short, \"abiflags\": abiflags}\r\n        return {}\r\n\r\n    def _replace_parent_version(self, path, replace_version):\r\n        if not os.path.exists(path):\r\n            base, leaf = os.path.split(path)\r\n            base, parent = os.path.split(base)\r\n            leaf = os.path.join(parent, leaf).replace(\r\n                replace_version, self.python_info.get(\"py_version_short\", get_python_version())\r\n            )\r\n            return os.path.join(base, leaf)\r\n        return path\r\n\r\n    @cached_property\r\n    def base_paths(self):\r\n        \"\"\"\r\n        Returns the context appropriate paths for the environment.\r\n\r\n        :return: A dictionary of environment specific paths to be used for installation operations\r\n        :rtype: dict\r\n\r\n        .. note:: The implementation of this is borrowed from a combination of pip and\r\n           virtualenv and is likely to change at some point in the future.\r\n\r\n        >>> from pipenv.core import project\r\n        >>> from pipenv.environment import Environment\r\n        >>> env = Environment(prefix=project.virtualenv_location, is_venv=True, sources=project.sources)\r\n        >>> import pprint\r\n        >>> pprint.pprint(env.base_paths)\r\n        {'PATH': '/home/hawk/.virtualenvs/pipenv-MfOPs1lW/bin::/bin:/usr/bin',\r\n        'PYTHONPATH': '/home/hawk/.virtualenvs/pipenv-MfOPs1lW/lib/python3.7/site-packages',\r\n        'data': '/home/hawk/.virtualenvs/pipenv-MfOPs1lW',\r\n        'include': '/home/hawk/.pyenv/versions/3.7.1/include/python3.7m',\r\n        'libdir': '/home/hawk/.virtualenvs/pipenv-MfOPs1lW/lib/python3.7/site-packages',\r\n        'platinclude': '/home/hawk/.pyenv/versions/3.7.1/include/python3.7m',\r\n        'platlib': '/home/hawk/.virtualenvs/pipenv-MfOPs1lW/lib/python3.7/site-packages',\r\n        'platstdlib': '/home/hawk/.virtualenvs/pipenv-MfOPs1lW/lib/python3.7',\r\n        'prefix': '/home/hawk/.virtualenvs/pipenv-MfOPs1lW',\r\n        'purelib': '/home/hawk/.virtualenvs/pipenv-MfOPs1lW/lib/python3.7/site-packages',\r\n        'scripts': '/home/hawk/.virtualenvs/pipenv-MfOPs1lW/bin',\r\n        'stdlib': '/home/hawk/.pyenv/versions/3.7.1/lib/python3.7'}\r\n        \"\"\"\r\n\r\n        prefix = make_posix(self.prefix.as_posix())\r\n        paths = {}\r\n        if self._base_paths:\r\n            paths = self._base_paths.copy()\r\n        else:\r\n            try:\r\n                paths = self.get_paths()\r\n            except Exception:\r\n                install_scheme = 'nt' if (os.name == 'nt') else 'posix_prefix'\r\n                paths = get_paths(install_scheme, vars={\r\n                    'base': prefix,\r\n                    'platbase': prefix,\r\n                })\r\n                current_version = get_python_version()\r\n                try:\r\n                    for k in list(paths.keys()):\r\n                        if not os.path.exists(paths[k]):\r\n                            paths[k] = self._replace_parent_version(paths[k], current_version)\r\n                except OSError:\r\n                    # Sometimes virtualenvs are made using virtualenv interpreters and there is no\r\n                    # include directory, which will cause this approach to fail. This failsafe\r\n                    # will make sure we fall back to the shell execution to find the real include path\r\n                    paths = self.get_include_path()\r\n                    paths.update(self.get_lib_paths())\r\n                    paths[\"scripts\"] = self.script_basedir\r\n        if not paths:\r\n            install_scheme = 'nt' if (os.name == 'nt') else 'posix_prefix'\r\n            paths = get_paths(install_scheme, vars={\r\n                'base': prefix,\r\n                'platbase': prefix,\r\n            })\r\n        if not os.path.exists(paths[\"purelib\"]) and not os.path.exists(paths[\"platlib\"]):\r\n            lib_paths = self.get_lib_paths()\r\n            paths.update(lib_paths)\r\n        paths[\"PATH\"] = paths[\"scripts\"] + os.pathsep + os.defpath\r\n        if \"prefix\" not in paths:\r\n            paths[\"prefix\"] = prefix\r\n        purelib = paths[\"purelib\"] = make_posix(paths[\"purelib\"])\r\n        platlib = paths[\"platlib\"] = make_posix(paths[\"platlib\"])\r\n        if purelib == platlib:\r\n            lib_dirs = purelib\r\n        else:\r\n            lib_dirs = purelib + os.pathsep + platlib\r\n        paths[\"libdir\"] = purelib\r\n        paths['PYTHONPATH'] = os.pathsep.join([\"\", \".\", lib_dirs])\r\n        paths[\"libdirs\"] = lib_dirs\r\n        return paths\r\n\r\n    @cached_property\r\n    def script_basedir(self):\r\n        \"\"\"Path to the environment scripts dir\"\"\"\r\n        prefix = make_posix(self.prefix.as_posix())\r\n        install_scheme = 'nt' if (os.name == 'nt') else 'posix_prefix'\r\n        paths = get_paths(install_scheme, vars={\r\n            'base': prefix,\r\n            'platbase': prefix,\r\n        })\r\n        return paths[\"scripts\"]\r\n\r\n    @property\r\n    def python(self):\r\n        \"\"\"Path to the environment python\"\"\"\r\n        py = vistir.compat.Path(self.script_basedir).joinpath(\"python\").absolute().as_posix()\r\n        if not py:\r\n            return vistir.compat.Path(sys.executable).as_posix()\r\n        return py\r\n\r\n    @cached_property\r\n    def sys_path(self):\r\n        \"\"\"\r\n        The system path inside the environment\r\n\r\n        :return: The :data:`sys.path` from the environment\r\n        :rtype: list\r\n        \"\"\"\r\n\r\n        from .vendor.vistir.compat import JSONDecodeError\r\n        current_executable = vistir.compat.Path(sys.executable).as_posix()\r\n        if not self.python or self.python == current_executable:\r\n            return sys.path\r\n        elif any([sys.prefix == self.prefix, not self.is_venv]):\r\n            return sys.path\r\n        cmd_args = [self.python, \"-c\", \"import json, sys; print(json.dumps(sys.path))\"]\r\n        path, _ = vistir.misc.run(cmd_args, return_object=False, nospin=True, block=True, combine_stderr=False, write_to_stdout=False)\r\n        try:\r\n            path = json.loads(path.strip())\r\n        except JSONDecodeError:\r\n            path = sys.path\r\n        return path\r\n\r\n    def build_command(self, python_lib=False, python_inc=False, scripts=False, py_version=False):\r\n        \"\"\"Build the text for running a command in the given environment\r\n\r\n        :param python_lib: Whether to include the python lib dir commands, defaults to False\r\n        :type python_lib: bool, optional\r\n        :param python_inc: Whether to include the python include dir commands, defaults to False\r\n        :type python_inc: bool, optional\r\n        :param scripts: Whether to include the scripts directory, defaults to False\r\n        :type scripts: bool, optional\r\n        :param py_version: Whether to include the python version info, defaults to False\r\n        :type py_version: bool, optional\r\n        :return: A string representing the command to run\r\n        \"\"\"\r\n        pylib_lines = []\r\n        pyinc_lines = []\r\n        py_command = (\r\n            \"import sysconfig, distutils.sysconfig, io, json, sys; paths = {{\"\r\n            \"%s }}; value = u'{{0}}'.format(json.dumps(paths));\"\r\n            \"fh = io.open('{0}', 'w'); fh.write(value); fh.close()\"\r\n        )\r\n        distutils_line = \"distutils.sysconfig.get_python_{0}(plat_specific={1})\"\r\n        sysconfig_line = \"sysconfig.get_path('{0}')\"\r\n        if python_lib:\r\n            for key, var, val in ((\"pure\", \"lib\", \"0\"), (\"plat\", \"lib\", \"1\")):\r\n                dist_prefix = \"{0}lib\".format(key)\r\n                # XXX: We need to get 'stdlib' or 'platstdlib'\r\n                sys_prefix = \"{0}stdlib\".format(\"\" if key == \"pure\" else key)\r\n                pylib_lines.append(\"u'%s': u'{{0}}'.format(%s)\" % (dist_prefix, distutils_line.format(var, val)))\r\n                pylib_lines.append(\"u'%s': u'{{0}}'.format(%s)\" % (sys_prefix, sysconfig_line.format(sys_prefix)))\r\n        if python_inc:\r\n            for key, var, val in ((\"include\", \"inc\", \"0\"), (\"platinclude\", \"inc\", \"1\")):\r\n                pylib_lines.append(\"u'%s': u'{{0}}'.format(%s)\" % (key, distutils_line.format(var, val)))\r\n        lines = pylib_lines + pyinc_lines\r\n        if scripts:\r\n            lines.append(\"u'scripts': u'{{0}}'.format(%s)\" % sysconfig_line.format(\"scripts\"))\r\n        if py_version:\r\n            lines.append(\"u'py_version_short': u'{{0}}'.format(distutils.sysconfig.get_python_version()),\")\r\n        lines_as_str = u\",\".join(lines)\r\n        py_command = py_command % lines_as_str\r\n        return py_command\r\n\r\n    def get_paths(self):\r\n        \"\"\"\r\n        Get the paths for the environment by running a subcommand\r\n\r\n        :return: The python paths for the environment\r\n        :rtype: Dict[str, str]\r\n        \"\"\"\r\n        tmpfile = vistir.path.create_tracked_tempfile(suffix=\".json\")\r\n        tmpfile.close()\r\n        tmpfile_path = make_posix(tmpfile.name)\r\n        py_command = self.build_command(python_lib=True, python_inc=True, scripts=True, py_version=True)\r\n        command = [self.python, \"-c\", py_command.format(tmpfile_path)]\r\n        c = vistir.misc.run(\r\n            command, return_object=True, block=True, nospin=True, write_to_stdout=False\r\n        )\r\n        if c.returncode == 0:\r\n            paths = {}\r\n            with io.open(tmpfile_path, \"r\", encoding=\"utf-8\") as fh:\r\n                paths = json.load(fh)\r\n            if \"purelib\" in paths:\r\n                paths[\"libdir\"] = paths[\"purelib\"] = make_posix(paths[\"purelib\"])\r\n            for key in (\"platlib\", \"scripts\", \"platstdlib\", \"stdlib\", \"include\", \"platinclude\"):\r\n                if key in paths:\r\n                    paths[key] = make_posix(paths[key])\r\n            return paths\r\n        else:\r\n            vistir.misc.echo(\"Failed to load paths: {0}\".format(c.err), fg=\"yellow\")\r\n            vistir.misc.echo(\"Output: {0}\".format(c.out), fg=\"yellow\")\r\n        return None\r\n\r\n    def get_lib_paths(self):\r\n        \"\"\"Get the include path for the environment\r\n\r\n        :return: The python include path for the environment\r\n        :rtype: Dict[str, str]\r\n        \"\"\"\r\n        tmpfile = vistir.path.create_tracked_tempfile(suffix=\".json\")\r\n        tmpfile.close()\r\n        tmpfile_path = make_posix(tmpfile.name)\r\n        py_command = self.build_command(python_lib=True)\r\n        command = [self.python, \"-c\", py_command.format(tmpfile_path)]\r\n        c = vistir.misc.run(\r\n            command, return_object=True, block=True, nospin=True, write_to_stdout=False\r\n        )\r\n        paths = None\r\n        if c.returncode == 0:\r\n            paths = {}\r\n            with io.open(tmpfile_path, \"r\", encoding=\"utf-8\") as fh:\r\n                paths = json.load(fh)\r\n            if \"purelib\" in paths:\r\n                paths[\"libdir\"] = paths[\"purelib\"] = make_posix(paths[\"purelib\"])\r\n            for key in (\"platlib\", \"platstdlib\", \"stdlib\"):\r\n                if key in paths:\r\n                    paths[key] = make_posix(paths[key])\r\n            return paths\r\n        else:\r\n            vistir.misc.echo(\"Failed to load paths: {0}\".format(c.err), fg=\"yellow\")\r\n            vistir.misc.echo(\"Output: {0}\".format(c.out), fg=\"yellow\")\r\n        if not paths:\r\n            if not self.prefix.joinpath(\"lib\").exists():\r\n                return {}\r\n            stdlib_path = next(iter([\r\n                p for p in self.prefix.joinpath(\"lib\").iterdir()\r\n                if p.name.startswith(\"python\")\r\n            ]), None)\r\n            lib_path = None\r\n            if stdlib_path:\r\n                lib_path = next(iter([\r\n                    p.as_posix() for p in stdlib_path.iterdir()\r\n                    if p.name == \"site-packages\"\r\n                ]))\r\n                paths = {\"stdlib\": stdlib_path.as_posix()}\r\n                if lib_path:\r\n                    paths[\"purelib\"] = lib_path\r\n                return paths\r\n        return {}\r\n\r\n    def get_include_path(self):\r\n        \"\"\"Get the include path for the environment\r\n\r\n        :return: The python include path for the environment\r\n        :rtype: Dict[str, str]\r\n        \"\"\"\r\n        tmpfile = vistir.path.create_tracked_tempfile(suffix=\".json\")\r\n        tmpfile.close()\r\n        tmpfile_path = make_posix(tmpfile.name)\r\n        py_command = (\r\n            \"import distutils.sysconfig, io, json, sys; paths = {{u'include': \"\r\n            \"u'{{0}}'.format(distutils.sysconfig.get_python_inc(plat_specific=0)), \"\r\n            \"u'platinclude': u'{{0}}'.format(distutils.sysconfig.get_python_inc(\"\r\n            \"plat_specific=1)) }}; value = u'{{0}}'.format(json.dumps(paths));\"\r\n            \"fh = io.open('{0}', 'w'); fh.write(value); fh.close()\"\r\n        )\r\n        command = [self.python, \"-c\", py_command.format(tmpfile_path)]\r\n        c = vistir.misc.run(\r\n            command, return_object=True, block=True, nospin=True, write_to_stdout=False\r\n        )\r\n        if c.returncode == 0:\r\n            paths = []\r\n            with io.open(tmpfile_path, \"r\", encoding=\"utf-8\") as fh:\r\n                paths = json.load(fh)\r\n            for key in (\"include\", \"platinclude\"):\r\n                if key in paths:\r\n                    paths[key] = make_posix(paths[key])\r\n            return paths\r\n        else:\r\n            vistir.misc.echo(\"Failed to load paths: {0}\".format(c.err), fg=\"yellow\")\r\n            vistir.misc.echo(\"Output: {0}\".format(c.out), fg=\"yellow\")\r\n        return None\r\n\r\n    @cached_property\r\n    def sys_prefix(self):\r\n        \"\"\"\r\n        The prefix run inside the context of the environment\r\n\r\n        :return: The python prefix inside the environment\r\n        :rtype: :data:`sys.prefix`\r\n        \"\"\"\r\n\r\n        command = [self.python, \"-c\", \"import sys; print(sys.prefix)\"]\r\n        c = vistir.misc.run(command, return_object=True, block=True, nospin=True, write_to_stdout=False)\r\n        sys_prefix = vistir.compat.Path(vistir.misc.to_text(c.out).strip()).as_posix()\r\n        return sys_prefix\r\n\r\n    @cached_property\r\n    def paths(self):\r\n        paths = {}\r\n        with vistir.contextmanagers.temp_environ(), vistir.contextmanagers.temp_path():\r\n            os.environ[\"PYTHONIOENCODING\"] = vistir.compat.fs_str(\"utf-8\")\r\n            os.environ[\"PYTHONDONTWRITEBYTECODE\"] = vistir.compat.fs_str(\"1\")\r\n            paths = self.base_paths\r\n            os.environ[\"PATH\"] = paths[\"PATH\"]\r\n            os.environ[\"PYTHONPATH\"] = paths[\"PYTHONPATH\"]\r\n            if \"headers\" not in paths:\r\n                paths[\"headers\"] = paths[\"include\"]\r\n        return paths\r\n\r\n    @property\r\n    def scripts_dir(self):\r\n        return self.paths[\"scripts\"]\r\n\r\n    @property\r\n    def libdir(self):\r\n        purelib = self.paths.get(\"purelib\", None)\r\n        if purelib and os.path.exists(purelib):\r\n            return \"purelib\", purelib\r\n        return \"platlib\", self.paths[\"platlib\"]\r\n\r\n    @property\r\n    def pip_version(self):\r\n        \"\"\"\r\n        Get the pip version in the environment.  Useful for knowing which args we can use\r\n        when installing.\r\n        \"\"\"\r\n        from .vendor.packaging.version import parse as parse_version\r\n        pip = next(iter(\r\n            pkg for pkg in self.get_installed_packages() if pkg.key == \"pip\"\r\n        ), None)\r\n        if pip is not None:\r\n            return parse_version(pip.version)\r\n        return parse_version(\"19.3\")\r\n\r\n    def expand_egg_links(self):\r\n        \"\"\"\r\n        Expand paths specified in egg-link files to prevent pip errors during\r\n        reinstall\r\n        \"\"\"\r\n        prefixes = [\r\n            vistir.compat.Path(prefix)\r\n            for prefix in self.base_paths[\"libdirs\"].split(os.pathsep)\r\n            if vistir.path.is_in_path(prefix, self.prefix.as_posix())\r\n        ]\r\n        for loc in prefixes:\r\n            if not loc.exists():\r\n                continue\r\n            for pth in loc.iterdir():\r\n                if not pth.suffix == \".egg-link\":\r\n                    continue\r\n                contents = [\r\n                    vistir.path.normalize_path(line.strip())\r\n                    for line in pth.read_text().splitlines()\r\n                ]\r\n                pth.write_text(\"\\n\".join(contents))\r\n\r\n    def get_distributions(self):\r\n        \"\"\"\r\n        Retrives the distributions installed on the library path of the environment\r\n\r\n        :return: A set of distributions found on the library path\r\n        :rtype: iterator\r\n        \"\"\"\r\n\r\n        pkg_resources = self.safe_import(\"pkg_resources\")\r\n        libdirs = self.base_paths[\"libdirs\"].split(os.pathsep)\r\n        dists = (pkg_resources.find_distributions(libdir) for libdir in libdirs)\r\n        for dist in itertools.chain.from_iterable(dists):\r\n            yield dist\r\n\r\n    def find_egg(self, egg_dist):\r\n        \"\"\"Find an egg by name in the given environment\"\"\"\r\n        site_packages = self.libdir[1]\r\n        search_filename = \"{0}.egg-link\".format(egg_dist.project_name)\r\n        try:\r\n            user_site = site.getusersitepackages()\r\n        except AttributeError:\r\n            user_site = site.USER_SITE\r\n        search_locations = [site_packages, user_site]\r\n        for site_directory in search_locations:\r\n            egg = os.path.join(site_directory, search_filename)\r\n            if os.path.isfile(egg):\r\n                return egg\r\n\r\n    def locate_dist(self, dist):\r\n        \"\"\"Given a distribution, try to find a corresponding egg link first.\r\n\r\n        If the egg - link doesn 't exist, return the supplied distribution.\"\"\"\r\n\r\n        location = self.find_egg(dist)\r\n        return location or dist.location\r\n\r\n    def dist_is_in_project(self, dist):\r\n        \"\"\"Determine whether the supplied distribution is in the environment.\"\"\"\r\n        from .project import _normalized\r\n        prefixes = [\r\n            _normalized(prefix) for prefix in self.base_paths[\"libdirs\"].split(os.pathsep)\r\n            if _normalized(prefix).startswith(_normalized(self.prefix.as_posix()))\r\n        ]\r\n        location = self.locate_dist(dist)\r\n        if not location:\r\n            return False\r\n        location = _normalized(make_posix(location))\r\n        return any(location.startswith(prefix) for prefix in prefixes)\r\n\r\n    def get_installed_packages(self):\r\n        \"\"\"Returns all of the installed packages in a given environment\"\"\"\r\n        workingset = self.get_working_set()\r\n        packages = [\r\n            pkg for pkg in workingset\r\n            if self.dist_is_in_project(pkg) and pkg.key != \"python\"\r\n        ]\r\n        return packages\r\n\r\n    @contextlib.contextmanager\r\n    def get_finder(self, pre=False):\r\n        from .vendor.pip_shims.shims import (\r\n            InstallCommand, get_package_finder\r\n        )\r\n        from .environments import PIPENV_CACHE_DIR\r\n\r\n        pip_command = InstallCommand()\r\n        pip_args = self._modules[\"pipenv\"].utils.prepare_pip_source_args(self.sources)\r\n        pip_options, _ = pip_command.parser.parse_args(pip_args)\r\n        pip_options.cache_dir = PIPENV_CACHE_DIR\r\n        pip_options.pre = self.pipfile.get(\"pre\", pre)\r\n        with pip_command._build_session(pip_options) as session:\r\n            finder = get_package_finder(install_cmd=pip_command, options=pip_options, session=session)\r\n            yield finder\r\n\r\n    def get_package_info(self, pre=False):\r\n        from .vendor.pip_shims.shims import pip_version, parse_version, CandidateEvaluator\r\n        dependency_links = []\r\n        packages = self.get_installed_packages()\r\n        # This code is borrowed from pip's current implementation\r\n        if parse_version(pip_version) < parse_version(\"19.0\"):\r\n            for dist in packages:\r\n                if dist.has_metadata('dependency_links.txt'):\r\n                    dependency_links.extend(\r\n                        dist.get_metadata_lines('dependency_links.txt')\r\n                    )\r\n\r\n        with self.get_finder() as finder:\r\n            if parse_version(pip_version) < parse_version(\"19.0\"):\r\n                finder.add_dependency_links(dependency_links)\r\n\r\n            for dist in packages:\r\n                typ = 'unknown'\r\n                all_candidates = finder.find_all_candidates(dist.key)\r\n                if not self.pipfile.get(\"pre\", finder.allow_all_prereleases):\r\n                    # Remove prereleases\r\n                    all_candidates = [\r\n                        candidate for candidate in all_candidates\r\n                        if not candidate.version.is_prerelease\r\n                    ]\r\n\r\n                if not all_candidates:\r\n                    continue\r\n                candidate_evaluator = finder.make_candidate_evaluator(project_name=dist.key)\r\n                best_candidate_result = candidate_evaluator.compute_best_candidate(all_candidates)\r\n                remote_version = best_candidate_result.best_candidate.version\r\n                if best_candidate_result.best_candidate.link.is_wheel:\r\n                    typ = 'wheel'\r\n                else:\r\n                    typ = 'sdist'\r\n                # This is dirty but makes the rest of the code much cleaner\r\n                dist.latest_version = remote_version\r\n                dist.latest_filetype = typ\r\n                yield dist\r\n\r\n    def get_outdated_packages(self, pre=False):\r\n        return [\r\n            pkg for pkg in self.get_package_info(pre=pre)\r\n            if pkg.latest_version._key > pkg.parsed_version._key\r\n        ]\r\n\r\n    @classmethod\r\n    def _get_requirements_for_package(cls, node, key_tree, parent=None, chain=None):\r\n        if chain is None:\r\n            chain = [node.project_name]\r\n\r\n        d = node.as_dict()\r\n        if parent:\r\n            d['required_version'] = node.version_spec if node.version_spec else 'Any'\r\n        else:\r\n            d['required_version'] = d['installed_version']\r\n\r\n        get_children = lambda n: key_tree.get(n.key, [])    # noqa\r\n\r\n        d['dependencies'] = [\r\n            cls._get_requirements_for_package(c, key_tree, parent=node,\r\n                                              chain=chain+[c.project_name])\r\n            for c in get_children(node)\r\n            if c.project_name not in chain\r\n        ]\r\n\r\n        return d\r\n\r\n    def get_package_requirements(self, pkg=None):\r\n        from .vendor.pipdeptree import flatten, sorted_tree, build_dist_index, construct_tree\r\n        packages = self.get_installed_packages()\r\n        if pkg:\r\n            packages = [p for p in packages if p.key == pkg]\r\n        dist_index = build_dist_index(packages)\r\n        tree = sorted_tree(construct_tree(dist_index))\r\n        branch_keys = set(r.key for r in flatten(tree.values()))\r\n        if pkg is not None:\r\n            nodes = [p for p in tree.keys() if p.key == pkg]\r\n        else:\r\n            nodes = [p for p in tree.keys() if p.key not in branch_keys]\r\n        key_tree = dict((k.key, v) for k, v in tree.items())\r\n\r\n        return [self._get_requirements_for_package(p, key_tree) for p in nodes]\r\n\r\n    @classmethod\r\n    def reverse_dependency(cls, node):\r\n        new_node = {\r\n            \"package_name\": node[\"package_name\"],\r\n            \"installed_version\": node[\"installed_version\"],\r\n            \"required_version\": node[\"required_version\"]\r\n        }\r\n        for dependency in node.get(\"dependencies\", []):\r\n            for dep in cls.reverse_dependency(dependency):\r\n                new_dep = dep.copy()\r\n                new_dep[\"parent\"] = (node[\"package_name\"], node[\"installed_version\"])\r\n                yield new_dep\r\n        yield new_node\r\n\r\n    def reverse_dependencies(self):\r\n        from vistir.misc import unnest, chunked\r\n        rdeps = {}\r\n        for req in self.get_package_requirements():\r\n            for d in self.reverse_dependency(req):\r\n                parents = None\r\n                name = d[\"package_name\"]\r\n                pkg = {\r\n                    name: {\r\n                        \"installed\": d[\"installed_version\"],\r\n                        \"required\": d[\"required_version\"]\r\n                    }\r\n                }\r\n                parents = tuple(d.get(\"parent\", ()))\r\n                pkg[name][\"parents\"] = parents\r\n                if rdeps.get(name):\r\n                    if not (rdeps[name].get(\"required\") or rdeps[name].get(\"installed\")):\r\n                        rdeps[name].update(pkg[name])\r\n                    rdeps[name][\"parents\"] = rdeps[name].get(\"parents\", ()) + parents\r\n                else:\r\n                    rdeps[name] = pkg[name]\r\n        for k in list(rdeps.keys()):\r\n            entry = rdeps[k]\r\n            if entry.get(\"parents\"):\r\n                rdeps[k][\"parents\"] = set([\r\n                   p for p, version in chunked(2, unnest(entry[\"parents\"]))\r\n                ])\r\n        return rdeps\r\n\r\n    def get_working_set(self):\r\n        \"\"\"Retrieve the working set of installed packages for the environment.\r\n\r\n        :return: The working set for the environment\r\n        :rtype: :class:`pkg_resources.WorkingSet`\r\n        \"\"\"\r\n\r\n        working_set = pkg_resources.WorkingSet(self.sys_path)\r\n        return working_set\r\n\r\n    def is_installed(self, pkgname):\r\n        \"\"\"Given a package name, returns whether it is installed in the environment\r\n\r\n        :param str pkgname: The name of a package\r\n        :return: Whether the supplied package is installed in the environment\r\n        :rtype: bool\r\n        \"\"\"\r\n\r\n        return any(d for d in self.get_distributions() if d.project_name == pkgname)\r\n\r\n    def is_satisfied(self, req):\r\n        match = next(\r\n            iter(\r\n                d for d in self.get_distributions()\r\n                if canonicalize_name(d.project_name) == req.normalized_name\r\n            ), None\r\n        )\r\n        if match is not None:\r\n            if req.editable and req.line_instance.is_local and self.find_egg(match):\r\n                requested_path = req.line_instance.path\r\n                return requested_path and vistir.compat.samefile(requested_path, match.location)\r\n            elif match.has_metadata(\"direct_url.json\"):\r\n                direct_url_metadata = json.loads(match.get_metadata(\"direct_url.json\"))\r\n                commit_id = direct_url_metadata.get(\"vcs_info\", {}).get(\"commit_id\", \"\")\r\n                vcs_type = direct_url_metadata.get(\"vcs_info\", {}).get(\"vcs\", \"\")\r\n                _, pipfile_part = req.as_pipfile().popitem()\r\n                return (\r\n                    vcs_type == req.vcs and commit_id == req.commit_hash\r\n                    and direct_url_metadata[\"url\"] == pipfile_part[req.vcs]\r\n                )\r\n            elif req.line_instance.specifiers is not None:\r\n                return req.line_instance.specifiers.contains(\r\n                    match.version, prereleases=True\r\n                )\r\n            return True\r\n        return False\r\n\r\n    def run(self, cmd, cwd=os.curdir):\r\n        \"\"\"Run a command with :class:`~subprocess.Popen` in the context of the environment\r\n\r\n        :param cmd: A command to run in the environment\r\n        :type cmd: str or list\r\n        :param str cwd: The working directory in which to execute the command, defaults to :data:`os.curdir`\r\n        :return: A finished command object\r\n        :rtype: :class:`~subprocess.Popen`\r\n        \"\"\"\r\n\r\n        c = None\r\n        with self.activated():\r\n            script = vistir.cmdparse.Script.parse(cmd)\r\n            c = vistir.misc.run(script._parts, return_object=True, nospin=True, cwd=cwd, write_to_stdout=False)\r\n        return c\r\n\r\n    def run_py(self, cmd, cwd=os.curdir):\r\n        \"\"\"Run a python command in the enviornment context.\r\n\r\n        :param cmd: A command to run in the environment - runs with `python -c`\r\n        :type cmd: str or list\r\n        :param str cwd: The working directory in which to execute the command, defaults to :data:`os.curdir`\r\n        :return: A finished command object\r\n        :rtype: :class:`~subprocess.Popen`\r\n        \"\"\"\r\n\r\n        c = None\r\n        if isinstance(cmd, six.string_types):\r\n            script = vistir.cmdparse.Script.parse(\"{0} -c {1}\".format(self.python, cmd))\r\n        else:\r\n            script = vistir.cmdparse.Script.parse([self.python, \"-c\"] + list(cmd))\r\n        with self.activated():\r\n            c = vistir.misc.run(script._parts, return_object=True, nospin=True, cwd=cwd, write_to_stdout=False)\r\n        return c\r\n\r\n    def run_activate_this(self):\r\n        \"\"\"Runs the environment's inline activation script\"\"\"\r\n        if self.is_venv:\r\n            activate_this = os.path.join(self.scripts_dir, \"activate_this.py\")\r\n            if not os.path.isfile(activate_this):\r\n                raise OSError(\"No such file: {0!s}\".format(activate_this))\r\n            with open(activate_this, \"r\") as f:\r\n                code = compile(f.read(), activate_this, \"exec\")\r\n                exec(code, dict(__file__=activate_this))\r\n\r\n    @contextlib.contextmanager\r\n    def activated(self, include_extras=True, extra_dists=None):\r\n        \"\"\"Helper context manager to activate the environment.\r\n\r\n        This context manager will set the following variables for the duration\r\n        of its activation:\r\n\r\n            * sys.prefix\r\n            * sys.path\r\n            * os.environ[\"VIRTUAL_ENV\"]\r\n            * os.environ[\"PATH\"]\r\n\r\n        In addition, it will make any distributions passed into `extra_dists` available\r\n        on `sys.path` while inside the context manager, as well as making `passa` itself\r\n        available.\r\n\r\n        The environment's `prefix` as well as `scripts_dir` properties are both prepended\r\n        to `os.environ[\"PATH\"]` to ensure that calls to `~Environment.run()` use the\r\n        environment's path preferentially.\r\n        \"\"\"\r\n\r\n        if not extra_dists:\r\n            extra_dists = []\r\n        original_path = sys.path\r\n        original_prefix = sys.prefix\r\n        parent_path = vistir.compat.Path(__file__).absolute().parent\r\n        vendor_dir = parent_path.joinpath(\"vendor\").as_posix()\r\n        patched_dir = parent_path.joinpath(\"patched\").as_posix()\r\n        parent_path = parent_path.as_posix()\r\n        self.add_dist(\"pip\")\r\n        prefix = self.prefix.as_posix()\r\n        with vistir.contextmanagers.temp_environ(), vistir.contextmanagers.temp_path():\r\n            os.environ[\"PATH\"] = os.pathsep.join([\r\n                vistir.compat.fs_str(self.script_basedir),\r\n                vistir.compat.fs_str(self.prefix.as_posix()),\r\n                os.environ.get(\"PATH\", \"\")\r\n            ])\r\n            os.environ[\"PYTHONIOENCODING\"] = vistir.compat.fs_str(\"utf-8\")\r\n            os.environ[\"PYTHONDONTWRITEBYTECODE\"] = vistir.compat.fs_str(\"1\")\r\n            from .environments import PIPENV_USE_SYSTEM\r\n            if self.is_venv:\r\n                os.environ[\"PYTHONPATH\"] = self.base_paths[\"PYTHONPATH\"]\r\n                os.environ[\"VIRTUAL_ENV\"] = vistir.compat.fs_str(prefix)\r\n            else:\r\n                if not PIPENV_USE_SYSTEM and not os.environ.get(\"VIRTUAL_ENV\"):\r\n                    os.environ[\"PYTHONPATH\"] = self.base_paths[\"PYTHONPATH\"]\r\n                    os.environ.pop(\"PYTHONHOME\", None)\r\n            sys.path = self.sys_path\r\n            sys.prefix = self.sys_prefix\r\n            site.addsitedir(self.base_paths[\"purelib\"])\r\n            pip = self.safe_import(\"pip\")       # noqa\r\n            pip_vendor = self.safe_import(\"pip._vendor\")\r\n            pep517_dir = os.path.join(os.path.dirname(pip_vendor.__file__), \"pep517\")\r\n            site.addsitedir(pep517_dir)\r\n            os.environ[\"PYTHONPATH\"] = os.pathsep.join([\r\n                os.environ.get(\"PYTHONPATH\", self.base_paths[\"PYTHONPATH\"]), pep517_dir\r\n            ])\r\n            if include_extras:\r\n                site.addsitedir(parent_path)\r\n                sys.path.extend([parent_path, patched_dir, vendor_dir])\r\n                extra_dists = list(self.extra_dists) + extra_dists\r\n                for extra_dist in extra_dists:\r\n                    if extra_dist not in self.get_working_set():\r\n                        extra_dist.activate(self.sys_path)\r\n            try:\r\n                yield\r\n            finally:\r\n                sys.path = original_path\r\n                sys.prefix = original_prefix\r\n                six.moves.reload_module(pkg_resources)\r\n\r\n    @cached_property\r\n    def finders(self):\r\n        from pipenv.vendor.pythonfinder import Finder\r\n        finders = [\r\n            Finder(path=self.base_paths[\"scripts\"], global_search=gs, system=False)\r\n            for gs in (False, True)\r\n        ]\r\n        return finders\r\n\r\n    @property\r\n    def finder(self):\r\n        return next(iter(self.finders), None)\r\n\r\n    def which(self, search, as_path=True):\r\n        find = operator.methodcaller(\"which\", search)\r\n        result = next(iter(filter(None, (find(finder) for finder in self.finders))), None)\r\n        if not result:\r\n            result = self._which(search)\r\n        else:\r\n            if as_path:\r\n                result = str(result.path)\r\n        return result\r\n\r\n    def get_install_args(self, editable=False, setup_path=None):\r\n        install_arg = \"install\" if not editable else \"develop\"\r\n        install_keys = [\"headers\", \"purelib\", \"platlib\", \"scripts\", \"data\"]\r\n        install_args = [\r\n            self.environment.python, \"-u\", \"-c\", SETUPTOOLS_SHIM % setup_path,\r\n            install_arg, \"--single-version-externally-managed\", \"--no-deps\",\r\n            \"--prefix={0}\".format(self.base_paths[\"prefix\"]), \"--no-warn-script-location\"\r\n        ]\r\n        for key in install_keys:\r\n            install_args.append(\r\n                \"--install-{0}={1}\".format(key, self.base_paths[key])\r\n            )\r\n        return install_args\r\n\r\n    def install(self, requirements):\r\n        if not isinstance(requirements, (tuple, list)):\r\n            requirements = [requirements]\r\n        with self.get_finder() as finder:\r\n            args = []\r\n            for format_control in ('no_binary', 'only_binary'):\r\n                formats = getattr(finder.format_control, format_control)\r\n                args.extend(('--' + format_control.replace('_', '-'),\r\n                            ','.join(sorted(formats or {':none:'}))))\r\n            if finder.index_urls:\r\n                args.extend(['-i', finder.index_urls[0]])\r\n                for extra_index in finder.index_urls[1:]:\r\n                    args.extend(['--extra-index-url', extra_index])\r\n            else:\r\n                args.append('--no-index')\r\n            for link in finder.find_links:\r\n                args.extend(['--find-links', link])\r\n            for _, host, _ in finder.secure_origins:\r\n                args.extend(['--trusted-host', host])\r\n            if finder.allow_all_prereleases:\r\n                args.append('--pre')\r\n            if finder.process_dependency_links:\r\n                args.append('--process-dependency-links')\r\n            args.append('--')\r\n            args.extend(requirements)\r\n            out, _ = vistir.misc.run(args, return_object=False, nospin=True, block=True,\r\n                                     combine_stderr=False)\r\n\r\n    @contextlib.contextmanager\r\n    def uninstall(self, pkgname, *args, **kwargs):\r\n        \"\"\"A context manager which allows uninstallation of packages from the environment\r\n\r\n        :param str pkgname: The name of a package to uninstall\r\n\r\n        >>> env = Environment(\"/path/to/env/root\")\r\n        >>> with env.uninstall(\"pytz\", auto_confirm=True, verbose=False) as uninstaller:\r\n                cleaned = uninstaller.paths\r\n        >>> if cleaned:\r\n                print(\"uninstalled packages: %s\" % cleaned)\r\n        \"\"\"\r\n\r\n        auto_confirm = kwargs.pop(\"auto_confirm\", True)\r\n        verbose = kwargs.pop(\"verbose\", False)\r\n        with self.activated():\r\n            monkey_patch = next(iter(\r\n                dist for dist in self.base_working_set\r\n                if dist.project_name == \"recursive-monkey-patch\"\r\n            ), None)\r\n            if monkey_patch:\r\n                monkey_patch.activate()\r\n            pip_shims = self.safe_import(\"pip_shims\")\r\n            pathset_base = pip_shims.UninstallPathSet\r\n            pathset_base._permitted = PatchedUninstaller._permitted\r\n            dist = next(\r\n                iter(d for d in self.get_working_set() if d.project_name == pkgname),\r\n                None\r\n            )\r\n            pathset = pathset_base.from_dist(dist)\r\n            if pathset is not None:\r\n                pathset.remove(auto_confirm=auto_confirm, verbose=verbose)\r\n            try:\r\n                yield pathset\r\n            except Exception:\r\n                if pathset is not None:\r\n                    pathset.rollback()\r\n            else:\r\n                if pathset is not None:\r\n                    pathset.commit()\r\n            if pathset is None:\r\n                return\r\n\r\n\r\nclass PatchedUninstaller(object):\r\n    def _permitted(self, path):\r\n        return True\r\n\r\n\r\nSETUPTOOLS_SHIM = (\r\n    \"import setuptools, tokenize;__file__=%r;\"\r\n    \"f=getattr(tokenize, 'open', open)(__file__);\"\r\n    \"code=f.read().replace('\\\\r\\\\n', '\\\\n');\"\r\n    \"f.close();\"\r\n    \"exec(compile(code, __file__, 'exec'))\"\r\n)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- env/Lib/site-packages/pipenv/environment.py	(revision 7de091c5b19e7b06e80c151f7100df6d0f893820)
+++ env/Lib/site-packages/pipenv/environment.py	(date 1591098437572)
@@ -25,13 +25,28 @@
 from .utils import normalize_path, make_posix
 
 
+if False:
+    import pip_shims.shims
+    import tomlkit
+    from typing import ContextManager, Dict, Generator, List, Optional, Set, Union
+    from types import ModuleType
+    from .project import TSource, TPipfile, Project
+    from .vendor.packaging.version import Version
+
 BASE_WORKING_SET = pkg_resources.WorkingSet(sys.path)
 # TODO: Unittests for this class
 
 
 class Environment(object):
-    def __init__(self, prefix=None, is_venv=False, base_working_set=None, pipfile=None,
-                 sources=None, project=None):
+    def __init__(
+        self,
+        prefix=None,  # type: Optional[str]
+        is_venv=False,  # type: bool
+        base_working_set=None,  # type: pkg_resources.WorkingSet
+        pipfile=None,  # type: Optional[Union[tomlkit.toml_document.TOMLDocument, TPipfile]]
+        sources=None,  # type: Optional[List[TSource]]
+        project=None  # type: Optional[Project]
+    ):
         super(Environment, self).__init__()
         self._modules = {'pkg_resources': pkg_resources, 'pipenv': pipenv}
         self.base_working_set = base_working_set if base_working_set else BASE_WORKING_SET
@@ -55,6 +70,7 @@
         self.sys_paths = get_paths()
 
     def safe_import(self, name):
+        # type: (str) -> ModuleType
         """Helper utility for reimporting previously imported modules while inside the env"""
         module = None
         if name not in self._modules:
@@ -74,10 +90,12 @@
             except TypeError:
                 del sys.modules[name]
                 sys.modules[name] = self._modules[name]
+                return self._modules[name]
         return module
 
     @classmethod
     def resolve_dist(cls, dist, working_set):
+        # type: (pkg_resources.Distribution, pkg_resources.WorkingSet) -> Set[pkg_resources.Distribution]
         """Given a local distribution and a working set, returns all dependencies from the set.
 
         :param dist: A single distribution to find the dependencies of
@@ -101,28 +119,33 @@
         return deps
 
     def extend_dists(self, dist):
+        # type: (pkg_resources.Distribution) -> None
         extras = self.resolve_dist(dist, self.base_working_set)
         self.extra_dists.append(dist)
         if extras:
             self.extra_dists.extend(extras)
 
     def add_dist(self, dist_name):
+        # type: (str) -> None
         dist = pkg_resources.get_distribution(pkg_resources.Requirement(dist_name))
         self.extend_dists(dist)
 
     @cached_property
     def python_version(self):
+        # type: () -> str
         with self.activated():
             sysconfig = self.safe_import("sysconfig")
             py_version = sysconfig.get_python_version()
             return py_version
 
     def find_libdir(self):
+        # type: () -> Optional[vistir.compat.Path]
         libdir = self.prefix / "lib"
         return next(iter(list(libdir.iterdir())), None)
 
     @property
     def python_info(self):
+        # type: () -> Dict[str, str]
         include_dir = self.prefix / "include"
         if not os.path.exists(include_dir):
             include_dirs = self.get_include_path()
@@ -139,6 +162,7 @@
         return {}
 
     def _replace_parent_version(self, path, replace_version):
+        # type: (str, str) -> str
         if not os.path.exists(path):
             base, leaf = os.path.split(path)
             base, parent = os.path.split(base)
@@ -150,6 +174,7 @@
 
     @cached_property
     def base_paths(self):
+        # type: () -> Dict[str, str]
         """
         Returns the context appropriate paths for the environment.
 
@@ -228,6 +253,7 @@
 
     @cached_property
     def script_basedir(self):
+        # type: () -> str
         """Path to the environment scripts dir"""
         prefix = make_posix(self.prefix.as_posix())
         install_scheme = 'nt' if (os.name == 'nt') else 'posix_prefix'
@@ -239,6 +265,7 @@
 
     @property
     def python(self):
+        # type: () -> str
         """Path to the environment python"""
         py = vistir.compat.Path(self.script_basedir).joinpath("python").absolute().as_posix()
         if not py:
@@ -247,6 +274,7 @@
 
     @cached_property
     def sys_path(self):
+        # type: () -> List[str]
         """
         The system path inside the environment
 
@@ -269,6 +297,7 @@
         return path
 
     def build_command(self, python_lib=False, python_inc=False, scripts=False, py_version=False):
+        # type: (bool, bool, bool, bool) -> str
         """Build the text for running a command in the given environment
 
         :param python_lib: Whether to include the python lib dir commands, defaults to False
@@ -310,6 +339,7 @@
         return py_command
 
     def get_paths(self):
+        # type: () -> Optional[Dict[str, str]]
         """
         Get the paths for the environment by running a subcommand
 
@@ -340,6 +370,7 @@
         return None
 
     def get_lib_paths(self):
+        # type: () -> Dict[str, str]
         """Get the include path for the environment
 
         :return: The python include path for the environment
@@ -387,6 +418,7 @@
         return {}
 
     def get_include_path(self):
+        # type: () -> Optional[Dict[str, str]]
         """Get the include path for the environment
 
         :return: The python include path for the environment
@@ -421,6 +453,7 @@
 
     @cached_property
     def sys_prefix(self):
+        # type: () -> str
         """
         The prefix run inside the context of the environment
 
@@ -435,6 +468,7 @@
 
     @cached_property
     def paths(self):
+        # type: () -> Dict[str, str]
         paths = {}
         with vistir.contextmanagers.temp_environ(), vistir.contextmanagers.temp_path():
             os.environ["PYTHONIOENCODING"] = vistir.compat.fs_str("utf-8")
@@ -448,10 +482,12 @@
 
     @property
     def scripts_dir(self):
+        # type: () -> str
         return self.paths["scripts"]
 
     @property
     def libdir(self):
+        # type: () -> str
         purelib = self.paths.get("purelib", None)
         if purelib and os.path.exists(purelib):
             return "purelib", purelib
@@ -459,6 +495,7 @@
 
     @property
     def pip_version(self):
+        # type: () -> Version
         """
         Get the pip version in the environment.  Useful for knowing which args we can use
         when installing.
@@ -469,9 +506,10 @@
         ), None)
         if pip is not None:
             return parse_version(pip.version)
-        return parse_version("19.3")
+        return parse_version("20.2")
 
     def expand_egg_links(self):
+        # type: () -> None
         """
         Expand paths specified in egg-link files to prevent pip errors during
         reinstall
@@ -494,6 +532,7 @@
                 pth.write_text("\n".join(contents))
 
     def get_distributions(self):
+        # type: () -> Generator[pkg_resources.Distribution, None, None]
         """
         Retrives the distributions installed on the library path of the environment
 
@@ -508,6 +547,7 @@
             yield dist
 
     def find_egg(self, egg_dist):
+        # type: (pkg_resources.Distribution) -> str
         """Find an egg by name in the given environment"""
         site_packages = self.libdir[1]
         search_filename = "{0}.egg-link".format(egg_dist.project_name)
@@ -522,6 +562,7 @@
                 return egg
 
     def locate_dist(self, dist):
+        # type: (pkg_resources.Distribution) -> str
         """Given a distribution, try to find a corresponding egg link first.
 
         If the egg - link doesn 't exist, return the supplied distribution."""
@@ -530,6 +571,7 @@
         return location or dist.location
 
     def dist_is_in_project(self, dist):
+        # type: (pkg_resources.Distribution) -> bool
         """Determine whether the supplied distribution is in the environment."""
         from .project import _normalized
         prefixes = [
@@ -543,6 +585,7 @@
         return any(location.startswith(prefix) for prefix in prefixes)
 
     def get_installed_packages(self):
+        # type: () -> List[pkg_resources.Distribution]
         """Returns all of the installed packages in a given environment"""
         workingset = self.get_working_set()
         packages = [
@@ -553,6 +596,7 @@
 
     @contextlib.contextmanager
     def get_finder(self, pre=False):
+        # type: (bool) -> ContextManager[pip_shims.shims.PackageFinder]
         from .vendor.pip_shims.shims import (
             InstallCommand, get_package_finder
         )
@@ -568,7 +612,8 @@
             yield finder
 
     def get_package_info(self, pre=False):
-        from .vendor.pip_shims.shims import pip_version, parse_version, CandidateEvaluator
+        # type: (bool) -> Generator[pkg_resources.Distribution, None, None]
+        from .vendor.pip_shims.shims import pip_version, parse_version
         dependency_links = []
         packages = self.get_installed_packages()
         # This code is borrowed from pip's current implementation
@@ -608,6 +653,7 @@
                 yield dist
 
     def get_outdated_packages(self, pre=False):
+        # type: (bool) -> List[pkg_resources.Distribution]
         return [
             pkg for pkg in self.get_package_info(pre=pre)
             if pkg.latest_version._key > pkg.parsed_version._key
Index: env/Lib/site-packages/pipenv-2020.6.2.dist-info/METADATA
===================================================================
--- env/Lib/site-packages/pipenv-2020.6.2.dist-info/METADATA	(date 1591098444260)
+++ env/Lib/site-packages/pipenv-2020.6.2.dist-info/METADATA	(date 1591098444260)
@@ -0,0 +1,352 @@
+Metadata-Version: 2.1
+Name: pipenv
+Version: 2020.6.2
+Summary: Python Development Workflow for Humans.
+Home-page: https://github.com/pypa/pipenv
+Author: Pipenv maintainer team
+Author-email: distutils-sig@python.org
+License: MIT
+Platform: UNKNOWN
+Classifier: License :: OSI Approved :: MIT License
+Classifier: Programming Language :: Python
+Classifier: Programming Language :: Python :: 2.7
+Classifier: Programming Language :: Python :: 3
+Classifier: Programming Language :: Python :: 3.4
+Classifier: Programming Language :: Python :: 3.5
+Classifier: Programming Language :: Python :: 3.6
+Classifier: Programming Language :: Python :: 3.7
+Classifier: Programming Language :: Python :: Implementation :: CPython
+Classifier: Programming Language :: Python :: Implementation :: PyPy
+Requires-Python: >=2.7,!=3.0.*,!=3.1.*,!=3.2.*,!=3.3.*
+Description-Content-Type: text/markdown
+Requires-Dist: pip (>=18.0)
+Requires-Dist: certifi
+Requires-Dist: setuptools (>=36.2.1)
+Requires-Dist: virtualenv-clone (>=0.2.5)
+Requires-Dist: virtualenv
+Requires-Dist: enum34 ; python_version < "3"
+Requires-Dist: typing ; python_version < "3.5"
+Provides-Extra: dev
+Requires-Dist: towncrier ; extra == 'dev'
+Requires-Dist: bs4 ; extra == 'dev'
+Requires-Dist: twine ; extra == 'dev'
+Requires-Dist: sphinx (<2) ; extra == 'dev'
+Requires-Dist: flake8 (<4.0,>=3.3.0) ; extra == 'dev'
+Requires-Dist: parver ; extra == 'dev'
+Requires-Dist: invoke ; extra == 'dev'
+Requires-Dist: black ; (python_version >= "3.6") and extra == 'dev'
+Provides-Extra: tests
+Requires-Dist: pytest (<5.0) ; extra == 'tests'
+Requires-Dist: pytest-timeout ; extra == 'tests'
+Requires-Dist: pytest-xdist ; extra == 'tests'
+Requires-Dist: flaky ; extra == 'tests'
+Requires-Dist: mock ; extra == 'tests'
+
+
+Pipenv: Python Development Workflow for Humans
+==============================================
+
+[![image](https://img.shields.io/pypi/v/pipenv.svg)](https://python.org/pypi/pipenv)
+[![image](https://img.shields.io/pypi/l/pipenv.svg)](https://python.org/pypi/pipenv)
+[![Azure Pipelines Build Status](https://dev.azure.com/pypa/pipenv/_apis/build/status/Pipenv%20CI?branchName=master)](https://dev.azure.com/pypa/pipenv/_build/latest?definitionId=16&branchName=master)
+[![image](https://img.shields.io/pypi/pyversions/pipenv.svg)](https://python.org/pypi/pipenv)
+
+
+------------------------------------------------------------------------
+[[ ~ Dependency Scanning by PyUp.io ~ ]](https://pyup.io)
+
+**Pipenv** is a tool that aims to bring the best of all packaging worlds
+(bundler, composer, npm, cargo, yarn, etc.) to the Python world.
+*Windows is a first-class citizen, in our world.*
+
+It automatically creates and manages a virtualenv for your projects, as
+well as adds/removes packages from your `Pipfile` as you
+install/uninstall packages. It also generates the ever-important
+`Pipfile.lock`, which is used to produce deterministic builds.
+
+![GIF demonstrating Pipenv's usage](https://gist.githubusercontent.com/jlusk/855d611bbcfa2b159839db73d07f6ce9/raw/7f5743401809f7e630ee8ff458faa980e19924a0/pipenv.gif)
+
+The problems that Pipenv seeks to solve are multi-faceted:
+
+-   You no longer need to use `pip` and `virtualenv` separately. They
+    work together.
+-   Managing a `requirements.txt` file [can be
+    problematic](https://www.kennethreitz.org/essays/a-better-pip-workflow),
+    so Pipenv uses the upcoming `Pipfile` and `Pipfile.lock` instead,
+    which is superior for basic use cases.
+-   Hashes are used everywhere, always. Security. Automatically expose
+    security vulnerabilities.
+-   Give you insight into your dependency graph (e.g. `$ pipenv graph`).
+-   Streamline development workflow by loading `.env` files.
+
+You can quickly play with Pipenv right in your browser:
+
+[![Try in browser](https://cdn.rawgit.com/rootnroll/library/assets/try.svg)](https://rootnroll.com/d/pipenv/)
+
+Installation
+------------
+
+If you\'re on MacOS, you can install Pipenv easily with Homebrew:
+
+    $ brew install pipenv
+
+Or, if you\'re using Debian Buster+:
+
+    $ sudo apt install pipenv
+
+Or, if you\'re using Fedora:
+
+    $ sudo dnf install pipenv
+
+Or, if you\'re using FreeBSD:
+
+    # pkg install py36-pipenv
+
+When none of the above is an option:
+
+    $ pip install pipenv
+
+Otherwise, refer to the [documentation](https://pipenv.pypa.io/en/latest/#install-pipenv-today) for instructions.
+
+✨🍰✨
+
+☤ User Testimonials
+-------------------
+
+**David Gang**---
+
+:   *This package manager is really awesome. For the first time I know
+    exactly what my dependencies are which I installed and what the
+    transitive dependencies are. Combined with the fact that installs
+    are deterministic, makes this package manager first class, like
+    cargo*.
+
+**Justin Myles Holmes**---
+
+:   *Pipenv is finally an abstraction meant to engage the mind instead
+    of merely the filesystem.*
+
+☤ Features
+----------
+
+-   Enables truly *deterministic builds*, while easily specifying *only
+    what you want*.
+-   Generates and checks file hashes for locked dependencies.
+-   Automatically install required Pythons, if `pyenv` is available.
+-   Automatically finds your project home, recursively, by looking for a
+    `Pipfile`.
+-   Automatically generates a `Pipfile`, if one doesn\'t exist.
+-   Automatically creates a virtualenv in a standard location.
+-   Automatically adds/removes packages to a `Pipfile` when they are
+    un/installed.
+-   Automatically loads `.env` files, if they exist.
+
+The main commands are `install`, `uninstall`, and `lock`, which
+generates a `Pipfile.lock`. These are intended to replace
+`$ pip install` usage, as well as manual virtualenv management (to
+activate a virtualenv, run `$ pipenv shell`).
+
+### Basic Concepts
+
+-   A virtualenv will automatically be created, when one doesn\'t exist.
+-   When no parameters are passed to `install`, all packages
+    `[packages]` specified will be installed.
+-   To initialize a Python 3 virtual environment, run
+    `$ pipenv --three`.
+-   To initialize a Python 2 virtual environment, run `$ pipenv --two`.
+-   Otherwise, whatever virtualenv defaults to will be the default.
+
+### Other Commands
+
+-   `shell` will spawn a shell with the virtualenv activated.
+-   `run` will run a given command from the virtualenv, with any
+    arguments forwarded (e.g. `$ pipenv run python`).
+-   `check` asserts that PEP 508 requirements are being met by the
+    current environment.
+-   `graph` will print a pretty graph of all your installed
+    dependencies.
+
+### Shell Completion
+
+For example, with fish, put this in your
+`~/.config/fish/completions/pipenv.fish`:
+
+    eval (pipenv --completion)
+
+Alternatively, with bash, put this in your `.bashrc` or `.bash_profile`:
+
+    eval "$(pipenv --completion)"
+
+Magic shell completions are now enabled! There is also a [fish
+plugin](https://github.com/fisherman/pipenv), which will automatically
+activate your subshells for you!
+
+Fish is the best shell. You should use it.
+
+☤ Usage
+-------
+
+    $ pipenv
+    Usage: pipenv [OPTIONS] COMMAND [ARGS]...
+
+    Options:
+      --where          Output project home information.
+      --venv           Output virtualenv information.
+      --py             Output Python interpreter information.
+      --envs           Output Environment Variable options.
+      --rm             Remove the virtualenv.
+      --bare           Minimal output.
+      --completion     Output completion (to be eval'd).
+      --man            Display manpage.
+      --three / --two  Use Python 3/2 when creating virtualenv.
+      --python TEXT    Specify which version of Python virtualenv should use.
+      --site-packages  Enable site-packages for the virtualenv.
+      --version        Show the version and exit.
+      -h, --help       Show this message and exit.
+
+
+    Usage Examples:
+       Create a new project using Python 3.7, specifically:
+       $ pipenv --python 3.7
+
+       Remove project virtualenv (inferred from current directory):
+       $ pipenv --rm
+
+       Install all dependencies for a project (including dev):
+       $ pipenv install --dev
+
+       Create a lockfile containing pre-releases:
+       $ pipenv lock --pre
+
+       Show a graph of your installed dependencies:
+       $ pipenv graph
+
+       Check your installed dependencies for security vulnerabilities:
+       $ pipenv check
+
+       Install a local setup.py into your virtual environment/Pipfile:
+       $ pipenv install -e .
+
+       Use a lower-level pip command:
+       $ pipenv run pip freeze
+
+    Commands:
+      check      Checks for security vulnerabilities and against PEP 508 markers
+                 provided in Pipfile.
+      clean      Uninstalls all packages not specified in Pipfile.lock.
+      graph      Displays currently–installed dependency graph information.
+      install    Installs provided packages and adds them to Pipfile, or (if no
+                 packages are given), installs all packages from Pipfile.
+      lock       Generates Pipfile.lock.
+      open       View a given module in your editor.
+      run        Spawns a command installed into the virtualenv.
+      shell      Spawns a shell within the virtualenv.
+      sync       Installs all packages specified in Pipfile.lock.
+      uninstall  Un-installs a provided package and removes it from Pipfile.
+
+Locate the project:
+
+    $ pipenv --where
+    /Users/kennethreitz/Library/Mobile Documents/com~apple~CloudDocs/repos/kr/pipenv/test
+
+Locate the virtualenv:
+
+    $ pipenv --venv
+    /Users/kennethreitz/.local/share/virtualenvs/test-Skyy4vre
+
+Locate the Python interpreter:
+
+    $ pipenv --py
+    /Users/kennethreitz/.local/share/virtualenvs/test-Skyy4vre/bin/python
+
+Install packages:
+
+    $ pipenv install
+    Creating a virtualenv for this project...
+    ...
+    No package provided, installing all dependencies.
+    Virtualenv location: /Users/kennethreitz/.local/share/virtualenvs/test-EJkjoYts
+    Installing dependencies from Pipfile.lock...
+    ...
+
+    To activate this project's virtualenv, run the following:
+    $ pipenv shell
+
+Installing from git:
+
+You can install packages with pipenv from git and other version control systems using URLs formatted according to the following rule:
+
+    <vcs_type>+<scheme>://<location>/<user_or_organization>/<repository>@<branch_or_tag>#<package_name>
+
+The only optional section is the `@<branch_or_tag>` section.  When using git over SSH, you may use the shorthand vcs and scheme alias `git+git@<location>:<user_or_organization>/<repository>@<branch_or_tag>#<package_name>`. Note that this is translated to `git+ssh://git@<location>` when parsed.
+
+Valid values for `<vcs_type>` include `git`, `bzr`, `svn`, and `hg`.  Valid values for `<scheme>` include `http,`, `https`, `ssh`, and `file`.  In specific cases you also have access to other schemes: `svn` may be combined with `svn` as a scheme, and `bzr` can be combined with `sftp` and `lp`.
+
+Note that it is **strongly recommended** that you install any version-controlled dependencies in editable mode, using `pipenv install -e`, in order to ensure that dependency resolution can be performed with an up to date copy of the repository each time it is performed, and that it includes all known dependencies.
+
+Below is an example usage which installs the git repository located at `https://github.com/requests/requests.git` from tag `v2.19.1` as package name `requests`:
+
+    $ pipenv install -e git+https://github.com/requests/requests.git@v2.19#egg=requests
+    Creating a Pipfile for this project...
+    Installing -e git+https://github.com/requests/requests.git@v2.19.1#egg=requests...
+    [...snipped...]
+    Adding -e git+https://github.com/requests/requests.git@v2.19.1#egg=requests to Pipfile's [packages]...
+    [...]
+
+You can read more about [pip's implementation of vcs support here](https://pip.pypa.io/en/stable/reference/pip_install/#vcs-support).
+
+Install a dev dependency:
+
+    $ pipenv install pytest --dev
+    Installing pytest...
+    ...
+    Adding pytest to Pipfile's [dev-packages]...
+
+Show a dependency graph:
+
+    $ pipenv graph
+    requests==2.18.4
+      - certifi [required: >=2017.4.17, installed: 2017.7.27.1]
+      - chardet [required: >=3.0.2,<3.1.0, installed: 3.0.4]
+      - idna [required: >=2.5,<2.7, installed: 2.6]
+      - urllib3 [required: <1.23,>=1.21.1, installed: 1.22]
+
+Generate a lockfile:
+
+    $ pipenv lock
+    Assuring all dependencies from Pipfile are installed...
+    Locking [dev-packages] dependencies...
+    Locking [packages] dependencies...
+    Note: your project now has only default [packages] installed.
+    To install [dev-packages], run: $ pipenv install --dev
+
+Install all dev dependencies:
+
+    $ pipenv install --dev
+    Pipfile found at /Users/kennethreitz/repos/kr/pip2/test/Pipfile. Considering this to be the project home.
+    Pipfile.lock out of date, updating...
+    Assuring all dependencies from Pipfile are installed...
+    Locking [dev-packages] dependencies...
+    Locking [packages] dependencies...
+
+Uninstall everything:
+
+    $ pipenv uninstall --all
+    No package provided, un-installing all dependencies.
+    Found 25 installed package(s), purging...
+    ...
+    Environment now purged and fresh!
+
+Use the shell:
+
+    $ pipenv shell
+    Loading .env environment variables…
+    Launching subshell in virtual environment. Type 'exit' or 'Ctrl+D' to return.
+    $ ▯
+
+☤ Documentation
+---------------
+
+Documentation resides over at [pipenv.pypa.io](https://pipenv.pypa.io/en/latest/).
+
+
Index: env/Lib/site-packages/pipenv/__version__.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#     ___     ( )  ___      ___       __\r\n#   //   ) ) / / //   ) ) //___) ) //   ) ) ||  / /\r\n#  //___/ / / / //___/ / //       //   / /  || / /\r\n# //       / / //       ((____   //   / /   ||/ /\r\n__version__ = \"2020.5.28\"\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- env/Lib/site-packages/pipenv/__version__.py	(revision 7de091c5b19e7b06e80c151f7100df6d0f893820)
+++ env/Lib/site-packages/pipenv/__version__.py	(date 1591098437567)
@@ -2,4 +2,4 @@
 #   //   ) ) / / //   ) ) //___) ) //   ) ) ||  / /
 #  //___/ / / / //___/ / //       //   / /  || / /
 # //       / / //       ((____   //   / /   ||/ /
-__version__ = "2020.5.28"
+__version__ = "2020.6.2"
Index: env/Lib/site-packages/pipenv/core.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># -*- coding=utf-8 -*-\r\nfrom __future__ import absolute_import, print_function\r\n\r\nimport io\r\nimport json as simplejson\r\nimport logging\r\nimport os\r\nimport sys\r\nimport time\r\nimport warnings\r\n\r\nimport click\r\nimport six\r\n\r\nimport delegator\r\nimport dotenv\r\nimport pipfile\r\nimport vistir\r\n\r\nfrom click_completion import init as init_completion\r\n\r\nfrom . import environments, exceptions, pep508checker, progress\r\nfrom ._compat import decode_for_output, fix_utf8\r\nfrom .cmdparse import Script\r\nfrom .environments import (\r\n    PIP_EXISTS_ACTION, PIPENV_CACHE_DIR, PIPENV_COLORBLIND,\r\n    PIPENV_DEFAULT_PYTHON_VERSION, PIPENV_DONT_USE_PYENV, PIPENV_DONT_USE_ASDF,\r\n    PIPENV_HIDE_EMOJIS, PIPENV_MAX_SUBPROCESS, PIPENV_PYUP_API_KEY,\r\n    PIPENV_RESOLVE_VCS, PIPENV_SHELL_FANCY, PIPENV_SKIP_VALIDATION, PIPENV_YES,\r\n    SESSION_IS_INTERACTIVE, is_type_checking\r\n)\r\nfrom .patched import crayons\r\nfrom .project import Project\r\nfrom .utils import (\r\n    convert_deps_to_pip, create_spinner, download_file,\r\n    escape_grouped_arguments, find_python, find_windows_executable,\r\n    get_canonical_names, get_source_list, interrupt_handled_subprocess,\r\n    is_pinned, is_python_command, is_required_version, is_star, is_valid_url,\r\n    parse_indexes, pep423_name, prepare_pip_source_args, proper_case,\r\n    python_version, run_command, venv_resolve_deps\r\n)\r\n\r\n\r\nif is_type_checking():\r\n    from typing import Dict, List, Optional, Union, Text\r\n    from pipenv.vendor.requirementslib.models.requirements import Requirement\r\n    TSourceDict = Dict[Text, Union[Text, bool]]\r\n\r\n\r\n# Packages that should be ignored later.\r\nBAD_PACKAGES = (\r\n    \"distribute\",\r\n    \"packaging\",\r\n    \"pip\",\r\n    \"pkg-resources\",\r\n    \"setuptools\",\r\n    \"wheel\",\r\n)\r\n\r\nFIRST_PACKAGES = (\"cython\",)\r\n# Are we using the default Python?\r\nUSING_DEFAULT_PYTHON = True\r\nif not PIPENV_HIDE_EMOJIS:\r\n    now = time.localtime()\r\n    # Halloween easter-egg.\r\n    if ((now.tm_mon == 10) and (now.tm_mday == 30)) or (\r\n        (now.tm_mon == 10) and (now.tm_mday == 31)\r\n    ):\r\n        INSTALL_LABEL = \"\uD83C\uDF83   \"\r\n    # Christmas easter-egg.\r\n    elif ((now.tm_mon == 12) and (now.tm_mday == 24)) or (\r\n        (now.tm_mon == 12) and (now.tm_mday == 25)\r\n    ):\r\n        INSTALL_LABEL = \"\uD83C\uDF85   \"\r\n    else:\r\n        INSTALL_LABEL = \"\uD83D\uDC0D   \"\r\n    INSTALL_LABEL2 = crayons.normal(\"☤  \", bold=True)\r\n    STARTING_LABEL = \"    \"\r\nelse:\r\n    INSTALL_LABEL = \"   \"\r\n    INSTALL_LABEL2 = \"   \"\r\n    STARTING_LABEL = \"   \"\r\n# Enable shell completion.\r\ninit_completion()\r\n# Disable colors, for the color blind and others who do not prefer colors.\r\nif PIPENV_COLORBLIND:\r\n    crayons.disable()\r\n\r\n\r\ndef which(command, location=None, allow_global=False):\r\n    if not allow_global and location is None:\r\n        if project.virtualenv_exists:\r\n            location = project.virtualenv_location\r\n        else:\r\n            location = os.environ.get(\"VIRTUAL_ENV\", None)\r\n    if not (location and os.path.exists(location)) and not allow_global:\r\n        raise RuntimeError(\"location not created nor specified\")\r\n\r\n    version_str = \"python{0}\".format(\".\".join([str(v) for v in sys.version_info[:2]]))\r\n    is_python = command in (\"python\", os.path.basename(sys.executable), version_str)\r\n    if not allow_global:\r\n        if os.name == \"nt\":\r\n            p = find_windows_executable(os.path.join(location, \"Scripts\"), command)\r\n        else:\r\n            p = os.path.join(location, \"bin\", command)\r\n    else:\r\n        if is_python:\r\n            p = sys.executable\r\n    if not os.path.exists(p):\r\n        if is_python:\r\n            p = sys.executable or system_which(\"python\")\r\n        else:\r\n            p = system_which(command)\r\n    return p\r\n\r\n\r\nproject = Project(which=which)\r\n\r\n\r\ndef do_clear():\r\n    click.echo(crayons.white(fix_utf8(\"Clearing caches…\"), bold=True))\r\n    try:\r\n        from pip._internal import locations\r\n    except ImportError:  # pip 9.\r\n        from pip import locations\r\n\r\n    try:\r\n        vistir.path.rmtree(PIPENV_CACHE_DIR, onerror=vistir.path.handle_remove_readonly)\r\n        vistir.path.rmtree(\r\n            locations.USER_CACHE_DIR, onerror=vistir.path.handle_remove_readonly\r\n        )\r\n    except OSError as e:\r\n        # Ignore FileNotFoundError. This is needed for Python 2.7.\r\n        import errno\r\n\r\n        if e.errno == errno.ENOENT:\r\n            pass\r\n        raise\r\n\r\n\r\ndef load_dot_env():\r\n    \"\"\"Loads .env file into sys.environ.\"\"\"\r\n    if not environments.PIPENV_DONT_LOAD_ENV:\r\n        # If the project doesn't exist yet, check current directory for a .env file\r\n        project_directory = project.project_directory or \".\"\r\n        dotenv_file = environments.PIPENV_DOTENV_LOCATION or os.sep.join(\r\n            [project_directory, \".env\"]\r\n        )\r\n\r\n        if os.path.isfile(dotenv_file):\r\n            click.echo(\r\n                crayons.normal(fix_utf8(\"Loading .env environment variables…\"), bold=True),\r\n                err=True,\r\n            )\r\n        else:\r\n            if environments.PIPENV_DOTENV_LOCATION:\r\n                click.echo(\r\n                    \"{0}: file {1}={2} does not exist!!\\n{3}\".format(\r\n                        crayons.red(\"Warning\", bold=True),\r\n                        crayons.normal(\"PIPENV_DOTENV_LOCATION\", bold=True),\r\n                        crayons.normal(environments.PIPENV_DOTENV_LOCATION, bold=True),\r\n                        crayons.red(\"Not loading environment variables.\", bold=True),\r\n                    ),\r\n                    err=True,\r\n                )\r\n        dotenv.load_dotenv(dotenv_file, override=True)\r\n        six.moves.reload_module(environments)\r\n\r\n\r\ndef add_to_path(p):\r\n    \"\"\"Adds a given path to the PATH.\"\"\"\r\n    if p not in os.environ[\"PATH\"]:\r\n        os.environ[\"PATH\"] = \"{0}{1}{2}\".format(p, os.pathsep, os.environ[\"PATH\"])\r\n\r\n\r\ndef cleanup_virtualenv(bare=True):\r\n    \"\"\"Removes the virtualenv directory from the system.\"\"\"\r\n    if not bare:\r\n        click.echo(crayons.red(\"Environment creation aborted.\"))\r\n    try:\r\n        # Delete the virtualenv.\r\n        vistir.path.rmtree(project.virtualenv_location)\r\n    except OSError as e:\r\n        click.echo(\r\n            \"{0} An error occurred while removing {1}!\".format(\r\n                crayons.red(\"Error: \", bold=True),\r\n                crayons.green(project.virtualenv_location),\r\n            ),\r\n            err=True,\r\n        )\r\n        click.echo(crayons.blue(e), err=True)\r\n\r\n\r\ndef import_requirements(r=None, dev=False):\r\n    from .patched.notpip._vendor import requests as pip_requests\r\n    from .vendor.pip_shims.shims import parse_requirements\r\n\r\n    # Parse requirements.txt file with Pip's parser.\r\n    # Pip requires a `PipSession` which is a subclass of requests.Session.\r\n    # Since we're not making any network calls, it's initialized to nothing.\r\n    if r:\r\n        assert os.path.isfile(r)\r\n    # Default path, if none is provided.\r\n    if r is None:\r\n        r = project.requirements_location\r\n    with open(r, \"r\") as f:\r\n        contents = f.read()\r\n    indexes = []\r\n    trusted_hosts = []\r\n    # Find and add extra indexes.\r\n    for line in contents.split(\"\\n\"):\r\n        line_indexes, _trusted_hosts, _ = parse_indexes(line.strip())\r\n        indexes.extend(line_indexes)\r\n        trusted_hosts.extend(_trusted_hosts)\r\n    indexes = sorted(set(indexes))\r\n    trusted_hosts = sorted(set(trusted_hosts))\r\n    reqs = [f for f in parse_requirements(r, session=pip_requests)]\r\n    for package in reqs:\r\n        if package.name not in BAD_PACKAGES:\r\n            if package.link is not None:\r\n                package_string = (\r\n                    \"-e {0}\".format(package.link)\r\n                    if package.editable\r\n                    else str(package.link)\r\n                )\r\n                project.add_package_to_pipfile(package_string, dev=dev)\r\n            else:\r\n                project.add_package_to_pipfile(str(package.req), dev=dev)\r\n    for index in indexes:\r\n        trusted = index in trusted_hosts\r\n        project.add_index_to_pipfile(index, verify_ssl=trusted)\r\n    project.recase_pipfile()\r\n\r\n\r\ndef ensure_environment():\r\n    # Skip this on Windows…\r\n    if os.name != \"nt\":\r\n        if \"LANG\" not in os.environ:\r\n            click.echo(\r\n                \"{0}: the environment variable {1} is not set!\"\r\n                \"\\nWe recommend setting this in {2} (or equivalent) for \"\r\n                \"proper expected behavior.\".format(\r\n                    crayons.red(\"Warning\", bold=True),\r\n                    crayons.normal(\"LANG\", bold=True),\r\n                    crayons.green(\"~/.profile\"),\r\n                ),\r\n                err=True,\r\n            )\r\n\r\n\r\ndef import_from_code(path=\".\"):\r\n    from pipreqs import pipreqs\r\n\r\n    rs = []\r\n    try:\r\n        for r in pipreqs.get_all_imports(\r\n            path, encoding=\"utf-8\", extra_ignore_dirs=[\".venv\"]\r\n        ):\r\n            if r not in BAD_PACKAGES:\r\n                rs.append(r)\r\n        pkg_names = pipreqs.get_pkg_names(rs)\r\n        return [proper_case(r) for r in pkg_names]\r\n\r\n    except Exception:\r\n        return []\r\n\r\n\r\ndef ensure_pipfile(validate=True, skip_requirements=False, system=False):\r\n    \"\"\"Creates a Pipfile for the project, if it doesn't exist.\"\"\"\r\n    from .environments import PIPENV_VIRTUALENV\r\n\r\n    # Assert Pipfile exists.\r\n    python = which(\"python\") if not (USING_DEFAULT_PYTHON or system) else None\r\n    if project.pipfile_is_empty:\r\n        # Show an error message and exit if system is passed and no pipfile exists\r\n        if system and not PIPENV_VIRTUALENV:\r\n            raise exceptions.PipenvOptionsError(\r\n                \"--system\",\r\n                \"--system is intended to be used for pre-existing Pipfile \"\r\n                \"installation, not installation of specific packages. Aborting.\"\r\n            )\r\n        # If there's a requirements file, but no Pipfile…\r\n        if project.requirements_exists and not skip_requirements:\r\n            click.echo(\r\n                crayons.normal(\r\n                    fix_utf8(\"requirements.txt found, instead of Pipfile! Converting…\"),\r\n                    bold=True,\r\n                )\r\n            )\r\n            # Create a Pipfile…\r\n            project.create_pipfile(python=python)\r\n            with create_spinner(\"Importing requirements...\") as sp:\r\n                # Import requirements.txt.\r\n                try:\r\n                    import_requirements()\r\n                except Exception:\r\n                    sp.fail(environments.PIPENV_SPINNER_FAIL_TEXT.format(\"Failed...\"))\r\n                else:\r\n                    sp.ok(environments.PIPENV_SPINNER_OK_TEXT.format(\"Success!\"))\r\n            # Warn the user of side-effects.\r\n            click.echo(\r\n                u\"{0}: Your {1} now contains pinned versions, if your {2} did. \\n\"\r\n                \"We recommend updating your {1} to specify the {3} version, instead.\"\r\n                \"\".format(\r\n                    crayons.red(\"Warning\", bold=True),\r\n                    crayons.normal(\"Pipfile\", bold=True),\r\n                    crayons.normal(\"requirements.txt\", bold=True),\r\n                    crayons.normal('\"*\"', bold=True),\r\n                )\r\n            )\r\n        else:\r\n            click.echo(\r\n                crayons.normal(fix_utf8(\"Creating a Pipfile for this project…\"), bold=True),\r\n                err=True,\r\n            )\r\n            # Create the pipfile if it doesn't exist.\r\n            project.create_pipfile(python=python)\r\n    # Validate the Pipfile's contents.\r\n    if validate and project.virtualenv_exists and not PIPENV_SKIP_VALIDATION:\r\n        # Ensure that Pipfile is using proper casing.\r\n        p = project.parsed_pipfile\r\n        changed = project.ensure_proper_casing()\r\n        # Write changes out to disk.\r\n        if changed:\r\n            click.echo(\r\n                crayons.normal(u\"Fixing package names in Pipfile…\", bold=True), err=True\r\n            )\r\n            project.write_toml(p)\r\n\r\n\r\ndef find_a_system_python(line):\r\n    \"\"\"Find a Python installation from a given line.\r\n\r\n    This tries to parse the line in various of ways:\r\n\r\n    * Looks like an absolute path? Use it directly.\r\n    * Looks like a py.exe call? Use py.exe to get the executable.\r\n    * Starts with \"py\" something? Looks like a python command. Try to find it\r\n      in PATH, and use it directly.\r\n    * Search for \"python\" and \"pythonX.Y\" executables in PATH to find a match.\r\n    * Nothing fits, return None.\r\n    \"\"\"\r\n\r\n    from .vendor.pythonfinder import Finder\r\n    finder = Finder(system=False, global_search=True)\r\n    if not line:\r\n        return next(iter(finder.find_all_python_versions()), None)\r\n    # Use the windows finder executable\r\n    if (line.startswith(\"py \") or line.startswith(\"py.exe \")) and os.name == \"nt\":\r\n        line = line.split(\" \", 1)[1].lstrip(\"-\")\r\n    python_entry = find_python(finder, line)\r\n    return python_entry\r\n\r\n\r\ndef ensure_python(three=None, python=None):\r\n    # Runtime import is necessary due to the possibility that the environments module may have been reloaded.\r\n    from .environments import PIPENV_PYTHON, PIPENV_YES\r\n\r\n    if PIPENV_PYTHON and python is False and three is None:\r\n        python = PIPENV_PYTHON\r\n\r\n    def abort(msg=''):\r\n        click.echo(\r\n            \"{0}\\nYou can specify specific versions of Python with:\\n{1}\".format(\r\n                crayons.red(msg),\r\n                crayons.red(\r\n                    \"$ pipenv --python {0}\".format(\r\n                        os.sep.join((\"path\", \"to\", \"python\"))\r\n                    )\r\n                )\r\n            ),\r\n            err=True,\r\n        )\r\n        sys.exit(1)\r\n\r\n    global USING_DEFAULT_PYTHON\r\n    USING_DEFAULT_PYTHON = three is None and not python\r\n    # Find out which python is desired.\r\n    if not python:\r\n        python = convert_three_to_python(three, python)\r\n    if not python:\r\n        python = project.required_python_version\r\n    if not python:\r\n        python = PIPENV_DEFAULT_PYTHON_VERSION\r\n    path_to_python = find_a_system_python(python)\r\n    if environments.is_verbose():\r\n        click.echo(u\"Using python: {0}\".format(python), err=True)\r\n        click.echo(u\"Path to python: {0}\".format(path_to_python), err=True)\r\n    if not path_to_python and python is not None:\r\n        # We need to install Python.\r\n        click.echo(\r\n            u\"{0}: Python {1} {2}\".format(\r\n                crayons.red(\"Warning\", bold=True),\r\n                crayons.blue(python),\r\n                fix_utf8(\"was not found on your system…\"),\r\n            ),\r\n            err=True,\r\n        )\r\n        # check for python installers\r\n        from .installers import Pyenv, Asdf, InstallerError, InstallerNotFound\r\n\r\n        # prefer pyenv if both pyenv and asdf are installed as it's\r\n        # dedicated to python installs so probably the preferred\r\n        # method of the user for new python installs.\r\n        installer = None\r\n        if not PIPENV_DONT_USE_PYENV:\r\n            try:\r\n                installer = Pyenv()\r\n            except InstallerNotFound:\r\n                pass\r\n        if installer is None and not PIPENV_DONT_USE_ASDF:\r\n            try:\r\n                installer = Asdf()\r\n            except InstallerNotFound:\r\n                pass\r\n\r\n        if not installer:\r\n            abort(\"Neither 'pyenv' nor 'asdf' could be found to install Python.\")\r\n        else:\r\n            if SESSION_IS_INTERACTIVE or PIPENV_YES:\r\n                try:\r\n                    version = installer.find_version_to_install(python)\r\n                except ValueError:\r\n                    abort()\r\n                except InstallerError as e:\r\n                    abort('Something went wrong while installing Python:\\n{}'.format(e.err))\r\n                s = \"{0} {1} {2}\".format(\r\n                    \"Would you like us to install\",\r\n                    crayons.green(\"CPython {0}\".format(version)),\r\n                    \"with {0}?\".format(installer),\r\n                )\r\n                # Prompt the user to continue…\r\n                if not (PIPENV_YES or click.confirm(s, default=True)):\r\n                    abort()\r\n                else:\r\n                    # Tell the user we're installing Python.\r\n                    click.echo(\r\n                        u\"{0} {1} {2} {3}{4}\".format(\r\n                            crayons.normal(u\"Installing\", bold=True),\r\n                            crayons.green(u\"CPython {0}\".format(version), bold=True),\r\n                            crayons.normal(u\"with {0}\".format(installer.cmd), bold=True),\r\n                            crayons.normal(u\"(this may take a few minutes)\"),\r\n                            crayons.normal(fix_utf8(\"…\"), bold=True),\r\n                        )\r\n                    )\r\n                    with create_spinner(\"Installing python...\") as sp:\r\n                        try:\r\n                            c = installer.install(version)\r\n                        except InstallerError as e:\r\n                            sp.fail(environments.PIPENV_SPINNER_FAIL_TEXT.format(\r\n                                \"Failed...\")\r\n                            )\r\n                            click.echo(fix_utf8(\"Something went wrong…\"), err=True)\r\n                            click.echo(crayons.blue(e.err), err=True)\r\n                        else:\r\n                            sp.ok(environments.PIPENV_SPINNER_OK_TEXT.format(\"Success!\"))\r\n                            # Print the results, in a beautiful blue…\r\n                            click.echo(crayons.blue(c.out), err=True)\r\n                            # Clear the pythonfinder caches\r\n                            from .vendor.pythonfinder import Finder\r\n                            finder = Finder(system=False, global_search=True)\r\n                            finder.find_python_version.cache_clear()\r\n                            finder.find_all_python_versions.cache_clear()\r\n                    # Find the newly installed Python, hopefully.\r\n                    version = str(version)\r\n                    path_to_python = find_a_system_python(version)\r\n                    try:\r\n                        assert python_version(path_to_python) == version\r\n                    except AssertionError:\r\n                        click.echo(\r\n                            \"{0}: The Python you just installed is not available on your {1}, apparently.\"\r\n                            \"\".format(\r\n                                crayons.red(\"Warning\", bold=True),\r\n                                crayons.normal(\"PATH\", bold=True),\r\n                            ),\r\n                            err=True,\r\n                        )\r\n                        sys.exit(1)\r\n    return path_to_python\r\n\r\n\r\ndef ensure_virtualenv(three=None, python=None, site_packages=None, pypi_mirror=None):\r\n    \"\"\"Creates a virtualenv, if one doesn't exist.\"\"\"\r\n    from .environments import PIPENV_USE_SYSTEM\r\n\r\n    def abort():\r\n        sys.exit(1)\r\n\r\n    global USING_DEFAULT_PYTHON\r\n    if not project.virtualenv_exists:\r\n        try:\r\n            # Ensure environment variables are set properly.\r\n            ensure_environment()\r\n            # Ensure Python is available.\r\n            python = ensure_python(three=three, python=python)\r\n            if python is not None and not isinstance(python, six.string_types):\r\n                python = python.path.as_posix()\r\n            # Create the virtualenv.\r\n            # Abort if --system (or running in a virtualenv).\r\n            if PIPENV_USE_SYSTEM:\r\n                click.echo(\r\n                    crayons.red(\r\n                        \"You are attempting to re–create a virtualenv that \"\r\n                        \"Pipenv did not create. Aborting.\"\r\n                    )\r\n                )\r\n                sys.exit(1)\r\n            do_create_virtualenv(\r\n                python=python, site_packages=site_packages, pypi_mirror=pypi_mirror\r\n            )\r\n        except KeyboardInterrupt:\r\n            # If interrupted, cleanup the virtualenv.\r\n            cleanup_virtualenv(bare=False)\r\n            sys.exit(1)\r\n    # If --three, --two, or --python were passed…\r\n    elif (python) or (three is not None) or (site_packages is not None):\r\n        USING_DEFAULT_PYTHON = False\r\n        # Ensure python is installed before deleting existing virtual env\r\n        python = ensure_python(three=three, python=python)\r\n        if python is not None and not isinstance(python, six.string_types):\r\n            python = python.path.as_posix()\r\n\r\n        click.echo(crayons.red(\"Virtualenv already exists!\"), err=True)\r\n        # If VIRTUAL_ENV is set, there is a possibility that we are\r\n        # going to remove the active virtualenv that the user cares\r\n        # about, so confirm first.\r\n        if \"VIRTUAL_ENV\" in os.environ:\r\n            if not (\r\n                PIPENV_YES or click.confirm(\"Remove existing virtualenv?\", default=True)\r\n            ):\r\n                abort()\r\n        click.echo(\r\n            crayons.normal(fix_utf8(\"Removing existing virtualenv…\"), bold=True), err=True\r\n        )\r\n        # Remove the virtualenv.\r\n        cleanup_virtualenv(bare=True)\r\n        # Call this function again.\r\n        ensure_virtualenv(\r\n            three=three,\r\n            python=python,\r\n            site_packages=site_packages,\r\n            pypi_mirror=pypi_mirror,\r\n        )\r\n\r\n\r\ndef ensure_project(\r\n    three=None,\r\n    python=None,\r\n    validate=True,\r\n    system=False,\r\n    warn=True,\r\n    site_packages=None,\r\n    deploy=False,\r\n    skip_requirements=False,\r\n    pypi_mirror=None,\r\n    clear=False,\r\n):\r\n    \"\"\"Ensures both Pipfile and virtualenv exist for the project.\"\"\"\r\n    from .environments import PIPENV_USE_SYSTEM\r\n\r\n    # Clear the caches, if appropriate.\r\n    if clear:\r\n        print(\"clearing\")\r\n        sys.exit(1)\r\n\r\n    # Automatically use an activated virtualenv.\r\n    if PIPENV_USE_SYSTEM:\r\n        system = True\r\n    if not project.pipfile_exists and deploy:\r\n        raise exceptions.PipfileNotFound\r\n    # Fail if working under /\r\n    if not project.name:\r\n        click.echo(\r\n            \"{0}: Pipenv is not intended to work under the root directory, \"\r\n            \"please choose another path.\".format(crayons.red(\"ERROR\")),\r\n            err=True\r\n        )\r\n        sys.exit(1)\r\n    # Skip virtualenv creation when --system was used.\r\n    if not system:\r\n        ensure_virtualenv(\r\n            three=three,\r\n            python=python,\r\n            site_packages=site_packages,\r\n            pypi_mirror=pypi_mirror,\r\n        )\r\n        if warn:\r\n            # Warn users if they are using the wrong version of Python.\r\n            if project.required_python_version:\r\n                path_to_python = which(\"python\") or which(\"py\")\r\n                if path_to_python and project.required_python_version not in (\r\n                    python_version(path_to_python) or \"\"\r\n                ):\r\n                    click.echo(\r\n                        \"{0}: Your Pipfile requires {1} {2}, \"\r\n                        \"but you are using {3} ({4}).\".format(\r\n                            crayons.red(\"Warning\", bold=True),\r\n                            crayons.normal(\"python_version\", bold=True),\r\n                            crayons.blue(project.required_python_version),\r\n                            crayons.blue(python_version(path_to_python) or \"unknown\"),\r\n                            crayons.green(shorten_path(path_to_python)),\r\n                        ),\r\n                        err=True,\r\n                    )\r\n                    click.echo(\r\n                        \"  {0} and rebuilding the virtual environment \"\r\n                        \"may resolve the issue.\".format(crayons.green(\"$ pipenv --rm\")),\r\n                        err=True,\r\n                    )\r\n                    if not deploy:\r\n                        click.echo(\r\n                            \"  {0} will surely fail.\"\r\n                            \"\".format(crayons.red(\"$ pipenv check\")),\r\n                            err=True,\r\n                        )\r\n                    else:\r\n                        raise exceptions.DeployException\r\n    # Ensure the Pipfile exists.\r\n    ensure_pipfile(\r\n        validate=validate, skip_requirements=skip_requirements, system=system\r\n    )\r\n\r\n\r\ndef shorten_path(location, bold=False):\r\n    \"\"\"Returns a visually shorter representation of a given system path.\"\"\"\r\n    original = location\r\n    short = os.sep.join(\r\n        [s[0] if len(s) > (len(\"2long4\")) else s for s in location.split(os.sep)]\r\n    )\r\n    short = short.split(os.sep)\r\n    short[-1] = original.split(os.sep)[-1]\r\n    if bold:\r\n        short[-1] = str(crayons.normal(short[-1], bold=True))\r\n    return os.sep.join(short)\r\n\r\n\r\n# return short\r\ndef do_where(virtualenv=False, bare=True):\r\n    \"\"\"Executes the where functionality.\"\"\"\r\n    if not virtualenv:\r\n        if not project.pipfile_exists:\r\n            click.echo(\r\n                \"No Pipfile present at project home. Consider running \"\r\n                \"{0} first to automatically generate a Pipfile for you.\"\r\n                \"\".format(crayons.green(\"`pipenv install`\")),\r\n                err=True,\r\n            )\r\n            return\r\n        location = project.pipfile_location\r\n        # Shorten the virtual display of the path to the virtualenv.\r\n        if not bare:\r\n            location = shorten_path(location)\r\n            click.echo(\r\n                \"Pipfile found at {0}.\\n  Considering this to be the project home.\"\r\n                \"\".format(crayons.green(location)),\r\n                err=True,\r\n            )\r\n        else:\r\n            click.echo(project.project_directory)\r\n    else:\r\n        location = project.virtualenv_location\r\n        if not bare:\r\n            click.echo(\r\n                \"Virtualenv location: {0}\".format(crayons.green(location)), err=True\r\n            )\r\n        else:\r\n            click.echo(location)\r\n\r\n\r\ndef _cleanup_procs(procs, failed_deps_queue, retry=True):\r\n    while not procs.empty():\r\n        c = procs.get()\r\n        if not c.blocking:\r\n            c.block()\r\n        failed = False\r\n        if c.return_code != 0:\r\n            failed = True\r\n        if \"Ignoring\" in c.out:\r\n            click.echo(crayons.yellow(c.out.strip()))\r\n        elif environments.is_verbose():\r\n            click.echo(crayons.blue(c.out.strip() or c.err.strip()))\r\n        # The Installation failed…\r\n        if failed:\r\n            # If there is a mismatch in installed locations or the install fails\r\n            # due to wrongful disabling of pep517, we should allow for\r\n            # additional passes at installation\r\n            if \"does not match installed location\" in c.err:\r\n                project.environment.expand_egg_links()\r\n                click.echo(\"{0}\".format(\r\n                    crayons.yellow(\r\n                        \"Failed initial installation: Failed to overwrite existing \"\r\n                        \"package, likely due to path aliasing. Expanding and trying \"\r\n                        \"again!\"\r\n                    )\r\n                ))\r\n                dep = c.dep.copy()\r\n                dep.use_pep517 = True\r\n            elif \"Disabling PEP 517 processing is invalid\" in c.err:\r\n                dep = c.dep.copy()\r\n                dep.use_pep517 = True\r\n            elif not retry:\r\n                # The Installation failed…\r\n                # We echo both c.out and c.err because pip returns error details on out.\r\n                err = c.err.strip().splitlines() if c.err else []\r\n                out = c.out.strip().splitlines() if c.out else []\r\n                err_lines = [line for message in [out, err] for line in message]\r\n                # Return the subprocess' return code.\r\n                raise exceptions.InstallError(c.dep.name, extra=err_lines)\r\n            else:\r\n                # Alert the user.\r\n                dep = c.dep.copy()\r\n                dep.use_pep517 = False\r\n                click.echo(\r\n                    \"{0} {1}! Will try again.\".format(\r\n                        crayons.red(\"An error occurred while installing\"),\r\n                        crayons.green(dep.as_line()),\r\n                    ), err=True\r\n                )\r\n            # Save the Failed Dependency for later.\r\n            failed_deps_queue.put(dep)\r\n\r\n\r\ndef batch_install(deps_list, procs, failed_deps_queue,\r\n                  requirements_dir, no_deps=True, ignore_hashes=False,\r\n                  allow_global=False, blocking=False, pypi_mirror=None,\r\n                  retry=True, sequential_deps=None):\r\n    from .vendor.requirementslib.models.utils import strip_extras_markers_from_requirement\r\n    if sequential_deps is None:\r\n        sequential_deps = []\r\n    failed = (not retry)\r\n    install_deps = not no_deps\r\n    if not failed:\r\n        label = INSTALL_LABEL if not PIPENV_HIDE_EMOJIS else \"\"\r\n    else:\r\n        label = INSTALL_LABEL2\r\n\r\n    deps_to_install = deps_list[:]\r\n    deps_to_install.extend(sequential_deps)\r\n    deps_to_install = [\r\n        dep for dep in deps_to_install if not project.environment.is_satisfied(dep)\r\n    ]\r\n    sequential_dep_names = [d.name for d in sequential_deps]\r\n\r\n    deps_list_bar = progress.bar(\r\n        deps_to_install, width=32,\r\n        label=label\r\n    )\r\n\r\n    trusted_hosts = []\r\n    # Install these because\r\n    for dep in deps_list_bar:\r\n        extra_indexes = []\r\n        if dep.req.req:\r\n            dep.req.req = strip_extras_markers_from_requirement(dep.req.req)\r\n        if dep.markers:\r\n            dep.markers = str(strip_extras_markers_from_requirement(dep.get_markers()))\r\n        # Install the module.\r\n        is_artifact = False\r\n        if dep.is_file_or_url and (dep.is_direct_url or any(\r\n            dep.req.uri.endswith(ext) for ext in [\"zip\", \"tar.gz\"]\r\n        )):\r\n            is_artifact = True\r\n        elif dep.is_vcs:\r\n            is_artifact = True\r\n        if not PIPENV_RESOLVE_VCS and is_artifact and not dep.editable:\r\n            install_deps = True\r\n            no_deps = False\r\n\r\n        with vistir.contextmanagers.temp_environ():\r\n            if not allow_global:\r\n                os.environ[\"PIP_USER\"] = vistir.compat.fs_str(\"0\")\r\n                if \"PYTHONHOME\" in os.environ:\r\n                    del os.environ[\"PYTHONHOME\"]\r\n            if \"GIT_CONFIG\" in os.environ and dep.is_vcs:\r\n                del os.environ[\"GIT_CONFIG\"]\r\n            use_pep517 = True\r\n            if failed and not dep.is_vcs:\r\n                use_pep517 = getattr(dep, \"use_pep517\", False)\r\n\r\n            c = pip_install(\r\n                dep,\r\n                ignore_hashes=any([ignore_hashes, dep.editable, dep.is_vcs]),\r\n                allow_global=allow_global,\r\n                no_deps=not install_deps,\r\n                block=any([dep.editable, dep.is_vcs, blocking]),\r\n                index=dep.index,\r\n                requirements_dir=requirements_dir,\r\n                pypi_mirror=pypi_mirror,\r\n                trusted_hosts=trusted_hosts,\r\n                extra_indexes=extra_indexes,\r\n                use_pep517=use_pep517,\r\n            )\r\n            c.dep = dep\r\n            # if dep.is_vcs or dep.editable:\r\n            is_sequential = sequential_deps and dep.name in sequential_dep_names\r\n            if is_sequential:\r\n                c.block()\r\n\r\n            procs.put(c)\r\n            if procs.full() or procs.qsize() == len(deps_list) or is_sequential:\r\n                _cleanup_procs(procs, failed_deps_queue, retry=retry)\r\n\r\n\r\ndef do_install_dependencies(\r\n    dev=False,\r\n    dev_only=False,\r\n    bare=False,\r\n    emit_requirements=False,\r\n    allow_global=False,\r\n    ignore_hashes=False,\r\n    skip_lock=False,\r\n    concurrent=True,\r\n    requirements_dir=None,\r\n    pypi_mirror=None,\r\n):\r\n    \"\"\"\"\r\n    Executes the install functionality.\r\n\r\n    If emit_requirements is True, simply spits out a requirements format to stdout.\r\n    \"\"\"\r\n\r\n    from six.moves import queue\r\n    if emit_requirements:\r\n        bare = True\r\n    # Load the lockfile if it exists, or if dev_only is being used.\r\n    if skip_lock or not project.lockfile_exists:\r\n        if not bare:\r\n            click.echo(\r\n                crayons.normal(fix_utf8(\"Installing dependencies from Pipfile…\"), bold=True)\r\n            )\r\n            # skip_lock should completely bypass the lockfile (broken in 4dac1676)\r\n            lockfile = project.get_or_create_lockfile(from_pipfile=True)\r\n    else:\r\n        lockfile = project.get_or_create_lockfile()\r\n        if not bare:\r\n            click.echo(\r\n                crayons.normal(\r\n                    fix_utf8(\"Installing dependencies from Pipfile.lock ({0})…\".format(\r\n                        lockfile[\"_meta\"].get(\"hash\", {}).get(\"sha256\")[-6:]\r\n                    )),\r\n                    bold=True,\r\n                )\r\n            )\r\n    # Allow pip to resolve dependencies when in skip-lock mode.\r\n    no_deps = not skip_lock  # skip_lock true, no_deps False, pip resolves deps\r\n    dev = dev or dev_only\r\n    deps_list = list(lockfile.get_requirements(dev=dev, only=dev_only))\r\n    if emit_requirements:\r\n        index_args = prepare_pip_source_args(get_source_list(pypi_mirror=pypi_mirror, project=project))\r\n        index_args = \" \".join(index_args).replace(\" -\", \"\\n-\")\r\n        deps = [\r\n            req.as_line(sources=False, include_hashes=False) for req in deps_list\r\n        ]\r\n        click.echo(index_args)\r\n        click.echo(\r\n            \"\\n\".join(sorted(deps))\r\n        )\r\n        sys.exit(0)\r\n\r\n    if concurrent:\r\n        nprocs = PIPENV_MAX_SUBPROCESS\r\n    else:\r\n        nprocs = 1\r\n    procs = queue.Queue(maxsize=nprocs)\r\n    failed_deps_queue = queue.Queue()\r\n    if skip_lock:\r\n        ignore_hashes = True\r\n    editable_or_vcs_deps = [dep for dep in deps_list if (dep.editable or dep.vcs)]\r\n    normal_deps = [dep for dep in deps_list if not (dep.editable or dep.vcs)]\r\n    install_kwargs = {\r\n        \"no_deps\": no_deps, \"ignore_hashes\": ignore_hashes, \"allow_global\": allow_global,\r\n        \"blocking\": not concurrent, \"pypi_mirror\": pypi_mirror,\r\n        \"sequential_deps\": editable_or_vcs_deps\r\n    }\r\n\r\n    batch_install(\r\n        normal_deps, procs, failed_deps_queue, requirements_dir, **install_kwargs\r\n    )\r\n\r\n    if not procs.empty():\r\n        _cleanup_procs(procs, failed_deps_queue)\r\n\r\n    # click.echo(crayons.normal(\r\n    #     decode_for_output(\"Installing editable and vcs dependencies…\"), bold=True\r\n    # ))\r\n\r\n    # install_kwargs.update({\"blocking\": True})\r\n    # # XXX: All failed and editable/vcs deps should be installed in sequential mode!\r\n    # procs = queue.Queue(maxsize=1)\r\n    # batch_install(\r\n    #     editable_or_vcs_deps, procs, failed_deps_queue, requirements_dir,\r\n    #     **install_kwargs\r\n    # )\r\n\r\n    # Iterate over the hopefully-poorly-packaged dependencies…\r\n    if not failed_deps_queue.empty():\r\n        click.echo(\r\n            crayons.normal(fix_utf8(\"Installing initially failed dependencies…\"), bold=True)\r\n        )\r\n        retry_list = []\r\n        while not failed_deps_queue.empty():\r\n            failed_dep = failed_deps_queue.get()\r\n            retry_list.append(failed_dep)\r\n        install_kwargs.update({\"retry\": False})\r\n        batch_install(\r\n            retry_list, procs, failed_deps_queue, requirements_dir, **install_kwargs\r\n        )\r\n    if not procs.empty():\r\n        _cleanup_procs(procs, failed_deps_queue, retry=False)\r\n\r\n\r\ndef convert_three_to_python(three, python):\r\n    \"\"\"Converts a Three flag into a Python flag, and raises customer warnings\r\n    in the process, if needed.\r\n    \"\"\"\r\n    if not python:\r\n        if three is False:\r\n            return \"2\"\r\n\r\n        elif three is True:\r\n            return \"3\"\r\n\r\n    else:\r\n        return python\r\n\r\n\r\ndef do_create_virtualenv(python=None, site_packages=None, pypi_mirror=None):\r\n    \"\"\"Creates a virtualenv.\"\"\"\r\n\r\n    click.echo(\r\n        crayons.normal(fix_utf8(\"Creating a virtualenv for this project…\"), bold=True), err=True\r\n    )\r\n    click.echo(\r\n        u\"Pipfile: {0}\".format(crayons.red(project.pipfile_location, bold=True)),\r\n        err=True,\r\n    )\r\n\r\n    # Default to using sys.executable, if Python wasn't provided.\r\n    using_string = u\"Using\"\r\n    if not python:\r\n        python = sys.executable\r\n        using_string = \"Using default python from\"\r\n    click.echo(\r\n        u\"{0} {1} {3} {2}\".format(\r\n            crayons.normal(using_string, bold=True),\r\n            crayons.red(python, bold=True),\r\n            crayons.normal(fix_utf8(\"to create virtualenv…\"), bold=True),\r\n            crayons.green(\"({0})\".format(python_version(python))),\r\n        ),\r\n        err=True,\r\n    )\r\n\r\n    cmd = [\r\n        vistir.compat.Path(sys.executable).absolute().as_posix(),\r\n        \"-m\",\r\n        \"virtualenv\",\r\n        \"--prompt=({0}) \".format(project.name),\r\n        \"--python={0}\".format(python),\r\n        project.get_location_for_virtualenv(),\r\n    ]\r\n\r\n    # Pass site-packages flag to virtualenv, if desired…\r\n    if site_packages:\r\n        click.echo(\r\n            crayons.normal(fix_utf8(\"Making site-packages available…\"), bold=True), err=True\r\n        )\r\n        cmd.append(\"--system-site-packages\")\r\n\r\n    if pypi_mirror:\r\n        pip_config = {\"PIP_INDEX_URL\": vistir.misc.fs_str(pypi_mirror)}\r\n    else:\r\n        pip_config = {}\r\n\r\n    # Actually create the virtualenv.\r\n    error = None\r\n    with create_spinner(u\"Creating virtual environment...\") as sp:\r\n        with interrupt_handled_subprocess(cmd, combine_stderr=False, env=pip_config) as c:\r\n            click.echo(crayons.blue(u\"{0}\".format(c.out)), err=True)\r\n            if c.returncode != 0:\r\n                error = c.err if environments.is_verbose() else exceptions.prettify_exc(c.err)\r\n                sp.fail(environments.PIPENV_SPINNER_FAIL_TEXT.format(u\"Failed creating virtual environment\"))\r\n            else:\r\n                sp.green.ok(environments.PIPENV_SPINNER_OK_TEXT.format(u\"Successfully created virtual environment!\"))\r\n    if error is not None:\r\n        raise exceptions.VirtualenvCreationException(\r\n            extra=crayons.red(\"{0}\".format(error))\r\n        )\r\n\r\n    # Associate project directory with the environment.\r\n    # This mimics Pew's \"setproject\".\r\n    project_file_name = os.path.join(project.virtualenv_location, \".project\")\r\n    with open(project_file_name, \"w\") as f:\r\n        f.write(vistir.misc.fs_str(project.project_directory))\r\n    from .environment import Environment\r\n    sources = project.pipfile_sources\r\n    project._environment = Environment(\r\n        prefix=project.get_location_for_virtualenv(),\r\n        is_venv=True,\r\n        sources=sources,\r\n        pipfile=project.parsed_pipfile,\r\n        project=project\r\n    )\r\n    project._environment.add_dist(\"pipenv\")\r\n    # Say where the virtualenv is.\r\n    do_where(virtualenv=True, bare=False)\r\n\r\n\r\ndef parse_download_fname(fname, name):\r\n    fname, fextension = os.path.splitext(fname)\r\n    if fextension == \".whl\":\r\n        fname = \"-\".join(fname.split(\"-\")[:-3])\r\n    if fname.endswith(\".tar\"):\r\n        fname, _ = os.path.splitext(fname)\r\n    # Substring out package name (plus dash) from file name to get version.\r\n    version = fname[len(name) + 1 :]\r\n    # Ignore implicit post releases in version number.\r\n    if \"-\" in version and version.split(\"-\")[1].isdigit():\r\n        version = version.split(\"-\")[0]\r\n    return version\r\n\r\n\r\ndef get_downloads_info(names_map, section):\r\n    from .vendor.requirementslib.models.requirements import Requirement\r\n\r\n    info = []\r\n    p = project.parsed_pipfile\r\n    for fname in os.listdir(project.download_location):\r\n        # Get name from filename mapping.\r\n        name = Requirement.from_line(names_map[fname]).name\r\n        # Get the version info from the filenames.\r\n        version = parse_download_fname(fname, name)\r\n        # Get the hash of each file.\r\n        cmd = '{0} hash \"{1}\"'.format(\r\n            escape_grouped_arguments(which_pip()),\r\n            os.sep.join([project.download_location, fname]),\r\n        )\r\n        c = delegator.run(cmd)\r\n        hash = c.out.split(\"--hash=\")[1].strip()\r\n        # Verify we're adding the correct version from Pipfile\r\n        # and not one from a dependency.\r\n        specified_version = p[section].get(name, \"\")\r\n        if is_required_version(version, specified_version):\r\n            info.append(dict(name=name, version=version, hash=hash))\r\n    return info\r\n\r\n\r\ndef overwrite_dev(prod, dev):\r\n    dev_keys = set(list(dev.keys()))\r\n    prod_keys = set(list(prod.keys()))\r\n    for pkg in dev_keys & prod_keys:\r\n        dev[pkg] = prod[pkg]\r\n    return dev\r\n\r\n\r\ndef do_lock(\r\n    ctx=None,\r\n    system=False,\r\n    clear=False,\r\n    pre=False,\r\n    keep_outdated=False,\r\n    write=True,\r\n    pypi_mirror=None,\r\n):\r\n    \"\"\"Executes the freeze functionality.\"\"\"\r\n\r\n    cached_lockfile = {}\r\n    if not pre:\r\n        pre = project.settings.get(\"allow_prereleases\")\r\n    if keep_outdated:\r\n        if not project.lockfile_exists:\r\n            raise exceptions.PipenvOptionsError(\r\n                \"--keep-outdated\", ctx=ctx,\r\n                message=\"Pipfile.lock must exist to use --keep-outdated!\"\r\n            )\r\n        cached_lockfile = project.lockfile_content\r\n    # Create the lockfile.\r\n    lockfile = project._lockfile\r\n    # Cleanup lockfile.\r\n    for section in (\"default\", \"develop\"):\r\n        for k, v in lockfile[section].copy().items():\r\n            if not hasattr(v, \"keys\"):\r\n                del lockfile[section][k]\r\n    # Ensure that develop inherits from default.\r\n    dev_packages = project.dev_packages.copy()\r\n    dev_packages = overwrite_dev(project.packages, dev_packages)\r\n    # Resolve dev-package dependencies, with pip-tools.\r\n    for is_dev in [True, False]:\r\n        pipfile_section = \"dev-packages\" if is_dev else \"packages\"\r\n        if project.pipfile_exists:\r\n            packages = project.parsed_pipfile.get(pipfile_section, {})\r\n        else:\r\n            packages = getattr(project, pipfile_section.replace(\"-\", \"_\"))\r\n\r\n        if write:\r\n            # Alert the user of progress.\r\n            click.echo(\r\n                u\"{0} {1} {2}\".format(\r\n                    crayons.normal(u\"Locking\"),\r\n                    crayons.red(u\"[{0}]\".format(pipfile_section.replace(\"_\", \"-\"))),\r\n                    crayons.normal(fix_utf8(\"dependencies…\")),\r\n                ),\r\n                err=True,\r\n            )\r\n\r\n        # Mutates the lockfile\r\n        venv_resolve_deps(\r\n            packages,\r\n            which=which,\r\n            project=project,\r\n            dev=is_dev,\r\n            clear=clear,\r\n            pre=pre,\r\n            allow_global=system,\r\n            pypi_mirror=pypi_mirror,\r\n            pipfile=packages,\r\n            lockfile=lockfile,\r\n            keep_outdated=keep_outdated\r\n        )\r\n\r\n    # Support for --keep-outdated…\r\n    if keep_outdated:\r\n        from pipenv.vendor.packaging.utils import canonicalize_name\r\n        for section_name, section in (\r\n            (\"default\", project.packages),\r\n            (\"develop\", project.dev_packages),\r\n        ):\r\n            for package_specified in section.keys():\r\n                if not is_pinned(section[package_specified]):\r\n                    canonical_name = canonicalize_name(package_specified)\r\n                    if canonical_name in cached_lockfile[section_name]:\r\n                        lockfile[section_name][canonical_name] = cached_lockfile[\r\n                            section_name\r\n                        ][canonical_name].copy()\r\n            for key in [\"default\", \"develop\"]:\r\n                packages = set(cached_lockfile[key].keys())\r\n                new_lockfile = set(lockfile[key].keys())\r\n                missing = packages - new_lockfile\r\n                for missing_pkg in missing:\r\n                    lockfile[key][missing_pkg] = cached_lockfile[key][missing_pkg].copy()\r\n    # Overwrite any develop packages with default packages.\r\n    lockfile[\"develop\"].update(overwrite_dev(lockfile.get(\"default\", {}), lockfile[\"develop\"]))\r\n    if write:\r\n        project.write_lockfile(lockfile)\r\n        click.echo(\r\n            \"{0}\".format(\r\n                crayons.normal(\r\n                    \"Updated Pipfile.lock ({0})!\".format(\r\n                        lockfile[\"_meta\"].get(\"hash\", {}).get(\"sha256\")[-6:]\r\n                    ),\r\n                    bold=True,\r\n                )\r\n            ),\r\n            err=True,\r\n        )\r\n    else:\r\n        return lockfile\r\n\r\n\r\ndef do_purge(bare=False, downloads=False, allow_global=False):\r\n    \"\"\"Executes the purge functionality.\"\"\"\r\n\r\n    if downloads:\r\n        if not bare:\r\n            click.echo(crayons.normal(fix_utf8(\"Clearing out downloads directory…\"), bold=True))\r\n        vistir.path.rmtree(project.download_location)\r\n        return\r\n\r\n    # Remove comments from the output, if any.\r\n    installed = set([\r\n        pep423_name(pkg.project_name) for pkg in project.environment.get_installed_packages()\r\n    ])\r\n    bad_pkgs = set([pep423_name(pkg) for pkg in BAD_PACKAGES])\r\n    # Remove setuptools, pip, etc from targets for removal\r\n    to_remove = installed - bad_pkgs\r\n\r\n    # Skip purging if there is no packages which needs to be removed\r\n    if not to_remove:\r\n        if not bare:\r\n            click.echo(\"Found 0 installed package, skip purging.\")\r\n            click.echo(crayons.green(\"Environment now purged and fresh!\"))\r\n        return installed\r\n\r\n    if not bare:\r\n        click.echo(\r\n            fix_utf8(\"Found {0} installed package(s), purging…\".format(len(to_remove)))\r\n        )\r\n\r\n    command = \"{0} uninstall {1} -y\".format(\r\n        escape_grouped_arguments(which_pip(allow_global=allow_global)),\r\n        \" \".join(to_remove),\r\n    )\r\n    if environments.is_verbose():\r\n        click.echo(\"$ {0}\".format(command))\r\n    c = delegator.run(command)\r\n    if c.return_code != 0:\r\n        raise exceptions.UninstallError(installed, command, c.out + c.err, c.return_code)\r\n    if not bare:\r\n        click.echo(crayons.blue(c.out))\r\n        click.echo(crayons.green(\"Environment now purged and fresh!\"))\r\n    return installed\r\n\r\n\r\ndef do_init(\r\n    dev=False,\r\n    dev_only=False,\r\n    emit_requirements=False,\r\n    allow_global=False,\r\n    ignore_pipfile=False,\r\n    skip_lock=False,\r\n    system=False,\r\n    concurrent=True,\r\n    deploy=False,\r\n    pre=False,\r\n    keep_outdated=False,\r\n    requirements_dir=None,\r\n    pypi_mirror=None,\r\n):\r\n    \"\"\"Executes the init functionality.\"\"\"\r\n    from .environments import (\r\n        PIPENV_VIRTUALENV, PIPENV_DEFAULT_PYTHON_VERSION, PIPENV_PYTHON, PIPENV_USE_SYSTEM\r\n    )\r\n    python = None\r\n    if PIPENV_PYTHON is not None:\r\n        python = PIPENV_PYTHON\r\n    elif PIPENV_DEFAULT_PYTHON_VERSION is not None:\r\n        python = PIPENV_DEFAULT_PYTHON_VERSION\r\n\r\n    if not system and not PIPENV_USE_SYSTEM:\r\n        if not project.virtualenv_exists:\r\n            try:\r\n                do_create_virtualenv(python=python, three=None, pypi_mirror=pypi_mirror)\r\n            except KeyboardInterrupt:\r\n                cleanup_virtualenv(bare=False)\r\n                sys.exit(1)\r\n    # Ensure the Pipfile exists.\r\n    if not deploy:\r\n        ensure_pipfile(system=system)\r\n    if not requirements_dir:\r\n        requirements_dir = vistir.path.create_tracked_tempdir(\r\n            suffix=\"-requirements\", prefix=\"pipenv-\"\r\n        )\r\n    # Write out the lockfile if it doesn't exist, but not if the Pipfile is being ignored\r\n    if (project.lockfile_exists and not ignore_pipfile) and not skip_lock:\r\n        old_hash = project.get_lockfile_hash()\r\n        new_hash = project.calculate_pipfile_hash()\r\n        if new_hash != old_hash:\r\n            if deploy:\r\n                click.echo(\r\n                    crayons.red(\r\n                        \"Your Pipfile.lock ({0}) is out of date. Expected: ({1}).\".format(\r\n                            old_hash[-6:], new_hash[-6:]\r\n                        )\r\n                    )\r\n                )\r\n                raise exceptions.DeployException\r\n                sys.exit(1)\r\n            elif (system or allow_global) and not (PIPENV_VIRTUALENV):\r\n                click.echo(\r\n                    crayons.red(fix_utf8(\r\n                        \"Pipfile.lock ({0}) out of date, but installation \"\r\n                        \"uses {1}… re-building lockfile must happen in \"\r\n                        \"isolation. Please rebuild lockfile in a virtualenv. \"\r\n                        \"Continuing anyway…\".format(\r\n                            crayons.white(old_hash[-6:]), crayons.white(\"--system\")\r\n                        )),\r\n                        bold=True,\r\n                    ),\r\n                    err=True,\r\n                )\r\n            else:\r\n                if old_hash:\r\n                    msg = fix_utf8(\"Pipfile.lock ({0}) out of date, updating to ({1})…\")\r\n                else:\r\n                    msg = fix_utf8(\"Pipfile.lock is corrupted, replaced with ({1})…\")\r\n                click.echo(\r\n                    crayons.red(msg.format(old_hash[-6:], new_hash[-6:]), bold=True),\r\n                    err=True,\r\n                )\r\n                do_lock(\r\n                    system=system,\r\n                    pre=pre,\r\n                    keep_outdated=keep_outdated,\r\n                    write=True,\r\n                    pypi_mirror=pypi_mirror,\r\n                )\r\n    # Write out the lockfile if it doesn't exist.\r\n    if not project.lockfile_exists and not skip_lock:\r\n        # Unless we're in a virtualenv not managed by pipenv, abort if we're\r\n        # using the system's python.\r\n        if (system or allow_global) and not (PIPENV_VIRTUALENV):\r\n            raise exceptions.PipenvOptionsError(\r\n                \"--system\",\r\n                \"--system is intended to be used for Pipfile installation, \"\r\n                \"not installation of specific packages. Aborting.\\n\"\r\n                \"See also: --deploy flag.\"\r\n            )\r\n        else:\r\n            click.echo(\r\n                crayons.normal(fix_utf8(\"Pipfile.lock not found, creating…\"), bold=True),\r\n                err=True,\r\n            )\r\n            do_lock(\r\n                system=system,\r\n                pre=pre,\r\n                keep_outdated=keep_outdated,\r\n                write=True,\r\n                pypi_mirror=pypi_mirror,\r\n            )\r\n    do_install_dependencies(\r\n        dev=dev,\r\n        dev_only=dev_only,\r\n        emit_requirements=emit_requirements,\r\n        allow_global=allow_global,\r\n        skip_lock=skip_lock,\r\n        concurrent=concurrent,\r\n        requirements_dir=requirements_dir,\r\n        pypi_mirror=pypi_mirror,\r\n    )\r\n\r\n    # Hint the user what to do to activate the virtualenv.\r\n    if not allow_global and not deploy and \"PIPENV_ACTIVE\" not in os.environ:\r\n        click.echo(\r\n            \"To activate this project's virtualenv, run {0}.\\n\"\r\n            \"Alternatively, run a command \"\r\n            \"inside the virtualenv with {1}.\".format(\r\n                crayons.red(\"pipenv shell\"), crayons.red(\"pipenv run\")\r\n            )\r\n        )\r\n\r\n\r\ndef get_pip_args(\r\n    pre=False,  # type: bool\r\n    verbose=False,  # type: bool,\r\n    upgrade=False,  # type: bool,\r\n    require_hashes=False,  # type: bool,\r\n    no_build_isolation=False,  # type: bool,\r\n    no_use_pep517=False,  # type: bool,\r\n    no_deps=False,  # type: bool,\r\n    selective_upgrade=False,  # type: bool\r\n    src_dir=None,  # type: Optional[str]\r\n):\r\n    # type: (...) -> List[str]\r\n    from .vendor.packaging.version import parse as parse_version\r\n    arg_map = {\r\n        \"pre\": [\"--pre\"],\r\n        \"verbose\": [\"--verbose\"],\r\n        \"upgrade\": [\"--upgrade\"],\r\n        \"require_hashes\": [\"--require-hashes\"],\r\n        \"no_build_isolation\": [\"--no-build-isolation\"],\r\n        \"no_use_pep517\": [],\r\n        \"no_deps\": [\"--no-deps\"],\r\n        \"selective_upgrade\": [\r\n            \"--upgrade-strategy=only-if-needed\",\r\n            \"--exists-action={0}\".format(PIP_EXISTS_ACTION or \"i\")\r\n        ],\r\n        \"src_dir\": src_dir,\r\n    }\r\n    if project.environment.pip_version >= parse_version(\"19.0\"):\r\n        arg_map[\"no_use_pep517\"].append(\"--no-use-pep517\")\r\n    if project.environment.pip_version < parse_version(\"19.1\"):\r\n        arg_map[\"no_use_pep517\"].append(\"--no-build-isolation\")\r\n    arg_set = []\r\n    for key in arg_map.keys():\r\n        if key in locals() and locals().get(key):\r\n            arg_set.extend(arg_map.get(key))\r\n        elif key == \"selective_upgrade\" and not locals().get(key):\r\n            arg_set.append(\"--exists-action=i\")\r\n    return list(vistir.misc.dedup(arg_set))\r\n\r\n\r\ndef get_requirement_line(\r\n    requirement,  # type: Requirement\r\n    src_dir=None,  # type: Optional[str]\r\n    include_hashes=True,  # type: bool\r\n    format_for_file=False,  # type: bool\r\n):\r\n    # type: (...) -> Union[List[str], str]\r\n    line = None\r\n    if requirement.vcs or requirement.is_file_or_url:\r\n        if src_dir and requirement.line_instance.wheel_kwargs:\r\n            requirement.line_instance._wheel_kwargs.update({\r\n                \"src_dir\": src_dir\r\n            })\r\n        requirement.line_instance.vcsrepo\r\n        line = requirement.line_instance.line\r\n        if requirement.line_instance.markers:\r\n            line = '{0}; {1}'.format(line, requirement.line_instance.markers)\r\n            if not format_for_file:\r\n                line = '\"{0}\"'.format(line)\r\n        if requirement.editable:\r\n            if not format_for_file:\r\n                return [\"-e\", line]\r\n            return '-e {0}'.format(line)\r\n        if not format_for_file:\r\n            return [line]\r\n        return line\r\n    return requirement.as_line(include_hashes=include_hashes, as_list=not format_for_file)\r\n\r\n\r\ndef write_requirement_to_file(\r\n    requirement,  # type: Requirement\r\n    requirements_dir=None,  # type: Optional[str]\r\n    src_dir=None,  # type: Optional[str]\r\n    include_hashes=True  # type: bool\r\n):\r\n    # type: (...) -> str\r\n    if not requirements_dir:\r\n        requirements_dir = vistir.path.create_tracked_tempdir(\r\n            prefix=\"pipenv\", suffix=\"requirements\")\r\n    line = requirement.line_instance.get_line(\r\n        with_prefix=True, with_hashes=include_hashes, with_markers=True, as_list=False\r\n    )\r\n\r\n    f = vistir.compat.NamedTemporaryFile(\r\n        prefix=\"pipenv-\", suffix=\"-requirement.txt\", dir=requirements_dir,\r\n        delete=False\r\n    )\r\n    if environments.is_verbose():\r\n        click.echo(\r\n            \"Writing supplied requirement line to temporary file: {0!r}\".format(line),\r\n            err=True\r\n        )\r\n    f.write(vistir.misc.to_bytes(line))\r\n    r = f.name\r\n    f.close()\r\n    return r\r\n\r\n\r\ndef pip_install(\r\n    requirement=None,\r\n    r=None,\r\n    allow_global=False,\r\n    ignore_hashes=False,\r\n    no_deps=None,\r\n    block=True,\r\n    index=None,\r\n    pre=False,\r\n    selective_upgrade=False,\r\n    requirements_dir=None,\r\n    extra_indexes=None,\r\n    pypi_mirror=None,\r\n    trusted_hosts=None,\r\n    use_pep517=True\r\n):\r\n    piplogger = logging.getLogger(\"pipenv.patched.notpip._internal.commands.install\")\r\n    src_dir = None\r\n    if not trusted_hosts:\r\n        trusted_hosts = []\r\n\r\n    trusted_hosts.extend(os.environ.get(\"PIP_TRUSTED_HOSTS\", []))\r\n    if not allow_global:\r\n        src_dir = os.getenv(\"PIP_SRC\", os.getenv(\"PIP_SRC_DIR\", project.virtualenv_src_location))\r\n    else:\r\n        src_dir = os.getenv(\"PIP_SRC\", os.getenv(\"PIP_SRC_DIR\"))\r\n    if requirement:\r\n        if requirement.editable or not requirement.hashes:\r\n            ignore_hashes = True\r\n        elif not (requirement.is_vcs or requirement.editable or requirement.vcs):\r\n            ignore_hashes = False\r\n    line = None\r\n    # Try installing for each source in project.sources.\r\n    if not index and requirement.index:\r\n        index = requirement.index\r\n    if index and not extra_indexes:\r\n        extra_indexes = list(project.sources)\r\n    if requirement and requirement.vcs or requirement.editable:\r\n        requirement.index = None\r\n        # Install dependencies when a package is a non-editable VCS dependency.\r\n        # Don't specify a source directory when using --system.\r\n        if not requirement.editable and no_deps is not True:\r\n            # Leave this off becauase old lockfiles don't have all deps included\r\n            # TODO: When can it be turned back on?\r\n            no_deps = False\r\n        elif requirement.editable and no_deps is None:\r\n            no_deps = True\r\n\r\n    r = write_requirement_to_file(\r\n        requirement, requirements_dir=requirements_dir, src_dir=src_dir,\r\n        include_hashes=not ignore_hashes\r\n    )\r\n    sources = get_source_list(\r\n        index, extra_indexes=extra_indexes, trusted_hosts=trusted_hosts,\r\n        pypi_mirror=pypi_mirror\r\n    )\r\n    if r:\r\n        with io.open(r, \"r\") as fh:\r\n            if \"--hash\" not in fh.read():\r\n                ignore_hashes = True\r\n    if environments.is_verbose():\r\n        piplogger.setLevel(logging.WARN)\r\n        if requirement:\r\n            click.echo(\r\n                crayons.normal(\"Installing {0!r}\".format(requirement.name), bold=True),\r\n                err=True,\r\n            )\r\n\r\n    pip_command = [which_pip(allow_global=allow_global), \"install\"]\r\n    pip_args = get_pip_args(\r\n        pre=pre, verbose=environments.is_verbose(), upgrade=True,\r\n        selective_upgrade=selective_upgrade, no_use_pep517=not use_pep517,\r\n        no_deps=no_deps, require_hashes=not ignore_hashes,\r\n    )\r\n    pip_command.extend(pip_args)\r\n    if r:\r\n        pip_command.extend([\"-r\", vistir.path.normalize_path(r)])\r\n    elif line:\r\n        pip_command.extend(line)\r\n    pip_command.extend(prepare_pip_source_args(sources))\r\n    if environments.is_verbose():\r\n        click.echo(\"$ {0}\".format(pip_command), err=True)\r\n    cache_dir = vistir.compat.Path(PIPENV_CACHE_DIR)\r\n    DEFAULT_EXISTS_ACTION = \"w\"\r\n    if selective_upgrade:\r\n        DEFAULT_EXISTS_ACTION = \"i\"\r\n    exists_action = vistir.misc.fs_str(PIP_EXISTS_ACTION or DEFAULT_EXISTS_ACTION)\r\n    pip_config = {\r\n        \"PIP_CACHE_DIR\": vistir.misc.fs_str(cache_dir.as_posix()),\r\n        \"PIP_WHEEL_DIR\": vistir.misc.fs_str(cache_dir.joinpath(\"wheels\").as_posix()),\r\n        \"PIP_DESTINATION_DIR\": vistir.misc.fs_str(\r\n            cache_dir.joinpath(\"pkgs\").as_posix()\r\n        ),\r\n        \"PIP_EXISTS_ACTION\": exists_action,\r\n        \"PATH\": vistir.misc.fs_str(os.environ.get(\"PATH\")),\r\n    }\r\n    if src_dir:\r\n        if environments.is_verbose():\r\n            click.echo(\"Using source directory: {0!r}\".format(src_dir), err=True)\r\n        pip_config.update(\r\n            {\"PIP_SRC\": vistir.misc.fs_str(src_dir)}\r\n        )\r\n    cmd = Script.parse(pip_command)\r\n    pip_command = cmd.cmdify()\r\n    c = None\r\n    c = delegator.run(pip_command, block=block, env=pip_config)\r\n    c.env = pip_config\r\n    return c\r\n\r\n\r\ndef pip_download(package_name):\r\n    cache_dir = vistir.compat.Path(PIPENV_CACHE_DIR)\r\n    pip_config = {\r\n        \"PIP_CACHE_DIR\": vistir.misc.fs_str(cache_dir.as_posix()),\r\n        \"PIP_WHEEL_DIR\": vistir.misc.fs_str(cache_dir.joinpath(\"wheels\").as_posix()),\r\n        \"PIP_DESTINATION_DIR\": vistir.misc.fs_str(\r\n            cache_dir.joinpath(\"pkgs\").as_posix()\r\n        ),\r\n    }\r\n    for source in project.sources:\r\n        cmd = '{0} download \"{1}\" -i {2} -d {3}'.format(\r\n            escape_grouped_arguments(which_pip()),\r\n            package_name,\r\n            source[\"url\"],\r\n            project.download_location,\r\n        )\r\n        c = delegator.run(cmd, env=pip_config)\r\n        if c.return_code == 0:\r\n            break\r\n\r\n    return c\r\n\r\n\r\ndef fallback_which(command, location=None, allow_global=False, system=False):\r\n    \"\"\"\r\n    A fallback implementation of the `which` utility command that relies exclusively on\r\n    searching the path for commands.\r\n\r\n    :param str command: The command to search for, optional\r\n    :param str location: The search location to prioritize (prepend to path), defaults to None\r\n    :param bool allow_global: Whether to search the global path, defaults to False\r\n    :param bool system: Whether to use the system python instead of pipenv's python, defaults to False\r\n    :raises ValueError: Raised if no command is provided\r\n    :raises TypeError: Raised if the command provided is not a string\r\n    :return: A path to the discovered command location\r\n    :rtype: str\r\n    \"\"\"\r\n\r\n    from .vendor.pythonfinder import Finder\r\n    if not command:\r\n        raise ValueError(\"fallback_which: Must provide a command to search for...\")\r\n    if not isinstance(command, six.string_types):\r\n        raise TypeError(\"Provided command must be a string, received {0!r}\".format(command))\r\n    global_search = system or allow_global\r\n    if location is None:\r\n        global_search = True\r\n    finder = Finder(system=False, global_search=global_search, path=location)\r\n    if is_python_command(command):\r\n        result = find_python(finder, command)\r\n        if result:\r\n            return result\r\n    result = finder.which(command)\r\n    if result:\r\n        return result.path.as_posix()\r\n    return \"\"\r\n\r\n\r\ndef which_pip(allow_global=False):\r\n    \"\"\"Returns the location of virtualenv-installed pip.\"\"\"\r\n\r\n    location = None\r\n    if \"VIRTUAL_ENV\" in os.environ:\r\n        location = os.environ[\"VIRTUAL_ENV\"]\r\n    if allow_global:\r\n        if location:\r\n            pip = which(\"pip\", location=location)\r\n            if pip:\r\n                return pip\r\n\r\n        for p in (\"pip\", \"pip3\", \"pip2\"):\r\n            where = system_which(p)\r\n            if where:\r\n                return where\r\n\r\n    pip = which(\"pip\")\r\n    if not pip:\r\n        pip = fallback_which(\"pip\", allow_global=allow_global, location=location)\r\n    return pip\r\n\r\n\r\ndef system_which(command, mult=False):\r\n    \"\"\"Emulates the system's which. Returns None if not found.\"\"\"\r\n    _which = \"which -a\" if not os.name == \"nt\" else \"where\"\r\n    os.environ = {\r\n        vistir.compat.fs_str(k): vistir.compat.fs_str(val)\r\n        for k, val in os.environ.items()\r\n    }\r\n    result = None\r\n    try:\r\n        c = delegator.run(\"{0} {1}\".format(_which, command))\r\n        try:\r\n            # Which Not found…\r\n            if c.return_code == 127:\r\n                click.echo(\r\n                    \"{}: the {} system utility is required for Pipenv to find Python installations properly.\"\r\n                    \"\\n  Please install it.\".format(\r\n                        crayons.red(\"Warning\", bold=True), crayons.red(_which)\r\n                    ),\r\n                    err=True,\r\n                )\r\n            assert c.return_code == 0\r\n        except AssertionError:\r\n            result = fallback_which(command, allow_global=True)\r\n    except TypeError:\r\n        if not result:\r\n            result = fallback_which(command, allow_global=True)\r\n    else:\r\n        if not result:\r\n            result = next(iter([c.out, c.err]), \"\").split(\"\\n\")\r\n            result = next(iter(result)) if not mult else result\r\n            return result\r\n        if not result:\r\n            result = fallback_which(command, allow_global=True)\r\n    result = [result] if mult else result\r\n    return result\r\n\r\n\r\ndef format_help(help):\r\n    \"\"\"Formats the help string.\"\"\"\r\n    help = help.replace(\"Options:\", str(crayons.normal(\"Options:\", bold=True)))\r\n    help = help.replace(\r\n        \"Usage: pipenv\", str(\"Usage: {0}\".format(crayons.normal(\"pipenv\", bold=True)))\r\n    )\r\n    help = help.replace(\"  check\", str(crayons.red(\"  check\", bold=True)))\r\n    help = help.replace(\"  clean\", str(crayons.red(\"  clean\", bold=True)))\r\n    help = help.replace(\"  graph\", str(crayons.red(\"  graph\", bold=True)))\r\n    help = help.replace(\"  install\", str(crayons.magenta(\"  install\", bold=True)))\r\n    help = help.replace(\"  lock\", str(crayons.green(\"  lock\", bold=True)))\r\n    help = help.replace(\"  open\", str(crayons.red(\"  open\", bold=True)))\r\n    help = help.replace(\"  run\", str(crayons.yellow(\"  run\", bold=True)))\r\n    help = help.replace(\"  shell\", str(crayons.yellow(\"  shell\", bold=True)))\r\n    help = help.replace(\"  sync\", str(crayons.green(\"  sync\", bold=True)))\r\n    help = help.replace(\"  uninstall\", str(crayons.magenta(\"  uninstall\", bold=True)))\r\n    help = help.replace(\"  update\", str(crayons.green(\"  update\", bold=True)))\r\n    additional_help = \"\"\"\r\nUsage Examples:\r\n   Create a new project using Python 3.7, specifically:\r\n   $ {1}\r\n\r\n   Remove project virtualenv (inferred from current directory):\r\n   $ {9}\r\n\r\n   Install all dependencies for a project (including dev):\r\n   $ {2}\r\n\r\n   Create a lockfile containing pre-releases:\r\n   $ {6}\r\n\r\n   Show a graph of your installed dependencies:\r\n   $ {4}\r\n\r\n   Check your installed dependencies for security vulnerabilities:\r\n   $ {7}\r\n\r\n   Install a local setup.py into your virtual environment/Pipfile:\r\n   $ {5}\r\n\r\n   Use a lower-level pip command:\r\n   $ {8}\r\n\r\nCommands:\"\"\".format(\r\n        crayons.red(\"pipenv --three\"),\r\n        crayons.red(\"pipenv --python 3.7\"),\r\n        crayons.red(\"pipenv install --dev\"),\r\n        crayons.red(\"pipenv lock\"),\r\n        crayons.red(\"pipenv graph\"),\r\n        crayons.red(\"pipenv install -e .\"),\r\n        crayons.red(\"pipenv lock --pre\"),\r\n        crayons.red(\"pipenv check\"),\r\n        crayons.red(\"pipenv run pip freeze\"),\r\n        crayons.red(\"pipenv --rm\"),\r\n    )\r\n    help = help.replace(\"Commands:\", additional_help)\r\n    return help\r\n\r\n\r\ndef format_pip_error(error):\r\n    error = error.replace(\"Expected\", str(crayons.green(\"Expected\", bold=True)))\r\n    error = error.replace(\"Got\", str(crayons.red(\"Got\", bold=True)))\r\n    error = error.replace(\r\n        \"THESE PACKAGES DO NOT MATCH THE HASHES FROM THE REQUIREMENTS FILE\",\r\n        str(\r\n            crayons.red(\r\n                \"THESE PACKAGES DO NOT MATCH THE HASHES FROM Pipfile.lock!\", bold=True\r\n            )\r\n        ),\r\n    )\r\n    error = error.replace(\r\n        \"someone may have tampered with them\",\r\n        str(crayons.red(\"someone may have tampered with them\")),\r\n    )\r\n    error = error.replace(\"option to pip install\", \"option to 'pipenv install'\")\r\n    return error\r\n\r\n\r\ndef format_pip_output(out, r=None):\r\n    def gen(out):\r\n        for line in out.split(\"\\n\"):\r\n            # Remove requirements file information from pip9 output.\r\n            if \"(from -r\" in line:\r\n                yield line[: line.index(\"(from -r\")]\r\n\r\n            else:\r\n                yield line\r\n\r\n    out = \"\\n\".join([l for l in gen(out)])\r\n    return out\r\n\r\n\r\ndef warn_in_virtualenv():\r\n    # Only warn if pipenv isn't already active.\r\n    if environments.is_in_virtualenv() and not environments.is_quiet():\r\n        click.echo(\r\n            \"{0}: Pipenv found itself running within a virtual environment, \"\r\n            \"so it will automatically use that environment, instead of \"\r\n            \"creating its own for any project. You can set \"\r\n            \"{1} to force pipenv to ignore that environment and create \"\r\n            \"its own instead. You can set {2} to suppress this \"\r\n            \"warning.\".format(\r\n                crayons.green(\"Courtesy Notice\"),\r\n                crayons.normal(\"PIPENV_IGNORE_VIRTUALENVS=1\", bold=True),\r\n                crayons.normal(\"PIPENV_VERBOSITY=-1\", bold=True),\r\n            ),\r\n            err=True,\r\n        )\r\n\r\n\r\ndef ensure_lockfile(keep_outdated=False, pypi_mirror=None):\r\n    \"\"\"Ensures that the lockfile is up-to-date.\"\"\"\r\n    if not keep_outdated:\r\n        keep_outdated = project.settings.get(\"keep_outdated\")\r\n    # Write out the lockfile if it doesn't exist, but not if the Pipfile is being ignored\r\n    if project.lockfile_exists:\r\n        old_hash = project.get_lockfile_hash()\r\n        new_hash = project.calculate_pipfile_hash()\r\n        if new_hash != old_hash:\r\n            click.echo(\r\n                crayons.red(\r\n                    fix_utf8(\"Pipfile.lock ({0}) out of date, updating to ({1})…\".format(\r\n                        old_hash[-6:], new_hash[-6:]\r\n                    )),\r\n                    bold=True,\r\n                ),\r\n                err=True,\r\n            )\r\n            do_lock(keep_outdated=keep_outdated, pypi_mirror=pypi_mirror)\r\n    else:\r\n        do_lock(keep_outdated=keep_outdated, pypi_mirror=pypi_mirror)\r\n\r\n\r\ndef do_py(system=False):\r\n    if not project.virtualenv_exists:\r\n        click.echo(\r\n            \"{}({}){}\".format(\r\n                crayons.red(\"No virtualenv has been created for this project \"),\r\n                crayons.white(project.project_directory, bold=True),\r\n                crayons.red(\" yet!\")\r\n            ),\r\n            err=True,\r\n        )\r\n        return\r\n\r\n    try:\r\n        click.echo(which(\"python\", allow_global=system))\r\n    except AttributeError:\r\n        click.echo(crayons.red(\"No project found!\"))\r\n\r\n\r\ndef do_outdated(pypi_mirror=None, pre=False, clear=False):\r\n    # TODO: Allow --skip-lock here?\r\n    from .vendor.requirementslib.models.requirements import Requirement\r\n    from .vendor.requirementslib.models.utils import get_version\r\n    from .vendor.packaging.utils import canonicalize_name\r\n    from .vendor.vistir.compat import Mapping\r\n    from collections import namedtuple\r\n\r\n    packages = {}\r\n    package_info = namedtuple(\"PackageInfo\", [\"name\", \"installed\", \"available\"])\r\n\r\n    installed_packages = project.environment.get_installed_packages()\r\n    outdated_packages = {\r\n        canonicalize_name(pkg.project_name): package_info\r\n        (pkg.project_name, pkg.parsed_version, pkg.latest_version)\r\n        for pkg in project.environment.get_outdated_packages()\r\n    }\r\n    reverse_deps = {\r\n        canonicalize_name(name): deps\r\n        for name, deps in project.environment.reverse_dependencies().items()\r\n    }\r\n    for result in installed_packages:\r\n        dep = Requirement.from_line(str(result.as_requirement()))\r\n        packages.update(dep.as_pipfile())\r\n    updated_packages = {}\r\n    lockfile = do_lock(clear=clear, pre=pre, write=False, pypi_mirror=pypi_mirror)\r\n    for section in (\"develop\", \"default\"):\r\n        for package in lockfile[section]:\r\n            try:\r\n                updated_packages[package] = lockfile[section][package][\"version\"]\r\n            except KeyError:\r\n                pass\r\n    outdated = []\r\n    skipped = []\r\n    for package in packages:\r\n        norm_name = pep423_name(package)\r\n        if norm_name in updated_packages:\r\n            if updated_packages[norm_name] != packages[package]:\r\n                outdated.append(\r\n                    package_info(package, updated_packages[norm_name], packages[package])\r\n                )\r\n            elif canonicalize_name(package) in outdated_packages:\r\n                skipped.append(outdated_packages[canonicalize_name(package)])\r\n    for package, old_version, new_version in skipped:\r\n        name_in_pipfile = project.get_package_name_in_pipfile(package)\r\n        pipfile_version_text = \"\"\r\n        required = \"\"\r\n        version = None\r\n        if name_in_pipfile:\r\n            version = get_version(project.packages[name_in_pipfile])\r\n            rdeps = reverse_deps.get(canonicalize_name(package))\r\n            if isinstance(rdeps, Mapping) and \"required\" in rdeps:\r\n                required = \" {0} required\".format(rdeps[\"required\"])\r\n            if version:\r\n                pipfile_version_text = \" ({0} set in Pipfile)\".format(version)\r\n            else:\r\n                pipfile_version_text = \" (Unpinned in Pipfile)\"\r\n        click.echo(\r\n            crayons.yellow(\r\n                \"Skipped Update of Package {0!s}: {1!s} installed,{2!s}{3!s}, \"\r\n                \"{4!s} available.\".format(\r\n                    package, old_version, required, pipfile_version_text, new_version\r\n                )\r\n            ), err=True\r\n        )\r\n    if not outdated:\r\n        click.echo(crayons.green(\"All packages are up to date!\", bold=True))\r\n        sys.exit(0)\r\n    for package, new_version, old_version in outdated:\r\n        click.echo(\r\n            \"Package {0!r} out-of-date: {1!r} installed, {2!r} available.\".format(\r\n                package, old_version, new_version\r\n            )\r\n        )\r\n    sys.exit(bool(outdated))\r\n\r\n\r\ndef do_install(\r\n    packages=False,\r\n    editable_packages=False,\r\n    index_url=False,\r\n    extra_index_url=False,\r\n    dev=False,\r\n    three=False,\r\n    python=False,\r\n    pypi_mirror=None,\r\n    system=False,\r\n    lock=True,\r\n    ignore_pipfile=False,\r\n    skip_lock=False,\r\n    requirementstxt=False,\r\n    sequential=False,\r\n    pre=False,\r\n    code=False,\r\n    deploy=False,\r\n    keep_outdated=False,\r\n    selective_upgrade=False,\r\n    site_packages=None,\r\n):\r\n    from .environments import PIPENV_VIRTUALENV, PIPENV_USE_SYSTEM\r\n    from .vendor.pip_shims.shims import PipError\r\n\r\n    requirements_directory = vistir.path.create_tracked_tempdir(\r\n        suffix=\"-requirements\", prefix=\"pipenv-\"\r\n    )\r\n    warnings.filterwarnings(\"default\", category=vistir.compat.ResourceWarning)\r\n    if selective_upgrade:\r\n        keep_outdated = True\r\n    packages = packages if packages else []\r\n    editable_packages = editable_packages if editable_packages else []\r\n    package_args = [p for p in packages if p] + [p for p in editable_packages if p]\r\n    skip_requirements = False\r\n    # Don't search for requirements.txt files if the user provides one\r\n    if requirementstxt or package_args or project.pipfile_exists:\r\n        skip_requirements = True\r\n    concurrent = not sequential\r\n    # Ensure that virtualenv is available and pipfile are available\r\n    ensure_project(\r\n        three=three,\r\n        python=python,\r\n        system=system,\r\n        warn=True,\r\n        deploy=deploy,\r\n        skip_requirements=skip_requirements,\r\n        pypi_mirror=pypi_mirror,\r\n        site_packages=site_packages,\r\n    )\r\n    # Don't attempt to install develop and default packages if Pipfile is missing\r\n    if not project.pipfile_exists and not (package_args or dev) and not code:\r\n        if not (ignore_pipfile or deploy):\r\n            raise exceptions.PipfileNotFound(project.path_to(\"Pipfile\"))\r\n        elif ((skip_lock and deploy) or ignore_pipfile) and not project.lockfile_exists:\r\n            raise exceptions.LockfileNotFound(project.path_to(\"Pipfile.lock\"))\r\n    # Load the --pre settings from the Pipfile.\r\n    if not pre:\r\n        pre = project.settings.get(\"allow_prereleases\")\r\n    if not keep_outdated:\r\n        keep_outdated = project.settings.get(\"keep_outdated\")\r\n    remote = requirementstxt and is_valid_url(requirementstxt)\r\n    # Warn and exit if --system is used without a pipfile.\r\n    if (system and package_args) and not (PIPENV_VIRTUALENV):\r\n        raise exceptions.SystemUsageError\r\n    # Automatically use an activated virtualenv.\r\n    if PIPENV_USE_SYSTEM:\r\n        system = True\r\n    # Check if the file is remote or not\r\n    if remote:\r\n        click.echo(\r\n            crayons.normal(\r\n                fix_utf8(\"Remote requirements file provided! Downloading…\"), bold=True\r\n            ),\r\n            err=True,\r\n        )\r\n        fd = vistir.path.create_tracked_tempfile(\r\n            prefix=\"pipenv-\", suffix=\"-requirement.txt\", dir=requirements_directory\r\n        )\r\n        temp_reqs = fd.name\r\n        requirements_url = requirementstxt\r\n        # Download requirements file\r\n        try:\r\n            download_file(requirements_url, temp_reqs)\r\n        except IOError:\r\n            fd.close()\r\n            os.unlink(temp_reqs)\r\n            click.echo(\r\n                crayons.red(\r\n                    u\"Unable to find requirements file at {0}.\".format(\r\n                        crayons.normal(requirements_url)\r\n                    )\r\n                ),\r\n                err=True,\r\n            )\r\n            sys.exit(1)\r\n        finally:\r\n            fd.close()\r\n        # Replace the url with the temporary requirements file\r\n        requirementstxt = temp_reqs\r\n        remote = True\r\n    if requirementstxt:\r\n        error, traceback = None, None\r\n        click.echo(\r\n            crayons.normal(\r\n                fix_utf8(\"Requirements file provided! Importing into Pipfile…\"), bold=True\r\n            ),\r\n            err=True,\r\n        )\r\n        try:\r\n            import_requirements(r=project.path_to(requirementstxt), dev=dev)\r\n        except (UnicodeDecodeError, PipError) as e:\r\n            # Don't print the temp file path if remote since it will be deleted.\r\n            req_path = requirements_url if remote else project.path_to(requirementstxt)\r\n            error = (\r\n                u\"Unexpected syntax in {0}. Are you sure this is a \"\r\n                \"requirements.txt style file?\".format(req_path)\r\n            )\r\n            traceback = e\r\n        except AssertionError as e:\r\n            error = (\r\n                u\"Requirements file doesn't appear to exist. Please ensure the file exists in your \"\r\n                \"project directory or you provided the correct path.\"\r\n            )\r\n            traceback = e\r\n        finally:\r\n            # If requirements file was provided by remote url delete the temporary file\r\n            if remote:\r\n                fd.close()  # Close for windows to allow file cleanup.\r\n                os.remove(temp_reqs)\r\n            if error and traceback:\r\n                click.echo(crayons.red(error))\r\n                click.echo(crayons.blue(str(traceback)), err=True)\r\n                sys.exit(1)\r\n    if code:\r\n        click.echo(\r\n            crayons.normal(fix_utf8(\"Discovering imports from local codebase…\"), bold=True)\r\n        )\r\n        for req in import_from_code(code):\r\n            click.echo(\"  Found {0}!\".format(crayons.green(req)))\r\n            project.add_package_to_pipfile(req)\r\n    # Allow more than one package to be provided.\r\n    package_args = [p for p in packages] + [\r\n        \"-e {0}\".format(pkg) for pkg in editable_packages\r\n    ]\r\n    # Support for --selective-upgrade.\r\n    # We should do this part first to make sure that we actually do selectively upgrade\r\n    # the items specified\r\n    if selective_upgrade:\r\n        from .vendor.requirementslib.models.requirements import Requirement\r\n\r\n        for i, package in enumerate(package_args[:]):\r\n            section = project.packages if not dev else project.dev_packages\r\n            package = Requirement.from_line(package)\r\n            package__name, package__val = package.pipfile_entry\r\n            try:\r\n                if not is_star(section[package__name]) and is_star(package__val):\r\n                    # Support for VCS dependencies.\r\n                    package_args[i] = convert_deps_to_pip(\r\n                        {package__name: section[package__name]}, project=project, r=False\r\n                    )[0]\r\n            except KeyError:\r\n                pass\r\n    # Install all dependencies, if none was provided.\r\n    # This basically ensures that we have a pipfile and lockfile, then it locks and\r\n    # installs from the lockfile\r\n    if not packages and not editable_packages:\r\n        # Update project settings with pre preference.\r\n        if pre:\r\n            project.update_settings({\"allow_prereleases\": pre})\r\n        do_init(\r\n            dev=dev,\r\n            allow_global=system,\r\n            ignore_pipfile=ignore_pipfile,\r\n            system=system,\r\n            skip_lock=skip_lock,\r\n            concurrent=concurrent,\r\n            deploy=deploy,\r\n            pre=pre,\r\n            requirements_dir=requirements_directory,\r\n            pypi_mirror=pypi_mirror,\r\n            keep_outdated=keep_outdated\r\n        )\r\n\r\n    # This is for if the user passed in dependencies, then we want to make sure we\r\n    else:\r\n        from .vendor.requirementslib.models.requirements import Requirement\r\n\r\n        # make a tuple of (display_name, entry)\r\n        pkg_list = packages + ['-e {0}'.format(pkg) for pkg in editable_packages]\r\n        if not system and not project.virtualenv_exists:\r\n            do_init(\r\n                dev=dev,\r\n                system=system,\r\n                allow_global=system,\r\n                concurrent=concurrent,\r\n                keep_outdated=keep_outdated,\r\n                requirements_dir=requirements_directory,\r\n                deploy=deploy,\r\n                pypi_mirror=pypi_mirror,\r\n                skip_lock=skip_lock,\r\n            )\r\n        pip_shims_module = os.environ.pop(\"PIP_SHIMS_BASE_MODULE\", None)\r\n        for pkg_line in pkg_list:\r\n            click.echo(\r\n                crayons.normal(\r\n                    fix_utf8(\"Installing {0}…\".format(crayons.green(pkg_line, bold=True))),\r\n                    bold=True,\r\n                )\r\n            )\r\n            # pip install:\r\n            with vistir.contextmanagers.temp_environ(), create_spinner(\"Installing...\") as sp:\r\n                if not system:\r\n                    os.environ[\"PIP_USER\"] = vistir.compat.fs_str(\"0\")\r\n                    if \"PYTHONHOME\" in os.environ:\r\n                        del os.environ[\"PYTHONHOME\"]\r\n                sp.text = \"Resolving {0}...\".format(pkg_line)\r\n                try:\r\n                    pkg_requirement = Requirement.from_line(pkg_line)\r\n                except ValueError as e:\r\n                    sp.write_err(vistir.compat.fs_str(\"{0}: {1}\".format(crayons.red(\"WARNING\"), e)))\r\n                    sp.red.fail(environments.PIPENV_SPINNER_FAIL_TEXT.format(\"Installation Failed\"))\r\n                    sys.exit(1)\r\n                if index_url:\r\n                    pkg_requirement.index = index_url\r\n                no_deps = False\r\n                sp.text = \"Installing...\"\r\n                try:\r\n                    sp.text = \"Installing {0}...\".format(pkg_requirement.name)\r\n                    if environments.is_verbose():\r\n                        sp.hide_and_write(\"Installing package: {0}\".format(pkg_requirement.as_line(include_hashes=False)))\r\n                    c = pip_install(\r\n                        pkg_requirement,\r\n                        ignore_hashes=True,\r\n                        allow_global=system,\r\n                        selective_upgrade=selective_upgrade,\r\n                        no_deps=no_deps,\r\n                        pre=pre,\r\n                        requirements_dir=requirements_directory,\r\n                        index=index_url,\r\n                        extra_indexes=extra_index_url,\r\n                        pypi_mirror=pypi_mirror,\r\n                    )\r\n                    if not c.ok:\r\n                        sp.write_err(\r\n                            u\"{0} An error occurred while installing {1}!\".format(\r\n                                crayons.red(u\"Error: \", bold=True), crayons.green(pkg_line)\r\n                            ),\r\n                        )\r\n                        sp.write_err(\r\n                            vistir.compat.fs_str(u\"Error text: {0}\".format(c.out))\r\n                        )\r\n                        sp.write_err(crayons.blue(vistir.compat.fs_str(format_pip_error(c.err))))\r\n                        if environments.is_verbose():\r\n                            sp.write_err(crayons.blue(vistir.compat.fs_str(format_pip_output(c.out))))\r\n                        if \"setup.py egg_info\" in c.err:\r\n                            sp.write_err(vistir.compat.fs_str(\r\n                                \"This is likely caused by a bug in {0}. \"\r\n                                \"Report this to its maintainers.\".format(\r\n                                    crayons.green(pkg_requirement.name)\r\n                                )\r\n                            ))\r\n                        sp.red.fail(environments.PIPENV_SPINNER_FAIL_TEXT.format(\"Installation Failed\"))\r\n                        sys.exit(1)\r\n                except (ValueError, RuntimeError) as e:\r\n                    sp.write_err(vistir.compat.fs_str(\r\n                        \"{0}: {1}\".format(crayons.red(\"WARNING\"), e),\r\n                    ))\r\n                    sp.red.fail(environments.PIPENV_SPINNER_FAIL_TEXT.format(\r\n                        \"Installation Failed\",\r\n                    ))\r\n                    sys.exit(1)\r\n                # Warn if --editable wasn't passed.\r\n                if pkg_requirement.is_vcs and not pkg_requirement.editable and not PIPENV_RESOLVE_VCS:\r\n                    sp.write_err(\r\n                        \"{0}: You installed a VCS dependency in non-editable mode. \"\r\n                        \"This will work fine, but sub-dependencies will not be resolved by {1}.\"\r\n                        \"\\n  To enable this sub-dependency functionality, specify that this dependency is editable.\"\r\n                        \"\".format(\r\n                            crayons.red(\"Warning\", bold=True),\r\n                            crayons.red(\"$ pipenv lock\"),\r\n                        )\r\n                    )\r\n                sp.write(vistir.compat.fs_str(\r\n                    u\"{0} {1} {2} {3}{4}\".format(\r\n                        crayons.normal(u\"Adding\", bold=True),\r\n                        crayons.green(u\"{0}\".format(pkg_requirement.name), bold=True),\r\n                        crayons.normal(u\"to Pipfile's\", bold=True),\r\n                        crayons.red(u\"[dev-packages]\" if dev else u\"[packages]\", bold=True),\r\n                        crayons.normal(fix_utf8(\"…\"), bold=True),\r\n                    )\r\n                ))\r\n                # Add the package to the Pipfile.\r\n                try:\r\n                    project.add_package_to_pipfile(pkg_requirement, dev)\r\n                except ValueError:\r\n                    import traceback\r\n                    sp.write_err(\r\n                        \"{0} {1}\".format(\r\n                            crayons.red(\"Error:\", bold=True), traceback.format_exc()\r\n                        )\r\n                    )\r\n                    sp.fail(environments.PIPENV_SPINNER_FAIL_TEXT.format(\r\n                        \"Failed adding package to Pipfile\"\r\n                    ))\r\n                sp.ok(environments.PIPENV_SPINNER_OK_TEXT.format(\"Installation Succeeded\"))\r\n            # Update project settings with pre preference.\r\n            if pre:\r\n                project.update_settings({\"allow_prereleases\": pre})\r\n        if pip_shims_module:\r\n            os.environ[\"PIP_SHIMS_BASE_MODULE\"] = pip_shims_module\r\n        do_init(\r\n            dev=dev,\r\n            system=system,\r\n            allow_global=system,\r\n            concurrent=concurrent,\r\n            keep_outdated=keep_outdated,\r\n            requirements_dir=requirements_directory,\r\n            deploy=deploy,\r\n            pypi_mirror=pypi_mirror,\r\n            skip_lock=skip_lock,\r\n        )\r\n    sys.exit(0)\r\n\r\n\r\ndef do_uninstall(\r\n    packages=False,\r\n    editable_packages=False,\r\n    three=None,\r\n    python=False,\r\n    system=False,\r\n    lock=False,\r\n    all_dev=False,\r\n    all=False,\r\n    keep_outdated=False,\r\n    pypi_mirror=None,\r\n    ctx=None\r\n):\r\n    from .environments import PIPENV_USE_SYSTEM\r\n    from .vendor.requirementslib.models.requirements import Requirement\r\n    from .vendor.packaging.utils import canonicalize_name\r\n\r\n    # Automatically use an activated virtualenv.\r\n    if PIPENV_USE_SYSTEM:\r\n        system = True\r\n    # Ensure that virtualenv is available.\r\n    # TODO: We probably shouldn't ensure a project exists if the outcome will be to just\r\n    # install things in order to remove them... maybe tell the user to install first?\r\n    ensure_project(three=three, python=python, pypi_mirror=pypi_mirror)\r\n    # Un-install all dependencies, if --all was provided.\r\n    if not any([packages, editable_packages, all_dev, all]):\r\n        raise exceptions.MissingParameter(\r\n            crayons.red(\"No package provided!\"),\r\n            ctx=ctx, param_type=\"parameter\",\r\n        )\r\n    editable_pkgs = [\r\n        Requirement.from_line(\"-e {0}\".format(p)).name for p in editable_packages if p\r\n    ]\r\n    packages = packages + editable_pkgs\r\n    package_names = [p for p in packages if p]\r\n    package_map = {\r\n        canonicalize_name(p): p for p in packages if p\r\n    }\r\n    installed_package_names = project.installed_package_names\r\n    # Intelligently detect if --dev should be used or not.\r\n    lockfile_packages = set()\r\n    if project.lockfile_exists:\r\n        project_pkg_names = project.lockfile_package_names\r\n    else:\r\n        project_pkg_names = project.pipfile_package_names\r\n    pipfile_remove = True\r\n    # Uninstall [dev-packages], if --dev was provided.\r\n    if all_dev:\r\n        if \"dev-packages\" not in project.parsed_pipfile and not project_pkg_names[\"dev\"]:\r\n            click.echo(\r\n                crayons.normal(\r\n                    \"No {0} to uninstall.\".format(crayons.red(\"[dev-packages]\")),\r\n                    bold=True,\r\n                )\r\n            )\r\n            return\r\n        click.echo(\r\n            crayons.normal(\r\n                fix_utf8(\"Un-installing {0}…\".format(crayons.red(\"[dev-packages]\"))), bold=True\r\n            )\r\n        )\r\n        package_names = project_pkg_names[\"dev\"]\r\n\r\n    # Remove known \"bad packages\" from the list.\r\n    bad_pkgs = get_canonical_names(BAD_PACKAGES)\r\n    ignored_packages = bad_pkgs & set(list(package_map.keys()))\r\n    for ignored_pkg in ignored_packages:\r\n        if environments.is_verbose():\r\n            click.echo(\"Ignoring {0}.\".format(ignored_pkg), err=True)\r\n        pkg_name_index = package_names.index(package_map[ignored_pkg])\r\n        del package_names[pkg_name_index]\r\n\r\n    used_packages = project_pkg_names[\"combined\"] & installed_package_names\r\n    failure = False\r\n    packages_to_remove = set()\r\n    if all:\r\n        click.echo(\r\n            crayons.normal(\r\n                fix_utf8(\"Un-installing all {0} and {1}…\".format(\r\n                    crayons.red(\"[dev-packages]\"),\r\n                    crayons.red(\"[packages]\"),\r\n                )), bold=True\r\n            )\r\n        )\r\n        do_purge(bare=False, allow_global=system)\r\n        sys.exit(0)\r\n    if all_dev:\r\n        package_names = project_pkg_names[\"dev\"]\r\n    else:\r\n        package_names = set([pkg_name for pkg_name in package_names])\r\n    selected_pkg_map = {\r\n        canonicalize_name(p): p for p in package_names\r\n    }\r\n    packages_to_remove = [\r\n        p for normalized, p in selected_pkg_map.items()\r\n        if normalized in (used_packages - bad_pkgs)\r\n    ]\r\n    pip_path = None\r\n    for normalized, package_name in selected_pkg_map.items():\r\n        click.echo(\r\n            crayons.white(\r\n                fix_utf8(\"Uninstalling {0}…\".format(package_name)), bold=True\r\n            )\r\n        )\r\n        # Uninstall the package.\r\n        if package_name in packages_to_remove:\r\n            with project.environment.activated():\r\n                if pip_path is None:\r\n                    pip_path = which_pip(allow_global=system)\r\n                cmd = [pip_path, \"uninstall\", package_name, \"-y\"]\r\n                c = run_command(cmd)\r\n                click.echo(crayons.blue(c.out))\r\n                if c.return_code != 0:\r\n                    failure = True\r\n        if not failure and pipfile_remove:\r\n            in_packages = project.get_package_name_in_pipfile(package_name, dev=False)\r\n            in_dev_packages = project.get_package_name_in_pipfile(\r\n                package_name, dev=True\r\n            )\r\n            if normalized in lockfile_packages:\r\n                click.echo(\"{0} {1} {2} {3}\".format(\r\n                    crayons.blue(\"Removing\"),\r\n                    crayons.green(package_name),\r\n                    crayons.blue(\"from\"),\r\n                    crayons.white(fix_utf8(\"Pipfile.lock…\")))\r\n                )\r\n                lockfile = project.get_or_create_lockfile()\r\n                if normalized in lockfile.default:\r\n                    del lockfile.default[normalized]\r\n                if normalized in lockfile.develop:\r\n                    del lockfile.develop[normalized]\r\n                lockfile.write()\r\n            if not (in_dev_packages or in_packages):\r\n                if normalized in lockfile_packages:\r\n                    continue\r\n                click.echo(\r\n                    \"No package {0} to remove from Pipfile.\".format(\r\n                        crayons.green(package_name)\r\n                    )\r\n                )\r\n                continue\r\n\r\n            click.echo(\r\n                fix_utf8(\"Removing {0} from Pipfile…\".format(crayons.green(package_name)))\r\n            )\r\n            # Remove package from both packages and dev-packages.\r\n            if in_dev_packages:\r\n                project.remove_package_from_pipfile(package_name, dev=True)\r\n            if in_packages:\r\n                project.remove_package_from_pipfile(package_name, dev=False)\r\n    if lock:\r\n        do_lock(system=system, keep_outdated=keep_outdated, pypi_mirror=pypi_mirror)\r\n    sys.exit(int(failure))\r\n\r\n\r\ndef do_shell(three=None, python=False, fancy=False, shell_args=None, pypi_mirror=None):\r\n    # Ensure that virtualenv is available.\r\n    ensure_project(\r\n        three=three, python=python, validate=False, pypi_mirror=pypi_mirror,\r\n    )\r\n\r\n    # Support shell compatibility mode.\r\n    if PIPENV_SHELL_FANCY:\r\n        fancy = True\r\n\r\n    from .shells import choose_shell\r\n\r\n    shell = choose_shell()\r\n    click.echo(fix_utf8(\"Launching subshell in virtual environment…\"), err=True)\r\n\r\n    fork_args = (\r\n        project.virtualenv_location,\r\n        project.project_directory,\r\n        shell_args,\r\n    )\r\n\r\n    # Set an environment variable, so we know we're in the environment.\r\n    # Only set PIPENV_ACTIVE after finishing reading virtualenv_location\r\n    # otherwise its value will be changed\r\n    os.environ[\"PIPENV_ACTIVE\"] = vistir.misc.fs_str(\"1\")\r\n\r\n    os.environ.pop(\"PIP_SHIMS_BASE_MODULE\", None)\r\n\r\n    if fancy:\r\n        shell.fork(*fork_args)\r\n        return\r\n\r\n    try:\r\n        shell.fork_compat(*fork_args)\r\n    except (AttributeError, ImportError):\r\n        click.echo(fix_utf8(\r\n            \"Compatibility mode not supported. \"\r\n            \"Trying to continue as well-configured shell…\"),\r\n            err=True,\r\n        )\r\n        shell.fork(*fork_args)\r\n\r\n\r\ndef _inline_activate_virtualenv():\r\n    try:\r\n        activate_this = which(\"activate_this.py\")\r\n        if not activate_this or not os.path.exists(activate_this):\r\n            raise exceptions.VirtualenvActivationException()\r\n        with open(activate_this) as f:\r\n            code = compile(f.read(), activate_this, \"exec\")\r\n            exec(code, dict(__file__=activate_this))\r\n    # Catch all errors, just in case.\r\n    except Exception:\r\n        click.echo(\r\n            u\"{0}: There was an unexpected error while activating your \"\r\n            u\"virtualenv. Continuing anyway...\".format(\r\n                crayons.red(\"Warning\", bold=True)\r\n            ),\r\n            err=True,\r\n        )\r\n\r\n\r\ndef _inline_activate_venv():\r\n    \"\"\"Built-in venv doesn't have activate_this.py, but doesn't need it anyway.\r\n\r\n    As long as we find the correct executable, built-in venv sets up the\r\n    environment automatically.\r\n\r\n    See: https://bugs.python.org/issue21496#msg218455\r\n    \"\"\"\r\n    components = []\r\n    for name in (\"bin\", \"Scripts\"):\r\n        bindir = os.path.join(project.virtualenv_location, name)\r\n        if os.path.exists(bindir):\r\n            components.append(bindir)\r\n    if \"PATH\" in os.environ:\r\n        components.append(os.environ[\"PATH\"])\r\n    os.environ[\"PATH\"] = os.pathsep.join(components)\r\n\r\n\r\ndef inline_activate_virtual_environment():\r\n    root = project.virtualenv_location\r\n    if os.path.exists(os.path.join(root, \"pyvenv.cfg\")):\r\n        _inline_activate_venv()\r\n    else:\r\n        _inline_activate_virtualenv()\r\n    if \"VIRTUAL_ENV\" not in os.environ:\r\n        os.environ[\"VIRTUAL_ENV\"] = vistir.misc.fs_str(root)\r\n\r\n\r\ndef _launch_windows_subprocess(script):\r\n    import subprocess\r\n\r\n    command = system_which(script.command)\r\n    options = {\"universal_newlines\": True}\r\n\r\n    # Command not found, maybe this is a shell built-in?\r\n    if not command:\r\n        return subprocess.Popen(script.cmdify(), shell=True, **options)\r\n\r\n    # Try to use CreateProcess directly if possible. Specifically catch\r\n    # Windows error 193 \"Command is not a valid Win32 application\" to handle\r\n    # a \"command\" that is non-executable. See pypa/pipenv#2727.\r\n    try:\r\n        return subprocess.Popen([command] + script.args, **options)\r\n    except WindowsError as e:\r\n        if e.winerror != 193:\r\n            raise\r\n\r\n    # Try shell mode to use Windows's file association for file launch.\r\n    return subprocess.Popen(script.cmdify(), shell=True, **options)\r\n\r\n\r\ndef do_run_nt(script):\r\n    p = _launch_windows_subprocess(script)\r\n    p.communicate()\r\n    sys.exit(p.returncode)\r\n\r\n\r\ndef do_run_posix(script, command):\r\n    command_path = system_which(script.command)\r\n    if not command_path:\r\n        if project.has_script(command):\r\n            click.echo(\r\n                \"{0}: the command {1} (from {2}) could not be found within {3}.\"\r\n                \"\".format(\r\n                    crayons.red(\"Error\", bold=True),\r\n                    crayons.red(script.command),\r\n                    crayons.normal(command, bold=True),\r\n                    crayons.normal(\"PATH\", bold=True),\r\n                ),\r\n                err=True,\r\n            )\r\n        else:\r\n            click.echo(\r\n                \"{0}: the command {1} could not be found within {2} or Pipfile's {3}.\"\r\n                \"\".format(\r\n                    crayons.red(\"Error\", bold=True),\r\n                    crayons.red(command),\r\n                    crayons.normal(\"PATH\", bold=True),\r\n                    crayons.normal(\"[scripts]\", bold=True),\r\n                ),\r\n                err=True,\r\n            )\r\n        sys.exit(1)\r\n    os.execl(\r\n        command_path, command_path, *[os.path.expandvars(arg) for arg in script.args]\r\n    )\r\n\r\n\r\ndef do_run(command, args, three=None, python=False, pypi_mirror=None):\r\n    \"\"\"Attempt to run command either pulling from project or interpreting as executable.\r\n\r\n    Args are appended to the command in [scripts] section of project if found.\r\n    \"\"\"\r\n    from .cmdparse import ScriptEmptyError\r\n\r\n    # Ensure that virtualenv is available.\r\n    ensure_project(\r\n        three=three, python=python, validate=False, pypi_mirror=pypi_mirror,\r\n    )\r\n\r\n    load_dot_env()\r\n\r\n    previous_pip_shims_module = os.environ.pop(\"PIP_SHIMS_BASE_MODULE\", None)\r\n\r\n    # Activate virtualenv under the current interpreter's environment\r\n    inline_activate_virtual_environment()\r\n\r\n    # Set an environment variable, so we know we're in the environment.\r\n    # Only set PIPENV_ACTIVE after finishing reading virtualenv_location\r\n    # such as in inline_activate_virtual_environment\r\n    # otherwise its value will be changed\r\n    previous_pipenv_active_value = os.environ.get(\"PIPENV_ACTIVE\")\r\n    os.environ[\"PIPENV_ACTIVE\"] = vistir.misc.fs_str(\"1\")\r\n\r\n    os.environ.pop(\"PIP_SHIMS_BASE_MODULE\", None)\r\n\r\n    try:\r\n        script = project.build_script(command, args)\r\n        cmd_string = ' '.join([script.command] + script.args)\r\n        if environments.is_verbose():\r\n            click.echo(crayons.normal(\"$ {0}\".format(cmd_string)), err=True)\r\n    except ScriptEmptyError:\r\n        click.echo(\"Can't run script {0!r}-it's empty?\", err=True)\r\n    run_args = [script]\r\n    run_kwargs = {}\r\n    if os.name == \"nt\":\r\n        run_fn = do_run_nt\r\n    else:\r\n        run_fn = do_run_posix\r\n        run_kwargs = {\"command\": command}\r\n    try:\r\n        run_fn(*run_args, **run_kwargs)\r\n    finally:\r\n        os.environ.pop(\"PIPENV_ACTIVE\", None)\r\n        if previous_pipenv_active_value is not None:\r\n            os.environ[\"PIPENV_ACTIVE\"] = previous_pipenv_active_value\r\n        if previous_pip_shims_module is not None:\r\n            os.environ[\"PIP_SHIMS_BASE_MODULE\"] = previous_pip_shims_module\r\n\r\n\r\ndef do_check(\r\n    three=None,\r\n    python=False,\r\n    system=False,\r\n    unused=False,\r\n    db=False,\r\n    ignore=None,\r\n    output=\"default\",\r\n    key=None,\r\n    quiet=False,\r\n    args=None,\r\n    pypi_mirror=None\r\n):\r\n    from pipenv.vendor.vistir.compat import JSONDecodeError\r\n    from pipenv.vendor.first import first\r\n\r\n    if not system:\r\n        # Ensure that virtualenv is available.\r\n        ensure_project(\r\n            three=three,\r\n            python=python,\r\n            validate=False,\r\n            warn=False,\r\n            pypi_mirror=pypi_mirror,\r\n        )\r\n    if not args:\r\n        args = []\r\n    if unused:\r\n        deps_required = [k.lower() for k in project.packages.keys()]\r\n        deps_needed = [k.lower() for k in import_from_code(unused)]\r\n        for dep in deps_needed:\r\n            try:\r\n                deps_required.remove(dep)\r\n            except ValueError:\r\n                pass\r\n        if deps_required:\r\n            if not quiet and not environments.is_quiet():\r\n                click.echo(\r\n                    crayons.normal(\r\n                        \"The following dependencies appear unused, and may be safe for removal:\"\r\n                    )\r\n                )\r\n                for dep in deps_required:\r\n                    click.echo(\"  - {0}\".format(crayons.green(dep)))\r\n                sys.exit(1)\r\n        else:\r\n            sys.exit(0)\r\n    if not quiet and not environments.is_quiet():\r\n        click.echo(crayons.normal(decode_for_output(\"Checking PEP 508 requirements…\"), bold=True))\r\n    pep508checker_path = pep508checker.__file__.rstrip(\"cdo\")\r\n    safety_path = os.path.join(\r\n        os.path.dirname(os.path.abspath(__file__)), \"patched\", \"safety\"\r\n    )\r\n    if not system:\r\n        python = which(\"python\")\r\n    else:\r\n        python = first(system_which(p) for p in (\"python\", \"python3\", \"python2\"))\r\n    if not python:\r\n        click.echo(crayons.red(\"The Python interpreter can't be found.\"), err=True)\r\n        sys.exit(1)\r\n    _cmd = [vistir.compat.Path(python).as_posix()]\r\n    # Run the PEP 508 checker in the virtualenv.\r\n    cmd = _cmd + [vistir.compat.Path(pep508checker_path).as_posix()]\r\n    c = run_command(cmd)\r\n    if c.return_code is not None:\r\n        try:\r\n            results = simplejson.loads(c.out.strip())\r\n        except JSONDecodeError:\r\n            click.echo(\"{0}\\n{1}\\n{2}\".format(\r\n                crayons.white(decode_for_output(\"Failed parsing pep508 results: \"), bold=True),\r\n                c.out.strip(),\r\n                c.err.strip()\r\n            ))\r\n            sys.exit(1)\r\n    # Load the pipfile.\r\n    p = pipfile.Pipfile.load(project.pipfile_location)\r\n    failed = False\r\n    # Assert each specified requirement.\r\n    for marker, specifier in p.data[\"_meta\"][\"requires\"].items():\r\n        if marker in results:\r\n            try:\r\n                assert results[marker] == specifier\r\n            except AssertionError:\r\n                failed = True\r\n                click.echo(\r\n                    \"Specifier {0} does not match {1} ({2}).\"\r\n                    \"\".format(\r\n                        crayons.green(marker),\r\n                        crayons.blue(specifier),\r\n                        crayons.red(results[marker]),\r\n                    ),\r\n                    err=True,\r\n                )\r\n    if failed:\r\n        click.echo(crayons.red(\"Failed!\"), err=True)\r\n        sys.exit(1)\r\n    else:\r\n        if not quiet and not environments.is_quiet():\r\n            click.echo(crayons.green(\"Passed!\"))\r\n    if not quiet and not environments.is_quiet():\r\n        click.echo(crayons.normal(\r\n            decode_for_output(\"Checking installed package safety…\"), bold=True)\r\n        )\r\n    if ignore:\r\n        if not isinstance(ignore, (tuple, list)):\r\n            ignore = [ignore]\r\n        ignored = [[\"--ignore\", cve] for cve in ignore]\r\n        if not quiet and not environments.is_quiet():\r\n            click.echo(\r\n                crayons.normal(\r\n                    \"Notice: Ignoring CVE(s) {0}\".format(crayons.yellow(\", \".join(ignore)))\r\n                ),\r\n                err=True,\r\n            )\r\n    else:\r\n        ignored = []\r\n\r\n    switch = output\r\n    if output == \"default\":\r\n        switch = \"json\"\r\n\r\n    cmd = _cmd + [safety_path, \"check\", \"--{0}\".format(switch)]\r\n    if db:\r\n        if not quiet and not environments.is_quiet():\r\n            click.echo(crayons.normal(\"Using local database {}\".format(db)))\r\n        cmd.append(\"--db={0}\".format(db))\r\n    elif key or PIPENV_PYUP_API_KEY:\r\n        cmd = cmd + [\"--key={0}\".format(key or PIPENV_PYUP_API_KEY)]\r\n    if ignored:\r\n        for cve in ignored:\r\n            cmd += cve\r\n    c = run_command(cmd, catch_exceptions=False)\r\n    if output == \"default\":\r\n        try:\r\n            results = simplejson.loads(c.out)\r\n        except (ValueError, JSONDecodeError):\r\n            raise exceptions.JSONParseError(c.out, c.err)\r\n        except Exception:\r\n            raise exceptions.PipenvCmdError(c.cmd, c.out, c.err, c.return_code)\r\n        for (package, resolved, installed, description, vuln) in results:\r\n            click.echo(\r\n                \"{0}: {1} {2} resolved ({3} installed)!\".format(\r\n                    crayons.normal(vuln, bold=True),\r\n                    crayons.green(package),\r\n                    crayons.red(resolved, bold=False),\r\n                    crayons.red(installed, bold=True),\r\n                )\r\n            )\r\n            click.echo(\"{0}\".format(description))\r\n            click.echo()\r\n        if c.ok:\r\n            click.echo(crayons.green(\"All good!\"))\r\n            sys.exit(0)\r\n        else:\r\n            sys.exit(1)\r\n    else:\r\n        click.echo(c.out)\r\n        sys.exit(c.return_code)\r\n\r\n\r\ndef do_graph(bare=False, json=False, json_tree=False, reverse=False):\r\n    from pipenv.vendor.vistir.compat import JSONDecodeError\r\n    import pipdeptree\r\n    pipdeptree_path = pipdeptree.__file__.rstrip(\"cdo\")\r\n    try:\r\n        python_path = which(\"python\")\r\n    except AttributeError:\r\n        click.echo(\r\n            u\"{0}: {1}\".format(\r\n                crayons.red(\"Warning\", bold=True),\r\n                u\"Unable to display currently-installed dependency graph information here. \"\r\n                u\"Please run within a Pipenv project.\",\r\n            ),\r\n            err=True,\r\n        )\r\n        sys.exit(1)\r\n    except RuntimeError:\r\n        pass\r\n    else:\r\n        python_path = vistir.compat.Path(python_path).as_posix()\r\n        pipdeptree_path = vistir.compat.Path(pipdeptree_path).as_posix()\r\n\r\n    if reverse and json:\r\n        click.echo(\r\n            u\"{0}: {1}\".format(\r\n                crayons.red(\"Warning\", bold=True),\r\n                u\"Using both --reverse and --json together is not supported. \"\r\n                u\"Please select one of the two options.\",\r\n            ),\r\n            err=True,\r\n        )\r\n        sys.exit(1)\r\n    if reverse and json_tree:\r\n        click.echo(\r\n            u\"{0}: {1}\".format(\r\n                crayons.red(\"Warning\", bold=True),\r\n                u\"Using both --reverse and --json-tree together is not supported. \"\r\n                u\"Please select one of the two options.\",\r\n            ),\r\n            err=True,\r\n        )\r\n        sys.exit(1)\r\n    if json and json_tree:\r\n        click.echo(\r\n            u\"{0}: {1}\".format(\r\n                crayons.red(\"Warning\", bold=True),\r\n                u\"Using both --json and --json-tree together is not supported. \"\r\n                u\"Please select one of the two options.\",\r\n            ),\r\n            err=True,\r\n        )\r\n        sys.exit(1)\r\n    flag = \"\"\r\n    if json:\r\n        flag = \"--json\"\r\n    if json_tree:\r\n        flag = \"--json-tree\"\r\n    if reverse:\r\n        flag = \"--reverse\"\r\n    if not project.virtualenv_exists:\r\n        click.echo(\r\n            u\"{0}: No virtualenv has been created for this project yet! Consider \"\r\n            u\"running {1} first to automatically generate one for you or see \"\r\n            u\"{2} for further instructions.\".format(\r\n                crayons.red(\"Warning\", bold=True),\r\n                crayons.green(\"`pipenv install`\"),\r\n                crayons.green(\"`pipenv install --help`\"),\r\n            ),\r\n            err=True,\r\n        )\r\n        sys.exit(1)\r\n    cmd_args = [python_path, pipdeptree_path, flag, \"-l\"]\r\n    c = run_command(cmd_args)\r\n    # Run dep-tree.\r\n    if not bare:\r\n        if json:\r\n            data = []\r\n            try:\r\n                parsed = simplejson.loads(c.out.strip())\r\n            except JSONDecodeError:\r\n                raise exceptions.JSONParseError(c.out, c.err)\r\n            else:\r\n                for d in parsed:\r\n                    if d[\"package\"][\"key\"] not in BAD_PACKAGES:\r\n                        data.append(d)\r\n            click.echo(simplejson.dumps(data, indent=4))\r\n            sys.exit(0)\r\n        elif json_tree:\r\n\r\n            def traverse(obj):\r\n                if isinstance(obj, list):\r\n                    return [\r\n                        traverse(package)\r\n                        for package in obj\r\n                        if package[\"key\"] not in BAD_PACKAGES\r\n                    ]\r\n                else:\r\n                    obj[\"dependencies\"] = traverse(obj[\"dependencies\"])\r\n                    return obj\r\n\r\n            try:\r\n                parsed = simplejson.loads(c.out.strip())\r\n            except JSONDecodeError:\r\n                raise exceptions.JSONParseError(c.out, c.err)\r\n            else:\r\n                data = traverse(parsed)\r\n                click.echo(simplejson.dumps(data, indent=4))\r\n                sys.exit(0)\r\n        else:\r\n            for line in c.out.strip().split(\"\\n\"):\r\n                # Ignore bad packages as top level.\r\n                # TODO: This should probably be a \"==\" in + line.partition\r\n                if line.split(\"==\")[0] in BAD_PACKAGES and not reverse:\r\n                    continue\r\n\r\n                # Bold top-level packages.\r\n                if not line.startswith(\" \"):\r\n                    click.echo(crayons.normal(line, bold=True))\r\n                # Echo the rest.\r\n                else:\r\n                    click.echo(crayons.normal(line, bold=False))\r\n    else:\r\n        click.echo(c.out)\r\n    if c.return_code != 0:\r\n        click.echo(\r\n            \"{0} {1}\".format(\r\n                crayons.red(\"ERROR: \", bold=True),\r\n                crayons.white(\"{0}\".format(c.err, bold=True)),\r\n            ),\r\n            err=True,\r\n        )\r\n    # Return its return code.\r\n    sys.exit(c.return_code)\r\n\r\n\r\ndef do_sync(\r\n    ctx,\r\n    dev=False,\r\n    three=None,\r\n    python=None,\r\n    bare=False,\r\n    dont_upgrade=False,\r\n    user=False,\r\n    clear=False,\r\n    unused=False,\r\n    sequential=False,\r\n    pypi_mirror=None,\r\n    system=False,\r\n    deploy=False,\r\n):\r\n    # The lock file needs to exist because sync won't write to it.\r\n    if not project.lockfile_exists:\r\n        raise exceptions.LockfileNotFound(\"Pipfile.lock\")\r\n\r\n    # Ensure that virtualenv is available if not system.\r\n    ensure_project(\r\n        three=three,\r\n        python=python,\r\n        validate=False,\r\n        deploy=deploy,\r\n        pypi_mirror=pypi_mirror,\r\n    )\r\n\r\n    # Install everything.\r\n    requirements_dir = vistir.path.create_tracked_tempdir(\r\n        suffix=\"-requirements\", prefix=\"pipenv-\"\r\n    )\r\n    do_init(\r\n        dev=dev,\r\n        concurrent=(not sequential),\r\n        requirements_dir=requirements_dir,\r\n        ignore_pipfile=True,  # Don't check if Pipfile and lock match.\r\n        pypi_mirror=pypi_mirror,\r\n        deploy=deploy,\r\n        system=system,\r\n    )\r\n    if not bare:\r\n        click.echo(crayons.green(\"All dependencies are now up-to-date!\"))\r\n\r\n\r\ndef do_clean(\r\n    ctx, three=None, python=None, dry_run=False, bare=False, pypi_mirror=None,\r\n    system=False\r\n):\r\n    # Ensure that virtualenv is available.\r\n    from packaging.utils import canonicalize_name\r\n    ensure_project(three=three, python=python, validate=False, pypi_mirror=pypi_mirror)\r\n    ensure_lockfile(pypi_mirror=pypi_mirror)\r\n    # Make sure that the virtualenv's site packages are configured correctly\r\n    # otherwise we may end up removing from the global site packages directory\r\n    installed_package_names = project.installed_package_names.copy()\r\n    # Remove known \"bad packages\" from the list.\r\n    for bad_package in BAD_PACKAGES:\r\n        if canonicalize_name(bad_package) in installed_package_names:\r\n            if environments.is_verbose():\r\n                click.echo(\"Ignoring {0}.\".format(bad_package), err=True)\r\n            installed_package_names.remove(canonicalize_name(bad_package))\r\n    # Intelligently detect if --dev should be used or not.\r\n    locked_packages = {\r\n        canonicalize_name(pkg) for pkg in project.lockfile_package_names[\"combined\"]\r\n    }\r\n    for used_package in locked_packages:\r\n        if used_package in installed_package_names:\r\n            installed_package_names.remove(used_package)\r\n    failure = False\r\n    cmd = [which_pip(allow_global=system), \"uninstall\", \"-y\", \"-qq\"]\r\n    for apparent_bad_package in installed_package_names:\r\n        if dry_run and not bare:\r\n            click.echo(apparent_bad_package)\r\n        else:\r\n            if not bare:\r\n                click.echo(\r\n                    crayons.white(\r\n                        fix_utf8(\"Uninstalling {0}…\".format(apparent_bad_package)), bold=True\r\n                    )\r\n                )\r\n            # Uninstall the package.\r\n            cmd = [which_pip(), \"uninstall\", apparent_bad_package, \"-y\"]\r\n            c = run_command(cmd)\r\n            if c.return_code != 0:\r\n                failure = True\r\n    sys.exit(int(failure))\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- env/Lib/site-packages/pipenv/core.py	(revision 7de091c5b19e7b06e80c151f7100df6d0f893820)
+++ env/Lib/site-packages/pipenv/core.py	(date 1591098437571)
@@ -126,8 +126,11 @@
 
     try:
         vistir.path.rmtree(PIPENV_CACHE_DIR, onerror=vistir.path.handle_remove_readonly)
+        # Other processes may be writing into this directory simultaneously.
         vistir.path.rmtree(
-            locations.USER_CACHE_DIR, onerror=vistir.path.handle_remove_readonly
+            locations.USER_CACHE_DIR,
+            ignore_errors=environments.PIPENV_IS_CI,
+            onerror=vistir.path.handle_remove_readonly
         )
     except OSError as e:
         # Ignore FileNotFoundError. This is needed for Python 2.7.
@@ -568,14 +571,6 @@
         system = True
     if not project.pipfile_exists and deploy:
         raise exceptions.PipfileNotFound
-    # Fail if working under /
-    if not project.name:
-        click.echo(
-            "{0}: Pipenv is not intended to work under the root directory, "
-            "please choose another path.".format(crayons.red("ERROR")),
-            err=True
-        )
-        sys.exit(1)
     # Skip virtualenv creation when --system was used.
     if not system:
         ensure_virtualenv(
@@ -993,8 +988,10 @@
         f.write(vistir.misc.fs_str(project.project_directory))
     from .environment import Environment
     sources = project.pipfile_sources
+    # project.get_location_for_virtualenv is only for if we are creating a new virtualenv
+    # whereas virtualenv_location is for the current path to the runtime
     project._environment = Environment(
-        prefix=project.get_location_for_virtualenv(),
+        prefix=project.virtualenv_location,
         is_venv=True,
         sources=sources,
         pipfile=project.parsed_pipfile,
@@ -1619,10 +1616,10 @@
 def system_which(command, mult=False):
     """Emulates the system's which. Returns None if not found."""
     _which = "which -a" if not os.name == "nt" else "where"
-    os.environ = {
+    os.environ.update({
         vistir.compat.fs_str(k): vistir.compat.fs_str(val)
         for k, val in os.environ.items()
-    }
+    })
     result = None
     try:
         c = delegator.run("{0} {1}".format(_which, command))
Index: application/xml/Check.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"utf-8\"?>\r\r\n<HattrickData>\r\r\n  <FileName>check_token</FileName>\r\r\n  <Version>1.0</Version>\r\r\n  <UserID>1248859</UserID>\r\r\n  <FetchedDate>2020-06-01 13:29:09</FetchedDate>\r\r\n  <Token>D9IVQbiGhEL6bRXb</Token>\r\r\n  <Created>2020-05-20 16:30:00</Created>\r\r\n  <User>1248859</User>\r\r\n  <Expires>9999-12-31 23:59:59</Expires>\r\r\n  <ExtendedPermissions></ExtendedPermissions>\r\r\n</HattrickData>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- application/xml/Check.xml	(revision 7de091c5b19e7b06e80c151f7100df6d0f893820)
+++ application/xml/Check.xml	(date 1591016694703)
@@ -8,7 +8,7 @@
 
   <UserID>1248859</UserID>
 
-  <FetchedDate>2020-06-01 13:29:09</FetchedDate>
+  <FetchedDate>2020-06-01 15:04:54</FetchedDate>
 
   <Token>D9IVQbiGhEL6bRXb</Token>
 
Index: env/Lib/site-packages/pipenv-2020.6.2.dist-info/LICENSE
===================================================================
--- env/Lib/site-packages/pipenv-2020.6.2.dist-info/LICENSE	(date 1591098444259)
+++ env/Lib/site-packages/pipenv-2020.6.2.dist-info/LICENSE	(date 1591098444259)
@@ -0,0 +1,21 @@
+The MIT License (MIT)
+
+Copyright 2020 Python Packaging Authority
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
Index: env/Lib/site-packages/pipenv-2020.6.2.dist-info/INSTALLER
===================================================================
--- env/Lib/site-packages/pipenv-2020.6.2.dist-info/INSTALLER	(date 1591098487230)
+++ env/Lib/site-packages/pipenv-2020.6.2.dist-info/INSTALLER	(date 1591098487230)
@@ -0,0 +1,1 @@
+pip
Index: env/Lib/site-packages/pipenv/utils.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># -*- coding: utf-8 -*-\r\nfrom __future__ import print_function\r\n\r\nimport contextlib\r\nimport errno\r\nimport logging\r\nimport os\r\nimport posixpath\r\nimport re\r\nimport shutil\r\nimport signal\r\nimport stat\r\nimport sys\r\nimport warnings\r\nfrom contextlib import contextmanager\r\nfrom distutils.spawn import find_executable\r\n\r\nimport six\r\nimport toml\r\nfrom click import echo as click_echo\r\nfrom six.moves.urllib.parse import urlparse\r\n\r\nimport crayons\r\nimport parse\r\nimport tomlkit\r\n\r\nfrom . import environments\r\nfrom .exceptions import PipenvCmdError, PipenvUsageError, RequirementError, ResolutionFailure\r\nfrom .pep508checker import lookup\r\nfrom .vendor.packaging.markers import Marker\r\nfrom .vendor.urllib3 import util as urllib3_util\r\nfrom .vendor.vistir.compat import Mapping, ResourceWarning, Sequence, Set, lru_cache\r\nfrom .vendor.vistir.misc import fs_str, run\r\n\r\nif environments.MYPY_RUNNING:\r\n    from typing import Tuple, Dict, Any, List, Union, Optional, Text\r\n    from .vendor.requirementslib.models.requirements import Requirement, Line\r\n    from .vendor.requirementslib.models.pipfile import Pipfile\r\n    from .project import Project, TSource\r\n\r\n\r\nlogging.basicConfig(level=logging.ERROR)\r\n\r\nspecifiers = [k for k in lookup.keys()]\r\n# List of version control systems we support.\r\nVCS_LIST = (\"git\", \"svn\", \"hg\", \"bzr\")\r\nSCHEME_LIST = (\"http://\", \"https://\", \"ftp://\", \"ftps://\", \"file://\")\r\nrequests_session = None  # type: ignore\r\n\r\n\r\ndef _get_requests_session():\r\n    \"\"\"Load requests lazily.\"\"\"\r\n    global requests_session\r\n    if requests_session is not None:\r\n        return requests_session\r\n    import requests\r\n\r\n    requests_session = requests.Session()\r\n    adapter = requests.adapters.HTTPAdapter(\r\n        max_retries=environments.PIPENV_MAX_RETRIES\r\n    )\r\n    requests_session.mount(\"https://pypi.org/pypi\", adapter)\r\n    return requests_session\r\n\r\n\r\ndef cleanup_toml(tml):\r\n    toml = tml.split(\"\\n\")\r\n    new_toml = []\r\n    # Remove all empty lines from TOML.\r\n    for line in toml:\r\n        if line.strip():\r\n            new_toml.append(line)\r\n    toml = \"\\n\".join(new_toml)\r\n    new_toml = []\r\n    # Add newlines between TOML sections.\r\n    for i, line in enumerate(toml.split(\"\\n\")):\r\n        # Skip the first line.\r\n        if line.startswith(\"[\"):\r\n            if i > 0:\r\n                # Insert a newline before the heading.\r\n                new_toml.append(\"\")\r\n        new_toml.append(line)\r\n    # adding new line at the end of the TOML file\r\n    new_toml.append(\"\")\r\n    toml = \"\\n\".join(new_toml)\r\n    return toml\r\n\r\n\r\ndef convert_toml_outline_tables(parsed):\r\n    \"\"\"Converts all outline tables to inline tables.\"\"\"\r\n    def convert_tomlkit_table(section):\r\n        if isinstance(section, tomlkit.items.Table):\r\n            body = section.value._body\r\n        else:\r\n            body = section._body\r\n        for key, value in body:\r\n            if not key:\r\n                continue\r\n            if hasattr(value, \"keys\") and not isinstance(value, tomlkit.items.InlineTable):\r\n                table = tomlkit.inline_table()\r\n                table.update(value.value)\r\n                section[key.key] = table\r\n\r\n    def convert_toml_table(section):\r\n        for package, value in section.items():\r\n            if hasattr(value, \"keys\") and not isinstance(value, toml.decoder.InlineTableDict):\r\n                table = toml.TomlDecoder().get_empty_inline_table()\r\n                table.update(value)\r\n                section[package] = table\r\n\r\n    is_tomlkit_parsed = isinstance(parsed, tomlkit.container.Container)\r\n    for section in (\"packages\", \"dev-packages\"):\r\n        table_data = parsed.get(section, {})\r\n        if not table_data:\r\n            continue\r\n        if is_tomlkit_parsed:\r\n            convert_tomlkit_table(table_data)\r\n        else:\r\n            convert_toml_table(table_data)\r\n\r\n    return parsed\r\n\r\n\r\ndef run_command(cmd, *args, **kwargs):\r\n    \"\"\"\r\n    Take an input command and run it, handling exceptions and error codes and returning\r\n    its stdout and stderr.\r\n\r\n    :param cmd: The list of command and arguments.\r\n    :type cmd: list\r\n    :returns: A 2-tuple of the output and error from the command\r\n    :rtype: Tuple[str, str]\r\n    :raises: exceptions.PipenvCmdError\r\n    \"\"\"\r\n\r\n    from pipenv.vendor import delegator\r\n    from ._compat import decode_for_output\r\n    from .cmdparse import Script\r\n    catch_exceptions = kwargs.pop(\"catch_exceptions\", True)\r\n    if isinstance(cmd, (six.string_types, list, tuple)):\r\n        cmd = Script.parse(cmd)\r\n    if not isinstance(cmd, Script):\r\n        raise TypeError(\"Command input must be a string, list or tuple\")\r\n    if \"env\" not in kwargs:\r\n        kwargs[\"env\"] = os.environ.copy()\r\n    kwargs[\"env\"][\"PYTHONIOENCODING\"] = \"UTF-8\"\r\n    try:\r\n        cmd_string = cmd.cmdify()\r\n    except TypeError:\r\n        click_echo(\"Error turning command into string: {0}\".format(cmd), err=True)\r\n        sys.exit(1)\r\n    if environments.is_verbose():\r\n        click_echo(\"Running command: $ {0}\".format(cmd_string, err=True))\r\n    c = delegator.run(cmd_string, *args, **kwargs)\r\n    return_code = c.return_code\r\n    if environments.is_verbose():\r\n        click_echo(\"Command output: {0}\".format(\r\n            crayons.blue(decode_for_output(c.out))\r\n        ), err=True)\r\n    if not c.ok and catch_exceptions:\r\n        raise PipenvCmdError(cmd_string, c.out, c.err, return_code)\r\n    return c\r\n\r\n\r\ndef parse_python_version(output):\r\n    \"\"\"Parse a Python version output returned by `python --version`.\r\n\r\n    Return a dict with three keys: major, minor, and micro. Each value is a\r\n    string containing a version part.\r\n\r\n    Note: The micro part would be `'0'` if it's missing from the input string.\r\n    \"\"\"\r\n    version_line = output.split(\"\\n\", 1)[0]\r\n    version_pattern = re.compile(\r\n        r\"\"\"\r\n        ^                   # Beginning of line.\r\n        Python              # Literally \"Python\".\r\n        \\s                  # Space.\r\n        (?P<major>\\d+)      # Major = one or more digits.\r\n        \\.                  # Dot.\r\n        (?P<minor>\\d+)      # Minor = one or more digits.\r\n        (?:                 # Unnamed group for dot-micro.\r\n            \\.              # Dot.\r\n            (?P<micro>\\d+)  # Micro = one or more digit.\r\n        )?                  # Micro is optional because pypa/pipenv#1893.\r\n        .*                  # Trailing garbage.\r\n        $                   # End of line.\r\n    \"\"\",\r\n        re.VERBOSE,\r\n    )\r\n\r\n    match = version_pattern.match(version_line)\r\n    if not match:\r\n        return None\r\n    return match.groupdict(default=\"0\")\r\n\r\n\r\ndef python_version(path_to_python):\r\n    from .vendor.pythonfinder.utils import get_python_version\r\n\r\n    if not path_to_python:\r\n        return None\r\n    try:\r\n        version = get_python_version(path_to_python)\r\n    except Exception:\r\n        return None\r\n    return version\r\n\r\n\r\ndef escape_grouped_arguments(s):\r\n    \"\"\"Prepares a string for the shell (on Windows too!)\r\n\r\n    Only for use on grouped arguments (passed as a string to Popen)\r\n    \"\"\"\r\n    if s is None:\r\n        return None\r\n\r\n    # Additional escaping for windows paths\r\n    if os.name == \"nt\":\r\n        s = \"{}\".format(s.replace(\"\\\\\", \"\\\\\\\\\"))\r\n    return '\"' + s.replace(\"'\", \"'\\\\''\") + '\"'\r\n\r\n\r\ndef clean_pkg_version(version):\r\n    \"\"\"Uses pip to prepare a package version string, from our internal version.\"\"\"\r\n    return six.u(pep440_version(str(version).replace(\"==\", \"\")))\r\n\r\n\r\nclass HackedPythonVersion(object):\r\n    \"\"\"A Beautiful hack, which allows us to tell pip which version of Python we're using.\"\"\"\r\n\r\n    def __init__(self, python_version, python_path):\r\n        self.python_version = python_version\r\n        self.python_path = python_path\r\n\r\n    def __enter__(self):\r\n        # Only inject when the value is valid\r\n        if self.python_version:\r\n            os.environ[\"PIPENV_REQUESTED_PYTHON_VERSION\"] = str(self.python_version)\r\n        if self.python_path:\r\n            os.environ[\"PIP_PYTHON_PATH\"] = str(self.python_path)\r\n\r\n    def __exit__(self, *args):\r\n        # Restore original Python version information.\r\n        try:\r\n            del os.environ[\"PIPENV_REQUESTED_PYTHON_VERSION\"]\r\n        except KeyError:\r\n            pass\r\n\r\n\r\ndef prepare_pip_source_args(sources, pip_args=None):\r\n    if pip_args is None:\r\n        pip_args = []\r\n    if sources:\r\n        # Add the source to notpip.\r\n        package_url = sources[0].get(\"url\")\r\n        if not package_url:\r\n            raise PipenvUsageError(\"[[source]] section does not contain a URL.\")\r\n        pip_args.extend([\"-i\", package_url])\r\n        # Trust the host if it's not verified.\r\n        if not sources[0].get(\"verify_ssl\", True):\r\n            url_parts = urllib3_util.parse_url(package_url)\r\n            url_port = \":{0}\".format(url_parts.port) if url_parts.port else \"\"\r\n            pip_args.extend(\r\n                [\"--trusted-host\", \"{0}{1}\".format(url_parts.host, url_port)]\r\n            )\r\n        # Add additional sources as extra indexes.\r\n        if len(sources) > 1:\r\n            for source in sources[1:]:\r\n                url = source.get(\"url\")\r\n                if not url:  # not harmless, just don't continue\r\n                    continue\r\n                pip_args.extend([\"--extra-index-url\", url])\r\n                # Trust the host if it's not verified.\r\n                if not source.get(\"verify_ssl\", True):\r\n                    url_parts = urllib3_util.parse_url(url)\r\n                    url_port = \":{0}\".format(url_parts.port) if url_parts.port else \"\"\r\n                    pip_args.extend(\r\n                        [\"--trusted-host\", \"{0}{1}\".format(url_parts.host, url_port)]\r\n                    )\r\n    return pip_args\r\n\r\n\r\ndef get_project_index(index=None, trusted_hosts=None, project=None):\r\n    # type: (Optional[Union[str, TSource]], Optional[List[str]], Optional[Project]) -> TSource\r\n    from .project import SourceNotFound\r\n    if not project:\r\n        from .core import project\r\n    if trusted_hosts is None:\r\n        trusted_hosts = []\r\n    if isinstance(index, Mapping):\r\n        return project.find_source(index.get(\"url\"))\r\n    try:\r\n        source = project.find_source(index)\r\n    except SourceNotFound:\r\n        index_url = urllib3_util.parse_url(index)\r\n        src_name = project.src_name_from_url(index)\r\n        verify_ssl = index_url.host not in trusted_hosts\r\n        source = {\"url\": index, \"verify_ssl\": verify_ssl, \"name\": src_name}\r\n    return source\r\n\r\n\r\ndef get_source_list(\r\n    index=None,  # type: Optional[Union[str, TSource]]\r\n    extra_indexes=None,  # type: Optional[List[str]]\r\n    trusted_hosts=None,  # type: Optional[List[str]]\r\n    pypi_mirror=None,  # type: Optional[str]\r\n    project=None,  # type: Optional[Project]\r\n):\r\n    # type: (...) -> List[TSource]\r\n    sources = []  # type: List[TSource]\r\n    if not project:\r\n        from .core import project\r\n    if index:\r\n        sources.append(get_project_index(index))\r\n    if extra_indexes:\r\n        if isinstance(extra_indexes, six.string_types):\r\n            extra_indexes = [extra_indexes]\r\n        for source in extra_indexes:\r\n            extra_src = get_project_index(source)\r\n            if not sources or extra_src[\"url\"] != sources[0][\"url\"]:\r\n                sources.append(extra_src)\r\n        else:\r\n            for source in project.pipfile_sources:\r\n                if not sources or source[\"url\"] != sources[0][\"url\"]:\r\n                    sources.append(source)\r\n    if not sources:\r\n        sources = project.pipfile_sources[:]\r\n    if pypi_mirror:\r\n        sources = [\r\n            create_mirror_source(pypi_mirror) if is_pypi_url(source[\"url\"]) else source\r\n            for source in sources\r\n        ]\r\n    return sources\r\n\r\n\r\ndef get_indexes_from_requirement(req, project=None, index=None, extra_indexes=None, trusted_hosts=None, pypi_mirror=None):\r\n    # type: (Requirement, Optional[Project], Optional[Text], Optional[List[Text]], Optional[List[Text]], Optional[Text]) -> Tuple[TSource, List[TSource], List[Text]]\r\n    if not project:\r\n        from .core import project\r\n    index_sources = []  # type: List[TSource]\r\n    if not trusted_hosts:\r\n        trusted_hosts = []  # type: List[Text]\r\n    if extra_indexes is None:\r\n        extra_indexes = []\r\n    project_indexes = project.pipfile_sources[:]\r\n    indexes = []\r\n    if req.index:\r\n        indexes.append(req.index)\r\n    if getattr(req, \"extra_indexes\", None):\r\n        if not isinstance(req.extra_indexes, list):\r\n            indexes.append(req.extra_indexes)\r\n        else:\r\n            indexes.extend(req.extra_indexes)\r\n    indexes.extend(project_indexes)\r\n    if len(indexes) > 1:\r\n        index, extra_indexes = indexes[0], indexes[1:]\r\n    index_sources = get_source_list(index=index, extra_indexes=extra_indexes, trusted_hosts=trusted_hosts, pypi_mirror=pypi_mirror, project=project)\r\n    if len(index_sources) > 1:\r\n        index_source, extra_index_sources = index_sources[0], index_sources[1:]\r\n    else:\r\n        index_source, extra_index_sources = index_sources[0], []\r\n    return index_source, extra_index_sources\r\n\r\n\r\n@lru_cache()\r\ndef get_pipenv_sitedir():\r\n    # type: () -> Optional[str]\r\n    import pkg_resources\r\n    site_dir = next(\r\n        iter(d for d in pkg_resources.working_set if d.key.lower() == \"pipenv\"), None\r\n    )\r\n    if site_dir is not None:\r\n        return site_dir.location\r\n    return None\r\n\r\n\r\nclass Resolver(object):\r\n    def __init__(\r\n        self, constraints, req_dir, project, sources, index_lookup=None,\r\n        markers_lookup=None, skipped=None, clear=False, pre=False\r\n    ):\r\n        from pipenv.patched.piptools import logging as piptools_logging\r\n        if environments.is_verbose():\r\n            logging.log.verbose = True\r\n            piptools_logging.log.verbosity = environments.PIPENV_VERBOSITY\r\n        self.initial_constraints = constraints\r\n        self.req_dir = req_dir\r\n        self.project = project\r\n        self.sources = sources\r\n        self.resolved_tree = set()\r\n        self.hashes = {}\r\n        self.clear = clear\r\n        self.pre = pre\r\n        self.results = None\r\n        self.markers_lookup = markers_lookup if markers_lookup is not None else {}\r\n        self.index_lookup = index_lookup if index_lookup is not None else {}\r\n        self.skipped = skipped if skipped is not None else {}\r\n        self.markers = {}\r\n        self.requires_python_markers = {}\r\n        self._pip_args = None\r\n        self._constraints = None\r\n        self._parsed_constraints = None\r\n        self._resolver = None\r\n        self._repository = None\r\n        self._session = None\r\n        self._constraint_file = None\r\n        self._pip_options = None\r\n        self._pip_command = None\r\n        self._retry_attempts = 0\r\n\r\n    def __repr__(self):\r\n        return (\r\n            \"<Resolver (constraints={self.initial_constraints}, req_dir={self.req_dir}, \"\r\n            \"sources={self.sources})>\".format(self=self)\r\n        )\r\n\r\n    @staticmethod\r\n    @lru_cache()\r\n    def _get_pip_command():\r\n        from .vendor.pip_shims.shims import InstallCommand\r\n        return InstallCommand()\r\n\r\n    @classmethod\r\n    def get_metadata(\r\n        cls,\r\n        deps,  # type: List[str]\r\n        index_lookup,  # type: Dict[str, str]\r\n        markers_lookup,  # type: Dict[str, str]\r\n        project,  # type: Project\r\n        sources,  # type: Dict[str, str]\r\n        req_dir=None,  # type: Optional[str]\r\n        pre=False,  # type: bool\r\n        clear=False,  # type: bool\r\n    ):\r\n        # type: (...) -> Tuple[Set[str], Dict[str, Dict[str, Union[str, bool, List[str]]]], Dict[str, str], Dict[str, str]]\r\n        constraints = set()  # type: Set[str]\r\n        skipped = dict()  # type: Dict[str, Dict[str, Union[str, bool, List[str]]]]\r\n        if index_lookup is None:\r\n            index_lookup = {}\r\n        if markers_lookup is None:\r\n            markers_lookup = {}\r\n        if not req_dir:\r\n            from .vendor.vistir.path import create_tracked_tempdir\r\n            req_dir = create_tracked_tempdir(prefix=\"pipenv-\", suffix=\"-reqdir\")\r\n        transient_resolver = cls(\r\n            [], req_dir, project, sources, index_lookup=index_lookup,\r\n            markers_lookup=markers_lookup, clear=clear, pre=pre\r\n        )\r\n        for dep in deps:\r\n            if not dep:\r\n                continue\r\n            req, req_idx, markers_idx = cls.parse_line(\r\n                dep, index_lookup=index_lookup, markers_lookup=markers_lookup, project=project\r\n            )\r\n            index_lookup.update(req_idx)\r\n            markers_lookup.update(markers_idx)\r\n            # Add dependencies of any file (e.g. wheels/tarballs), source, or local\r\n            # directories into the initial constraint pool to be resolved with the\r\n            # rest of the dependencies, while adding the files/vcs deps/paths themselves\r\n            # to the lockfile directly\r\n            constraint_update, lockfile_update = cls.get_deps_from_req(\r\n                req, resolver=transient_resolver\r\n            )\r\n            constraints |= constraint_update\r\n            skipped.update(lockfile_update)\r\n        return constraints, skipped, index_lookup, markers_lookup\r\n\r\n    @classmethod\r\n    def parse_line(\r\n        cls,\r\n        line,  # type: str\r\n        index_lookup=None,  # type: Dict[str, str]\r\n        markers_lookup=None,  # type: Dict[str, str]\r\n        project=None  # type: Optional[Project]\r\n    ):\r\n        # type: (...) -> Tuple[Requirement, Dict[str, str], Dict[str, str]]\r\n        from .vendor.requirementslib.models.requirements import Requirement\r\n        from .vendor.requirementslib.models.utils import DIRECT_URL_RE\r\n        if index_lookup is None:\r\n            index_lookup = {}\r\n        if markers_lookup is None:\r\n            markers_lookup = {}\r\n        if project is None:\r\n            from .project import Project\r\n            project = Project()\r\n        url = None\r\n        indexes, trusted_hosts, remainder = parse_indexes(line)\r\n        if indexes:\r\n            url = indexes[0]\r\n        line = \" \".join(remainder)\r\n        req = None  # type: Requirement\r\n        try:\r\n            req = Requirement.from_line(line)\r\n        except ValueError:\r\n            direct_url = DIRECT_URL_RE.match(line)\r\n            if direct_url:\r\n                line = \"{0}#egg={1}\".format(line, direct_url.groupdict()[\"name\"])\r\n                try:\r\n                    req = Requirement.from_line(line)\r\n                except ValueError:\r\n                    raise ResolutionFailure(\"Failed to resolve requirement from line: {0!s}\".format(line))\r\n            else:\r\n                raise ResolutionFailure(\"Failed to resolve requirement from line: {0!s}\".format(line))\r\n        if url:\r\n            try:\r\n                index_lookup[req.normalized_name] = project.get_source(\r\n                    url=url, refresh=True).get(\"name\")\r\n            except TypeError:\r\n                pass\r\n        try:\r\n            req.normalized_name\r\n        except TypeError:\r\n            raise RequirementError(req=req)\r\n        # strip the marker and re-add it later after resolution\r\n        # but we will need a fallback in case resolution fails\r\n        # eg pypiwin32\r\n        if req.markers:\r\n            markers_lookup[req.normalized_name] = req.markers.replace('\"', \"'\")\r\n        return req, index_lookup, markers_lookup\r\n\r\n    @classmethod\r\n    def get_deps_from_line(cls, line):\r\n        # type: (str) -> Tuple[Set[str], Dict[str, Dict[str, Union[str, bool, List[str]]]]]\r\n        req, _, _ = cls.parse_line(line)\r\n        return cls.get_deps_from_req(req)\r\n\r\n    @classmethod\r\n    def get_deps_from_req(cls, req, resolver=None):\r\n        # type: (Requirement, Optional[\"Resolver\"]) -> Tuple[Set[str], Dict[str, Dict[str, Union[str, bool, List[str]]]]]\r\n        from .vendor.requirementslib.models.utils import _requirement_to_str_lowercase_name\r\n        from .vendor.requirementslib.models.requirements import Requirement\r\n        from requirementslib.utils import is_installable_dir\r\n        # TODO: this is way too complex, refactor this\r\n        constraints = set()  # type: Set[str]\r\n        locked_deps = dict()  # type: Dict[str, Dict[str, Union[str, bool, List[str]]]]\r\n        if (req.is_file_or_url or req.is_vcs) and not req.is_wheel:\r\n            # for local packages with setup.py files and potential direct url deps:\r\n            if req.is_vcs:\r\n                req_list, lockfile = get_vcs_deps(reqs=[req])\r\n                req = next(iter(req for req in req_list if req is not None), req_list)\r\n                entry = lockfile[pep423_name(req.normalized_name)]\r\n            else:\r\n                _, entry = req.pipfile_entry\r\n            parsed_line = req.req.parsed_line  # type: Line\r\n            setup_info = None  # type: Any\r\n            try:\r\n                name = req.normalized_name\r\n            except TypeError:\r\n                raise RequirementError(req=req)\r\n            setup_info = req.req.setup_info\r\n            setup_info.get_info()\r\n            locked_deps[pep423_name(name)] = entry\r\n            requirements = []\r\n            # Allow users to toggle resolution off for non-editable VCS packages\r\n            # but leave it on for local, installable folders on the filesystem\r\n            if environments.PIPENV_RESOLVE_VCS or (\r\n                req.editable or parsed_line.is_wheel or (\r\n                    req.is_file_or_url and parsed_line.is_local\r\n                    and is_installable_dir(parsed_line.path)\r\n                )\r\n            ):\r\n                requirements = [v for v in getattr(setup_info, \"requires\", {}).values()]\r\n            for r in requirements:\r\n                if getattr(r, \"url\", None) and not getattr(r, \"editable\", False):\r\n                    if r is not None:\r\n                        if not r.url:\r\n                            continue\r\n                        line = _requirement_to_str_lowercase_name(r)\r\n                        new_req, _, _ = cls.parse_line(line)\r\n                        if r.marker and not r.marker.evaluate():\r\n                            new_constraints = {}\r\n                            _, new_entry = req.pipfile_entry\r\n                            new_lock = {\r\n                                pep423_name(new_req.normalized_name): new_entry\r\n                            }\r\n                        else:\r\n                            new_constraints, new_lock = cls.get_deps_from_req(\r\n                                new_req, resolver\r\n                            )\r\n                        locked_deps.update(new_lock)\r\n                        constraints |= new_constraints\r\n                # if there is no marker or there is a valid marker, add the constraint line\r\n                elif r and (not r.marker or (r.marker and r.marker.evaluate())):\r\n                    line = _requirement_to_str_lowercase_name(r)\r\n                    constraints.add(line)\r\n            # ensure the top level entry remains as provided\r\n            # note that we shouldn't pin versions for editable vcs deps\r\n            if not req.is_vcs:\r\n                if req.specifiers:\r\n                    locked_deps[name][\"version\"] = req.specifiers\r\n                elif parsed_line.setup_info and parsed_line.setup_info.version:\r\n                    locked_deps[name][\"version\"] = \"=={}\".format(\r\n                        parsed_line.setup_info.version\r\n                    )\r\n            # if not req.is_vcs:\r\n            locked_deps.update({name: entry})\r\n            if req.is_vcs and req.editable:\r\n                constraints.add(req.constraint_line)\r\n            if req.is_file_or_url and req.req.is_local and req.editable and (\r\n                    req.req.setup_path is not None and os.path.exists(req.req.setup_path)):\r\n                constraints.add(req.constraint_line)\r\n        else:\r\n            # if the dependency isn't installable, don't add it to constraints\r\n            # and instead add it directly to the lock\r\n            if req and req.requirement and (\r\n                req.requirement.marker and not req.requirement.marker.evaluate()\r\n            ):\r\n                pypi = resolver.repository if resolver else None\r\n                best_match = pypi.find_best_match(req.ireq) if pypi else None\r\n                if best_match:\r\n                    hashes = resolver.collect_hashes(best_match) if resolver else []\r\n                    new_req = Requirement.from_ireq(best_match)\r\n                    new_req = new_req.add_hashes(hashes)\r\n                    name, entry = new_req.pipfile_entry\r\n                    locked_deps[pep423_name(name)] = translate_markers(entry)\r\n                return constraints, locked_deps\r\n            constraints.add(req.constraint_line)\r\n            return constraints, locked_deps\r\n        return constraints, locked_deps\r\n\r\n    @classmethod\r\n    def create(\r\n        cls,\r\n        deps,  # type: List[str]\r\n        index_lookup=None,  # type: Dict[str, str]\r\n        markers_lookup=None,  # type: Dict[str, str]\r\n        project=None,  # type: Project\r\n        sources=None,  # type: List[str]\r\n        req_dir=None,  # type: str\r\n        clear=False,  # type: bool\r\n        pre=False  # type: bool\r\n    ):\r\n        # type: (...) -> \"Resolver\"\r\n        from pipenv.vendor.vistir.path import create_tracked_tempdir\r\n        if not req_dir:\r\n            req_dir = create_tracked_tempdir(suffix=\"-requirements\", prefix=\"pipenv-\")\r\n        if index_lookup is None:\r\n            index_lookup = {}\r\n        if markers_lookup is None:\r\n            markers_lookup = {}\r\n        if project is None:\r\n            from pipenv.core import project\r\n            project = project\r\n        if sources is None:\r\n            sources = project.sources\r\n        constraints, skipped, index_lookup, markers_lookup = cls.get_metadata(\r\n            deps, index_lookup, markers_lookup, project, sources, req_dir=req_dir,\r\n            pre=pre, clear=clear\r\n        )\r\n        return Resolver(\r\n            constraints, req_dir, project, sources, index_lookup=index_lookup,\r\n            markers_lookup=markers_lookup, skipped=skipped, clear=clear, pre=pre\r\n        )\r\n\r\n    @classmethod\r\n    def from_pipfile(cls, project=None, pipfile=None, dev=False, pre=False, clear=False):\r\n        # type: (Optional[Project], Optional[Pipfile], bool, bool, bool) -> \"Resolver\"\r\n        from pipenv.vendor.vistir.path import create_tracked_tempdir\r\n        if not project:\r\n            from pipenv.core import project\r\n        if not pipfile:\r\n            pipfile = project._pipfile\r\n        req_dir = create_tracked_tempdir(suffix=\"-requirements\", prefix=\"pipenv-\")\r\n        index_lookup, markers_lookup = {}, {}\r\n        deps = set()\r\n        if dev:\r\n            deps.update(set([req.as_line() for req in pipfile.dev_packages]))\r\n        deps.update(set([req.as_line() for req in pipfile.packages]))\r\n        constraints, skipped, index_lookup, markers_lookup = cls.get_metadata(\r\n            list(deps), index_lookup, markers_lookup, project, project.sources,\r\n            req_dir=req_dir, pre=pre, clear=clear\r\n        )\r\n        return Resolver(\r\n            constraints, req_dir, project, project.sources, index_lookup=index_lookup,\r\n            markers_lookup=markers_lookup, skipped=skipped, clear=clear, pre=pre\r\n        )\r\n\r\n    @property\r\n    def pip_command(self):\r\n        if self._pip_command is None:\r\n            self._pip_command = self._get_pip_command()\r\n        return self._pip_command\r\n\r\n    def prepare_pip_args(self, use_pep517=False, build_isolation=True):\r\n        pip_args = []\r\n        if self.sources:\r\n            pip_args = prepare_pip_source_args(self.sources, pip_args)\r\n        if use_pep517 is False:\r\n            pip_args.append(\"--no-use-pep517\")\r\n        if build_isolation is False:\r\n            pip_args.append(\"--no-build-isolation\")\r\n        pip_args.extend([\"--cache-dir\", environments.PIPENV_CACHE_DIR])\r\n        return pip_args\r\n\r\n    @property\r\n    def pip_args(self):\r\n        use_pep517 = environments.get_from_env(\"USE_PEP517\", prefix=\"PIP\")\r\n        build_isolation = environments.get_from_env(\"BUILD_ISOLATION\", prefix=\"PIP\")\r\n        if self._pip_args is None:\r\n            self._pip_args = self.prepare_pip_args(\r\n                use_pep517=use_pep517, build_isolation=build_isolation\r\n            )\r\n        return self._pip_args\r\n\r\n    def prepare_constraint_file(self):\r\n        from pipenv.vendor.vistir.path import create_tracked_tempfile\r\n        constraints_file = create_tracked_tempfile(\r\n            mode=\"w\",\r\n            prefix=\"pipenv-\",\r\n            suffix=\"-constraints.txt\",\r\n            dir=self.req_dir,\r\n            delete=False,\r\n        )\r\n        skip_args = (\"build-isolation\", \"use-pep517\", \"cache-dir\")\r\n        args_to_add = [\r\n            arg for arg in self.pip_args\r\n            if not any(bad_arg in arg for bad_arg in skip_args)\r\n        ]\r\n        if self.sources:\r\n            requirementstxt_sources = \" \".join(args_to_add) if args_to_add else \"\"\r\n            requirementstxt_sources = requirementstxt_sources.replace(\" --\", \"\\n--\")\r\n            constraints_file.write(u\"{0}\\n\".format(requirementstxt_sources))\r\n        constraints = self.initial_constraints\r\n        constraints_file.write(u\"\\n\".join([c for c in constraints]))\r\n        constraints_file.close()\r\n        return constraints_file.name\r\n\r\n    @property\r\n    def constraint_file(self):\r\n        if self._constraint_file is None:\r\n            self._constraint_file = self.prepare_constraint_file()\r\n        return self._constraint_file\r\n\r\n    @property\r\n    def pip_options(self):\r\n        if self._pip_options is None:\r\n            pip_options, _ = self.pip_command.parser.parse_args(self.pip_args)\r\n            pip_options.cache_dir = environments.PIPENV_CACHE_DIR\r\n            pip_options.no_python_version_warning = True\r\n            pip_options.no_input = True\r\n            pip_options.progress_bar = \"off\"\r\n            pip_options.ignore_requires_python = True\r\n            self._pip_options = pip_options\r\n        return self._pip_options\r\n\r\n    @property\r\n    def session(self):\r\n        if self._session is None:\r\n            self._session = self.pip_command._build_session(self.pip_options)\r\n            # if environments.is_verbose():\r\n            #     click_echo(\r\n            #         crayons.blue(\"Using pip: {0}\".format(\" \".join(self.pip_args))), err=True\r\n            #     )\r\n        return self._session\r\n\r\n    @property\r\n    def repository(self):\r\n        if self._repository is None:\r\n            from pipenv.patched.piptools.repositories.pypi import PyPIRepository\r\n            self._repository = PyPIRepository(\r\n                self.pip_args, use_json=False, session=self.session,\r\n                build_isolation=self.pip_options.build_isolation\r\n            )\r\n        return self._repository\r\n\r\n    @property\r\n    def constraints(self):\r\n        if self._constraints is None:\r\n            from pip_shims.shims import parse_requirements\r\n            self._constraints = parse_requirements(\r\n                self.constraint_file, finder=self.repository.finder, session=self.session,\r\n                options=self.pip_options\r\n            )\r\n        return self._constraints\r\n\r\n    @property\r\n    def parsed_constraints(self):\r\n        if self._parsed_constraints is None:\r\n            self._parsed_constraints = [c for c in self.constraints]\r\n        return self._parsed_constraints\r\n\r\n    def get_resolver(self, clear=False, pre=False):\r\n        from pipenv.patched.piptools.resolver import Resolver as PiptoolsResolver\r\n        from pipenv.patched.piptools.cache import DependencyCache\r\n        self._resolver = PiptoolsResolver(\r\n            constraints=self.parsed_constraints, repository=self.repository,\r\n            cache=DependencyCache(environments.PIPENV_CACHE_DIR), clear_caches=clear,\r\n            # TODO: allow users to toggle the 'allow unsafe' flag to resolve setuptools?\r\n            prereleases=pre, allow_unsafe=False\r\n        )\r\n\r\n    @property\r\n    def resolver(self):\r\n        if self._resolver is None:\r\n            self.get_resolver(clear=self.clear, pre=self.pre)\r\n        return self._resolver\r\n\r\n    def resolve(self):\r\n        from pipenv.vendor.pip_shims.shims import DistributionNotFound\r\n        from pipenv.vendor.requests.exceptions import HTTPError\r\n        from pipenv.patched.piptools.exceptions import NoCandidateFound\r\n        from pipenv.patched.piptools.cache import CorruptCacheError\r\n        from .exceptions import CacheError, ResolutionFailure\r\n        with temp_environ():\r\n            os.environ[\"PIP_NO_USE_PEP517\"] = str(\"\")\r\n            try:\r\n                results = self.resolver.resolve(max_rounds=environments.PIPENV_MAX_ROUNDS)\r\n            except CorruptCacheError as e:\r\n                if environments.PIPENV_IS_CI or self.clear:\r\n                    if self._retry_attempts < 3:\r\n                        self.get_resolver(clear=True, pre=self.pre)\r\n                        self._retry_attempts += 1\r\n                        self.resolve()\r\n                else:\r\n                    raise CacheError(e.path)\r\n            except (NoCandidateFound, DistributionNotFound, HTTPError) as e:\r\n                raise ResolutionFailure(message=str(e))\r\n            else:\r\n                self.results = results\r\n                self.resolved_tree.update(results)\r\n        return self.resolved_tree\r\n\r\n    @lru_cache(maxsize=1024)\r\n    def fetch_candidate(self, ireq):\r\n        candidates = self.repository.find_all_candidates(ireq.name)\r\n        matched_version = next(iter(sorted(\r\n            ireq.specifier.filter((c.version for c in candidates), True), reverse=True)\r\n        ), None)\r\n        if matched_version:\r\n            matched_candidate = next(iter(\r\n                c for c in candidates if c.version == matched_version\r\n            ))\r\n            return matched_candidate\r\n        return None\r\n\r\n    def resolve_constraints(self):\r\n        from .vendor.requirementslib.models.markers import marker_from_specifier\r\n        new_tree = set()\r\n        for result in self.resolved_tree:\r\n            if result.markers:\r\n                self.markers[result.name] = result.markers\r\n            else:\r\n                candidate = self.fetch_candidate(result)\r\n                requires_python = getattr(candidate, \"requires_python\", None)\r\n                if requires_python:\r\n                    marker = marker_from_specifier(candidate.requires_python)\r\n                    self.markers[result.name] = marker\r\n                    result.markers = marker\r\n                    if result.req:\r\n                        result.req.marker = marker\r\n            new_tree.add(result)\r\n        self.resolved_tree = new_tree\r\n\r\n    @classmethod\r\n    def prepend_hash_types(cls, checksums):\r\n        cleaned_checksums = []\r\n        for checksum in checksums:\r\n            if not checksum:\r\n                continue\r\n            if not checksum.startswith(\"sha256:\"):\r\n                checksum = \"sha256:{0}\".format(checksum)\r\n            cleaned_checksums.append(checksum)\r\n        return cleaned_checksums\r\n\r\n    def collect_hashes(self, ireq):\r\n        from .vendor.requests import ConnectionError\r\n        collected_hashes = []\r\n        if ireq in self.hashes:\r\n            collected_hashes += list(self.hashes.get(ireq, []))\r\n        if self._should_include_hash(ireq):\r\n            try:\r\n                hash_map = self.get_hash(ireq)\r\n                collected_hashes += list(hash_map)\r\n            except (ValueError, KeyError, IndexError, ConnectionError):\r\n                pass\r\n        elif any(\r\n            \"python.org\" in source[\"url\"] or \"pypi.org\" in source[\"url\"]\r\n            for source in self.sources\r\n        ):\r\n            pkg_url = \"https://pypi.org/pypi/{0}/json\".format(ireq.name)\r\n            session = _get_requests_session()\r\n            try:\r\n                # Grab the hashes from the new warehouse API.\r\n                r = session.get(pkg_url, timeout=10)\r\n                api_releases = r.json()[\"releases\"]\r\n                cleaned_releases = {}\r\n                for api_version, api_info in api_releases.items():\r\n                    api_version = clean_pkg_version(api_version)\r\n                    cleaned_releases[api_version] = api_info\r\n                version = \"\"\r\n                if ireq.specifier:\r\n                    spec = next(iter(s for s in list(ireq.specifier._specs)), None)\r\n                    if spec:\r\n                        version = spec.version\r\n                for release in cleaned_releases[version]:\r\n                    collected_hashes.append(release[\"digests\"][\"sha256\"])\r\n                collected_hashes = self.prepend_hash_types(collected_hashes)\r\n            except (ValueError, KeyError, ConnectionError):\r\n                if environments.is_verbose():\r\n                    click_echo(\r\n                        \"{0}: Error generating hash for {1}\".format(\r\n                            crayons.red(\"Warning\", bold=True), ireq.name\r\n                        ), err=True\r\n                    )\r\n        return collected_hashes\r\n\r\n    @staticmethod\r\n    def _should_include_hash(ireq):\r\n        from pipenv.vendor.vistir.compat import Path, to_native_string\r\n        from pipenv.vendor.vistir.path import url_to_path\r\n\r\n        # We can only hash artifacts.\r\n        try:\r\n            if not ireq.link.is_artifact:\r\n                return False\r\n        except AttributeError:\r\n            return False\r\n\r\n        # But we don't want normal pypi artifcats since the normal resolver\r\n        # handles those\r\n        if is_pypi_url(ireq.link.url):\r\n            return False\r\n\r\n        # We also don't want to try to hash directories as this will fail\r\n        # as these are editable deps and are not hashable.\r\n        if (\r\n            ireq.link.scheme == \"file\"\r\n            and Path(to_native_string(url_to_path(ireq.link.url))).is_dir()\r\n        ):\r\n            return False\r\n        return True\r\n\r\n    def get_hash(self, ireq, ireq_hashes=None):\r\n        \"\"\"\r\n        Retrieve hashes for a specific ``InstallRequirement`` instance.\r\n\r\n        :param ireq: An ``InstallRequirement`` to retrieve hashes for\r\n        :type ireq: :class:`~pip_shims.InstallRequirement`\r\n        :return: A set of hashes.\r\n        :rtype: Set\r\n        \"\"\"\r\n\r\n        # We _ALWAYS MUST PRIORITIZE_ the inclusion of hashes from local sources\r\n        # PLEASE *DO NOT MODIFY THIS* TO CHECK WHETHER AN IREQ ALREADY HAS A HASH\r\n        # RESOLVED. The resolver will pull hashes from PyPI and only from PyPI.\r\n        # The entire purpose of this approach is to include missing hashes.\r\n        # This fixes a race condition in resolution for missing dependency caches\r\n        # see pypa/pipenv#3289\r\n        if not self._should_include_hash(ireq):\r\n            return add_to_set(set(), ireq_hashes)\r\n        elif self._should_include_hash(ireq) and (\r\n            not ireq_hashes or ireq.link.scheme == \"file\"\r\n        ):\r\n            if not ireq_hashes:\r\n                ireq_hashes = set()\r\n            new_hashes = self.resolver.repository._hash_cache.get_hash(ireq.link)\r\n            ireq_hashes = add_to_set(ireq_hashes, new_hashes)\r\n        else:\r\n            ireq_hashes = set(ireq_hashes)\r\n        # The _ONLY CASE_ where we flat out set the value is if it isn't present\r\n        # It's a set, so otherwise we *always* need to do a union update\r\n        if ireq not in self.hashes:\r\n            return ireq_hashes\r\n        else:\r\n            return self.hashes[ireq] | ireq_hashes\r\n\r\n    def resolve_hashes(self):\r\n        if self.results is not None:\r\n            resolved_hashes = self.resolver.resolve_hashes(self.results)\r\n            for ireq, ireq_hashes in resolved_hashes.items():\r\n                self.hashes[ireq] = self.get_hash(ireq, ireq_hashes=ireq_hashes)\r\n            return self.hashes\r\n\r\n    def _clean_skipped_result(self, req, value):\r\n        ref = None\r\n        if req.is_vcs:\r\n            ref = req.commit_hash\r\n        ireq = req.as_ireq()\r\n        entry = value.copy()\r\n        entry[\"name\"] = req.name\r\n        if entry.get(\"editable\", False) and entry.get(\"version\"):\r\n            del entry[\"version\"]\r\n        ref = ref if ref is not None else entry.get(\"ref\")\r\n        if ref:\r\n            entry[\"ref\"] = ref\r\n        if self._should_include_hash(ireq):\r\n            collected_hashes = self.collect_hashes(ireq)\r\n            if collected_hashes:\r\n                entry[\"hashes\"] = sorted(set(collected_hashes))\r\n        return req.name, entry\r\n\r\n    def clean_results(self):\r\n        from pipenv.vendor.requirementslib.models.requirements import Requirement\r\n        reqs = [(Requirement.from_ireq(ireq), ireq) for ireq in self.resolved_tree]\r\n        results = {}\r\n        for req, ireq in reqs:\r\n            if (req.vcs and req.editable and not req.is_direct_url):\r\n                continue\r\n            elif req.normalized_name in self.skipped.keys():\r\n                continue\r\n            collected_hashes = self.collect_hashes(ireq)\r\n            req = req.add_hashes(collected_hashes)\r\n            if not collected_hashes and self._should_include_hash(ireq):\r\n                discovered_hashes = self.hashes.get(ireq, set()) | self.get_hash(ireq)\r\n                if discovered_hashes:\r\n                    req = req.add_hashes(discovered_hashes)\r\n                self.hashes[ireq] = collected_hashes = discovered_hashes\r\n            if collected_hashes:\r\n                collected_hashes = sorted(set(collected_hashes))\r\n            name, entry = format_requirement_for_lockfile(\r\n                req, self.markers_lookup, self.index_lookup, collected_hashes\r\n            )\r\n            entry = translate_markers(entry)\r\n            if name in results:\r\n                results[name].update(entry)\r\n            else:\r\n                results[name] = entry\r\n        for k in list(self.skipped.keys()):\r\n            req = Requirement.from_pipfile(k, self.skipped[k])\r\n            name, entry = self._clean_skipped_result(req, self.skipped[k])\r\n            entry = translate_markers(entry)\r\n            if name in results:\r\n                results[name].update(entry)\r\n            else:\r\n                results[name] = entry\r\n        results = list(results.values())\r\n        return results\r\n\r\n\r\ndef format_requirement_for_lockfile(req, markers_lookup, index_lookup, hashes=None):\r\n    if req.specifiers:\r\n        version = str(req.get_version())\r\n    else:\r\n        version = None\r\n    index = index_lookup.get(req.normalized_name)\r\n    markers = markers_lookup.get(req.normalized_name)\r\n    req.index = index\r\n    name, pf_entry = req.pipfile_entry\r\n    name = pep423_name(req.name)\r\n    entry = {}\r\n    if isinstance(pf_entry, six.string_types):\r\n        entry[\"version\"] = pf_entry.lstrip(\"=\")\r\n    else:\r\n        entry.update(pf_entry)\r\n        if version is not None and not req.is_vcs:\r\n            entry[\"version\"] = version\r\n        if req.line_instance.is_direct_url and not req.is_vcs:\r\n            entry[\"file\"] = req.req.uri\r\n    if hashes:\r\n        entry[\"hashes\"] = sorted(set(hashes))\r\n    entry[\"name\"] = name\r\n    if index:\r\n        entry.update({\"index\": index})\r\n    if markers:\r\n        entry.update({\"markers\": markers})\r\n    entry = translate_markers(entry)\r\n    if req.vcs or req.editable:\r\n        for key in (\"index\", \"version\", \"file\"):\r\n            try:\r\n                del entry[key]\r\n            except KeyError:\r\n                pass\r\n    return name, entry\r\n\r\n\r\ndef _show_warning(message, category, filename, lineno, line):\r\n    warnings.showwarning(message=message, category=category, filename=filename,\r\n                         lineno=lineno, file=sys.stderr, line=line)\r\n    sys.stderr.flush()\r\n\r\n\r\ndef actually_resolve_deps(\r\n    deps,\r\n    index_lookup,\r\n    markers_lookup,\r\n    project,\r\n    sources,\r\n    clear,\r\n    pre,\r\n    req_dir=None,\r\n):\r\n    from pipenv.vendor.vistir.path import create_tracked_tempdir\r\n\r\n    if not req_dir:\r\n        req_dir = create_tracked_tempdir(suffix=\"-requirements\", prefix=\"pipenv-\")\r\n    warning_list = []\r\n\r\n    with warnings.catch_warnings(record=True) as warning_list:\r\n        resolver = Resolver.create(\r\n            deps, index_lookup, markers_lookup, project, sources, req_dir, clear, pre\r\n        )\r\n        resolver.resolve()\r\n        hashes = resolver.resolve_hashes()\r\n        resolver.resolve_constraints()\r\n        results = resolver.clean_results()\r\n    for warning in warning_list:\r\n        _show_warning(warning.message, warning.category, warning.filename, warning.lineno,\r\n                      warning.line)\r\n    return (results, hashes, resolver.markers_lookup, resolver, resolver.skipped)\r\n\r\n\r\n@contextlib.contextmanager\r\ndef create_spinner(text, nospin=None, spinner_name=None):\r\n    from .vendor.vistir import spin\r\n    from .vendor.vistir.misc import fs_str\r\n    if not spinner_name:\r\n        spinner_name = environments.PIPENV_SPINNER\r\n    if nospin is None:\r\n        nospin = environments.PIPENV_NOSPIN\r\n    with spin.create_spinner(\r\n        spinner_name=spinner_name,\r\n        start_text=fs_str(text),\r\n        nospin=nospin, write_to_stdout=False\r\n    ) as sp:\r\n        yield sp\r\n\r\n\r\ndef resolve(cmd, sp):\r\n    import delegator\r\n    from .cmdparse import Script\r\n    from .vendor.pexpect.exceptions import EOF, TIMEOUT\r\n    from .vendor.vistir.compat import to_native_string\r\n    from .vendor.vistir.misc import echo\r\n    EOF.__module__ = \"pexpect.exceptions\"\r\n    from ._compat import decode_output\r\n    c = delegator.run(Script.parse(cmd).cmdify(), block=False, env=os.environ.copy())\r\n    if environments.is_verbose():\r\n        c.subprocess.logfile = sys.stderr\r\n    _out = decode_output(\"\")\r\n    result = None\r\n    out = to_native_string(\"\")\r\n    while True:\r\n        result = None\r\n        try:\r\n            result = c.expect(u\"\\n\", timeout=environments.PIPENV_INSTALL_TIMEOUT)\r\n        except TIMEOUT:\r\n            pass\r\n        except EOF:\r\n            break\r\n        except KeyboardInterrupt:\r\n            c.kill()\r\n            break\r\n        if result:\r\n            _out = c.subprocess.before\r\n            _out = decode_output(\"{0}\".format(_out))\r\n            out += _out\r\n            # sp.text = to_native_string(\"{0}\".format(_out[:100]))\r\n            if environments.is_verbose():\r\n                sp.hide_and_write(out.splitlines()[-1].rstrip())\r\n        else:\r\n            break\r\n    c.block()\r\n    if c.return_code != 0:\r\n        sp.red.fail(environments.PIPENV_SPINNER_FAIL_TEXT.format(\r\n            \"Locking Failed!\"\r\n        ))\r\n        echo(c.out.strip(), err=True)\r\n        if not environments.is_verbose():\r\n            echo(out, err=True)\r\n        sys.exit(c.return_code)\r\n    if environments.is_verbose():\r\n        echo(c.err.strip(), err=True)\r\n    return c\r\n\r\n\r\ndef get_locked_dep(dep, pipfile_section, prefer_pipfile=True):\r\n    # the prefer pipfile flag is not used yet, but we are introducing\r\n    # it now for development purposes\r\n    # TODO: Is this implementation clear? How can it be improved?\r\n    entry = None\r\n    cleaner_kwargs = {\r\n        \"is_top_level\": False,\r\n        \"pipfile_entry\": None\r\n    }\r\n    if isinstance(dep, Mapping) and dep.get(\"name\", \"\"):\r\n        dep_name = pep423_name(dep[\"name\"])\r\n        name = next(iter(\r\n            k for k in pipfile_section.keys()\r\n            if pep423_name(k) == dep_name\r\n        ), None)\r\n        entry = pipfile_section[name] if name else None\r\n\r\n    if entry:\r\n        cleaner_kwargs.update({\"is_top_level\": True, \"pipfile_entry\": entry})\r\n    lockfile_entry = clean_resolved_dep(dep, **cleaner_kwargs)\r\n    if entry and isinstance(entry, Mapping):\r\n        version = entry.get(\"version\", \"\") if entry else \"\"\r\n    else:\r\n        version = entry if entry else \"\"\r\n    lockfile_name, lockfile_dict = lockfile_entry.copy().popitem()\r\n    lockfile_version = lockfile_dict.get(\"version\", \"\")\r\n    # Keep pins from the lockfile\r\n    if prefer_pipfile and lockfile_version != version and version.startswith(\"==\"):\r\n        lockfile_dict[\"version\"] = version\r\n    lockfile_entry[lockfile_name] = lockfile_dict\r\n    return lockfile_entry\r\n\r\n\r\ndef prepare_lockfile(results, pipfile, lockfile):\r\n    # from .vendor.requirementslib.utils import is_vcs\r\n    for dep in results:\r\n        if not dep:\r\n            continue\r\n        # Merge in any relevant information from the pipfile entry, including\r\n        # markers, normalized names, URL info, etc that we may have dropped during lock\r\n        # if not is_vcs(dep):\r\n        lockfile_entry = get_locked_dep(dep, pipfile)\r\n        name = next(iter(k for k in lockfile_entry.keys()))\r\n        current_entry = lockfile.get(name)\r\n        if current_entry:\r\n            if not isinstance(current_entry, Mapping):\r\n                lockfile[name] = lockfile_entry[name]\r\n            else:\r\n                lockfile[name].update(lockfile_entry[name])\r\n                lockfile[name] = translate_markers(lockfile[name])\r\n        else:\r\n            lockfile[name] = lockfile_entry[name]\r\n    return lockfile\r\n\r\n\r\ndef venv_resolve_deps(\r\n    deps,\r\n    which,\r\n    project,\r\n    pre=False,\r\n    clear=False,\r\n    allow_global=False,\r\n    pypi_mirror=None,\r\n    dev=False,\r\n    pipfile=None,\r\n    lockfile=None,\r\n    keep_outdated=False\r\n):\r\n    \"\"\"\r\n    Resolve dependencies for a pipenv project, acts as a portal to the target environment.\r\n\r\n    Regardless of whether a virtual environment is present or not, this will spawn\r\n    a subproces which is isolated to the target environment and which will perform\r\n    dependency resolution.  This function reads the output of that call and mutates\r\n    the provided lockfile accordingly, returning nothing.\r\n\r\n    :param List[:class:`~requirementslib.Requirement`] deps: A list of dependencies to resolve.\r\n    :param Callable which: [description]\r\n    :param project: The pipenv Project instance to use during resolution\r\n    :param Optional[bool] pre: Whether to resolve pre-release candidates, defaults to False\r\n    :param Optional[bool] clear: Whether to clear the cache during resolution, defaults to False\r\n    :param Optional[bool] allow_global: Whether to use *sys.executable* as the python binary, defaults to False\r\n    :param Optional[str] pypi_mirror: A URL to substitute any time *pypi.org* is encountered, defaults to None\r\n    :param Optional[bool] dev: Whether to target *dev-packages* or not, defaults to False\r\n    :param pipfile: A Pipfile section to operate on, defaults to None\r\n    :type pipfile: Optional[Dict[str, Union[str, Dict[str, bool, List[str]]]]]\r\n    :param Dict[str, Any] lockfile: A project lockfile to mutate, defaults to None\r\n    :param bool keep_outdated: Whether to retain outdated dependencies and resolve with them in mind, defaults to False\r\n    :raises RuntimeError: Raised on resolution failure\r\n    :return: Nothing\r\n    :rtype: None\r\n    \"\"\"\r\n\r\n    from .vendor.vistir.misc import fs_str\r\n    from .vendor.vistir.compat import Path, JSONDecodeError, NamedTemporaryFile\r\n    from .vendor.vistir.path import create_tracked_tempdir\r\n    from . import resolver\r\n    from ._compat import decode_for_output\r\n    import json\r\n\r\n    results = []\r\n    pipfile_section = \"dev-packages\" if dev else \"packages\"\r\n    lockfile_section = \"develop\" if dev else \"default\"\r\n    if not deps:\r\n        if not project.pipfile_exists:\r\n            return None\r\n        deps = project.parsed_pipfile.get(pipfile_section, {})\r\n    if not deps:\r\n        return None\r\n\r\n    if not pipfile:\r\n        pipfile = getattr(project, pipfile_section, {})\r\n    if not lockfile:\r\n        lockfile = project._lockfile\r\n    req_dir = create_tracked_tempdir(prefix=\"pipenv\", suffix=\"requirements\")\r\n    cmd = [\r\n        which(\"python\", allow_global=allow_global),\r\n        Path(resolver.__file__.rstrip(\"co\")).as_posix()\r\n    ]\r\n    if pre:\r\n        cmd.append(\"--pre\")\r\n    if clear:\r\n        cmd.append(\"--clear\")\r\n    if allow_global:\r\n        cmd.append(\"--system\")\r\n    if dev:\r\n        cmd.append(\"--dev\")\r\n    target_file = NamedTemporaryFile(prefix=\"resolver\", suffix=\".json\", delete=False)\r\n    target_file.close()\r\n    cmd.extend([\"--write\", make_posix(target_file.name)])\r\n    with temp_environ():\r\n        os.environ.update({fs_str(k): fs_str(val) for k, val in os.environ.items()})\r\n        if pypi_mirror:\r\n            os.environ[\"PIPENV_PYPI_MIRROR\"] = str(pypi_mirror)\r\n        os.environ[\"PIPENV_VERBOSITY\"] = str(environments.PIPENV_VERBOSITY)\r\n        os.environ[\"PIPENV_REQ_DIR\"] = fs_str(req_dir)\r\n        os.environ[\"PIP_NO_INPUT\"] = fs_str(\"1\")\r\n        pipenv_site_dir = get_pipenv_sitedir()\r\n        if pipenv_site_dir is not None:\r\n            os.environ[\"PIPENV_SITE_DIR\"] = pipenv_site_dir\r\n        else:\r\n            os.environ.pop(\"PIPENV_SITE_DIR\", None)\r\n        if keep_outdated:\r\n            os.environ[\"PIPENV_KEEP_OUTDATED\"] = fs_str(\"1\")\r\n        with create_spinner(text=decode_for_output(\"Locking...\")) as sp:\r\n            # This conversion is somewhat slow on local and file-type requirements since\r\n            # we now download those requirements / make temporary folders to perform\r\n            # dependency resolution on them, so we are including this step inside the\r\n            # spinner context manager for the UX improvement\r\n            sp.write(decode_for_output(\"Building requirements...\"))\r\n            deps = convert_deps_to_pip(\r\n                deps, project, r=False, include_index=True\r\n            )\r\n            constraints = set(deps)\r\n            os.environ[\"PIPENV_PACKAGES\"] = str(\"\\n\".join(constraints))\r\n            sp.write(decode_for_output(\"Resolving dependencies...\"))\r\n            c = resolve(cmd, sp)\r\n            results = c.out.strip()\r\n            if c.ok:\r\n                sp.green.ok(environments.PIPENV_SPINNER_OK_TEXT.format(\"Success!\"))\r\n            else:\r\n                sp.red.fail(environments.PIPENV_SPINNER_FAIL_TEXT.format(\"Locking Failed!\"))\r\n                click_echo(\"Output: {0}\".format(c.out.strip()), err=True)\r\n                click_echo(\"Error: {0}\".format(c.err.strip()), err=True)\r\n    try:\r\n        with open(target_file.name, \"r\") as fh:\r\n            results = json.load(fh)\r\n    except (IndexError, JSONDecodeError):\r\n        click_echo(c.out.strip(), err=True)\r\n        click_echo(c.err.strip(), err=True)\r\n        if os.path.exists(target_file.name):\r\n            os.unlink(target_file.name)\r\n        raise RuntimeError(\"There was a problem with locking.\")\r\n    if os.path.exists(target_file.name):\r\n        os.unlink(target_file.name)\r\n    if lockfile_section not in lockfile:\r\n        lockfile[lockfile_section] = {}\r\n    prepare_lockfile(results, pipfile, lockfile[lockfile_section])\r\n\r\n\r\ndef resolve_deps(\r\n    deps,\r\n    which,\r\n    project,\r\n    sources=None,\r\n    python=False,\r\n    clear=False,\r\n    pre=False,\r\n    allow_global=False,\r\n    req_dir=None\r\n):\r\n    \"\"\"Given a list of dependencies, return a resolved list of dependencies,\r\n    using pip-tools -- and their hashes, using the warehouse API / pip.\r\n    \"\"\"\r\n    index_lookup = {}\r\n    markers_lookup = {}\r\n    python_path = which(\"python\", allow_global=allow_global)\r\n    if not os.environ.get(\"PIP_SRC\"):\r\n        os.environ[\"PIP_SRC\"] = project.virtualenv_src_location\r\n    backup_python_path = sys.executable\r\n    results = []\r\n    resolver = None\r\n    if not deps:\r\n        return results, resolver\r\n    # First (proper) attempt:\r\n    req_dir = req_dir if req_dir else os.environ.get(\"req_dir\", None)\r\n    if not req_dir:\r\n        from .vendor.vistir.path import create_tracked_tempdir\r\n        req_dir = create_tracked_tempdir(prefix=\"pipenv-\", suffix=\"-requirements\")\r\n    with HackedPythonVersion(python_version=python, python_path=python_path):\r\n        try:\r\n            results, hashes, markers_lookup, resolver, skipped = actually_resolve_deps(\r\n                deps,\r\n                index_lookup,\r\n                markers_lookup,\r\n                project,\r\n                sources,\r\n                clear,\r\n                pre,\r\n                req_dir=req_dir,\r\n            )\r\n        except RuntimeError:\r\n            # Don't exit here, like usual.\r\n            results = None\r\n    # Second (last-resort) attempt:\r\n    if results is None:\r\n        with HackedPythonVersion(\r\n            python_version=\".\".join([str(s) for s in sys.version_info[:3]]),\r\n            python_path=backup_python_path,\r\n        ):\r\n            try:\r\n                # Attempt to resolve again, with different Python version information,\r\n                # particularly for particularly particular packages.\r\n                results, hashes, markers_lookup, resolver, skipped = actually_resolve_deps(\r\n                    deps,\r\n                    index_lookup,\r\n                    markers_lookup,\r\n                    project,\r\n                    sources,\r\n                    clear,\r\n                    pre,\r\n                    req_dir=req_dir,\r\n                )\r\n            except RuntimeError:\r\n                sys.exit(1)\r\n    return results, resolver\r\n\r\n\r\ndef is_star(val):\r\n    return isinstance(val, six.string_types) and val == \"*\"\r\n\r\n\r\ndef is_pinned(val):\r\n    if isinstance(val, Mapping):\r\n        val = val.get(\"version\")\r\n    return isinstance(val, six.string_types) and val.startswith(\"==\")\r\n\r\n\r\ndef convert_deps_to_pip(deps, project=None, r=True, include_index=True):\r\n    \"\"\"\"Converts a Pipfile-formatted dependency to a pip-formatted one.\"\"\"\r\n    from .vendor.requirementslib.models.requirements import Requirement\r\n\r\n    dependencies = []\r\n    for dep_name, dep in deps.items():\r\n        if project:\r\n            project.clear_pipfile_cache()\r\n        indexes = getattr(project, \"pipfile_sources\", []) if project is not None else []\r\n        new_dep = Requirement.from_pipfile(dep_name, dep)\r\n        if new_dep.index:\r\n            include_index = True\r\n        req = new_dep.as_line(sources=indexes if include_index else None).strip()\r\n        dependencies.append(req)\r\n    if not r:\r\n        return dependencies\r\n\r\n    # Write requirements.txt to tmp directory.\r\n    from .vendor.vistir.path import create_tracked_tempfile\r\n    f = create_tracked_tempfile(suffix=\"-requirements.txt\", delete=False)\r\n    f.write(\"\\n\".join(dependencies).encode(\"utf-8\"))\r\n    f.close()\r\n    return f.name\r\n\r\n\r\ndef mkdir_p(newdir):\r\n    \"\"\"works the way a good mkdir should :)\r\n        - already exists, silently complete\r\n        - regular file in the way, raise an exception\r\n        - parent directory(ies) does not exist, make them as well\r\n        From: http://code.activestate.com/recipes/82465-a-friendly-mkdir/\r\n    \"\"\"\r\n    if os.path.isdir(newdir):\r\n        pass\r\n    elif os.path.isfile(newdir):\r\n        raise OSError(\r\n            \"a file with the same name as the desired dir, '{0}', already exists.\".format(\r\n                newdir\r\n            )\r\n        )\r\n\r\n    else:\r\n        head, tail = os.path.split(newdir)\r\n        if head and not os.path.isdir(head):\r\n            mkdir_p(head)\r\n        if tail:\r\n            # Even though we've checked that the directory doesn't exist above, it might exist\r\n            # now if some other process has created it between now and the time we checked it.\r\n            try:\r\n                os.mkdir(newdir)\r\n            except OSError as exn:\r\n                # If we failed because the directory does exist, that's not a problem -\r\n                # that's what we were trying to do anyway. Only re-raise the exception\r\n                # if we failed for some other reason.\r\n                if exn.errno != errno.EEXIST:\r\n                    raise\r\n\r\n\r\ndef is_required_version(version, specified_version):\r\n    \"\"\"Check to see if there's a hard requirement for version\r\n    number provided in the Pipfile.\r\n    \"\"\"\r\n    # Certain packages may be defined with multiple values.\r\n    if isinstance(specified_version, dict):\r\n        specified_version = specified_version.get(\"version\", \"\")\r\n    if specified_version.startswith(\"==\"):\r\n        return version.strip() == specified_version.split(\"==\")[1].strip()\r\n\r\n    return True\r\n\r\n\r\ndef is_editable(pipfile_entry):\r\n    if hasattr(pipfile_entry, \"get\"):\r\n        return pipfile_entry.get(\"editable\", False) and any(\r\n            pipfile_entry.get(key) for key in (\"file\", \"path\") + VCS_LIST\r\n        )\r\n    return False\r\n\r\n\r\ndef is_installable_file(path):\r\n    \"\"\"Determine if a path can potentially be installed\"\"\"\r\n    from .vendor.pip_shims.shims import is_installable_dir, is_archive_file\r\n    from .patched.notpip._internal.utils.packaging import specifiers\r\n    from ._compat import Path\r\n\r\n    if hasattr(path, \"keys\") and any(\r\n        key for key in path.keys() if key in [\"file\", \"path\"]\r\n    ):\r\n        path = urlparse(path[\"file\"]).path if \"file\" in path else path[\"path\"]\r\n    if not isinstance(path, six.string_types) or path == \"*\":\r\n        return False\r\n\r\n    # If the string starts with a valid specifier operator, test if it is a valid\r\n    # specifier set before making a path object (to avoid breaking windows)\r\n    if any(path.startswith(spec) for spec in \"!=<>~\"):\r\n        try:\r\n            specifiers.SpecifierSet(path)\r\n        # If this is not a valid specifier, just move on and try it as a path\r\n        except specifiers.InvalidSpecifier:\r\n            pass\r\n        else:\r\n            return False\r\n\r\n    if not os.path.exists(os.path.abspath(path)):\r\n        return False\r\n\r\n    lookup_path = Path(path)\r\n    absolute_path = \"{0}\".format(lookup_path.absolute())\r\n    if lookup_path.is_dir() and is_installable_dir(absolute_path):\r\n        return True\r\n\r\n    elif lookup_path.is_file() and is_archive_file(absolute_path):\r\n        return True\r\n\r\n    return False\r\n\r\n\r\ndef is_file(package):\r\n    \"\"\"Determine if a package name is for a File dependency.\"\"\"\r\n    if hasattr(package, \"keys\"):\r\n        return any(key for key in package.keys() if key in [\"file\", \"path\"])\r\n\r\n    if os.path.exists(str(package)):\r\n        return True\r\n\r\n    for start in SCHEME_LIST:\r\n        if str(package).startswith(start):\r\n            return True\r\n\r\n    return False\r\n\r\n\r\ndef pep440_version(version):\r\n    \"\"\"Normalize version to PEP 440 standards\"\"\"\r\n    from .vendor.pip_shims.shims import parse_version\r\n\r\n    # Use pip built-in version parser.\r\n    return str(parse_version(version))\r\n\r\n\r\ndef pep423_name(name):\r\n    \"\"\"Normalize package name to PEP 423 style standard.\"\"\"\r\n    name = name.lower()\r\n    if any(i not in name for i in (VCS_LIST + SCHEME_LIST)):\r\n        return name.replace(\"_\", \"-\")\r\n\r\n    else:\r\n        return name\r\n\r\n\r\ndef proper_case(package_name):\r\n    \"\"\"Properly case project name from pypi.org.\"\"\"\r\n    # Hit the simple API.\r\n    r = _get_requests_session().get(\r\n        \"https://pypi.org/pypi/{0}/json\".format(package_name), timeout=0.3, stream=True\r\n    )\r\n    if not r.ok:\r\n        raise IOError(\r\n            \"Unable to find package {0} in PyPI repository.\".format(package_name)\r\n        )\r\n\r\n    r = parse.parse(\"https://pypi.org/pypi/{name}/json\", r.url)\r\n    good_name = r[\"name\"]\r\n    return good_name\r\n\r\n\r\ndef get_windows_path(*args):\r\n    \"\"\"Sanitize a path for windows environments\r\n\r\n    Accepts an arbitrary list of arguments and makes a clean windows path\"\"\"\r\n    return os.path.normpath(os.path.join(*args))\r\n\r\n\r\ndef find_windows_executable(bin_path, exe_name):\r\n    \"\"\"Given an executable name, search the given location for an executable\"\"\"\r\n    requested_path = get_windows_path(bin_path, exe_name)\r\n    if os.path.isfile(requested_path):\r\n        return requested_path\r\n\r\n    try:\r\n        pathext = os.environ[\"PATHEXT\"]\r\n    except KeyError:\r\n        pass\r\n    else:\r\n        for ext in pathext.split(os.pathsep):\r\n            path = get_windows_path(bin_path, exe_name + ext.strip().lower())\r\n            if os.path.isfile(path):\r\n                return path\r\n\r\n    return find_executable(exe_name)\r\n\r\n\r\ndef path_to_url(path):\r\n    from ._compat import Path\r\n\r\n    return Path(normalize_drive(os.path.abspath(path))).as_uri()\r\n\r\n\r\ndef normalize_path(path):\r\n    return os.path.expandvars(os.path.expanduser(\r\n        os.path.normcase(os.path.normpath(os.path.abspath(str(path))))\r\n    ))\r\n\r\n\r\ndef get_url_name(url):\r\n    if not isinstance(url, six.string_types):\r\n        return\r\n    return urllib3_util.parse_url(url).host\r\n\r\n\r\ndef get_canonical_names(packages):\r\n    \"\"\"Canonicalize a list of packages and return a set of canonical names\"\"\"\r\n    from .vendor.packaging.utils import canonicalize_name\r\n\r\n    if not isinstance(packages, Sequence):\r\n        if not isinstance(packages, six.string_types):\r\n            return packages\r\n        packages = [packages]\r\n    return set([canonicalize_name(pkg) for pkg in packages if pkg])\r\n\r\n\r\ndef walk_up(bottom):\r\n    \"\"\"Mimic os.walk, but walk 'up' instead of down the directory tree.\r\n    From: https://gist.github.com/zdavkeos/1098474\r\n    \"\"\"\r\n    bottom = os.path.realpath(bottom)\r\n    # Get files in current dir.\r\n    try:\r\n        names = os.listdir(bottom)\r\n    except Exception:\r\n        return\r\n\r\n    dirs, nondirs = [], []\r\n    for name in names:\r\n        if os.path.isdir(os.path.join(bottom, name)):\r\n            dirs.append(name)\r\n        else:\r\n            nondirs.append(name)\r\n    yield bottom, dirs, nondirs\r\n\r\n    new_path = os.path.realpath(os.path.join(bottom, \"..\"))\r\n    # See if we are at the top.\r\n    if new_path == bottom:\r\n        return\r\n\r\n    for x in walk_up(new_path):\r\n        yield x\r\n\r\n\r\ndef find_requirements(max_depth=3):\r\n    \"\"\"Returns the path of a requirements.txt file in parent directories.\"\"\"\r\n    i = 0\r\n    for c, d, f in walk_up(os.getcwd()):\r\n        i += 1\r\n        if i < max_depth:\r\n            r = os.path.join(c, \"requirements.txt\")\r\n            if os.path.isfile(r):\r\n                return r\r\n\r\n    raise RuntimeError(\"No requirements.txt found!\")\r\n\r\n\r\n# Borrowed from Pew.\r\n# See https://github.com/berdario/pew/blob/master/pew/_utils.py#L82\r\n@contextmanager\r\ndef temp_environ():\r\n    \"\"\"Allow the ability to set os.environ temporarily\"\"\"\r\n    environ = dict(os.environ)\r\n    try:\r\n        yield\r\n\r\n    finally:\r\n        os.environ.clear()\r\n        os.environ.update(environ)\r\n\r\n\r\n@contextmanager\r\ndef temp_path():\r\n    \"\"\"Allow the ability to set os.environ temporarily\"\"\"\r\n    path = [p for p in sys.path]\r\n    try:\r\n        yield\r\n    finally:\r\n        sys.path = [p for p in path]\r\n\r\n\r\ndef load_path(python):\r\n    from ._compat import Path\r\n    import delegator\r\n    import json\r\n    python = Path(python).as_posix()\r\n    json_dump_commmand = '\"import json, sys; print(json.dumps(sys.path));\"'\r\n    c = delegator.run('\"{0}\" -c {1}'.format(python, json_dump_commmand))\r\n    if c.return_code == 0:\r\n        return json.loads(c.out.strip())\r\n    else:\r\n        return []\r\n\r\n\r\ndef is_valid_url(url):\r\n    \"\"\"Checks if a given string is an url\"\"\"\r\n    pieces = urlparse(url)\r\n    return all([pieces.scheme, pieces.netloc])\r\n\r\n\r\ndef is_pypi_url(url):\r\n    return bool(re.match(r\"^http[s]?:\\/\\/pypi(?:\\.python)?\\.org\\/simple[\\/]?$\", url))\r\n\r\n\r\ndef replace_pypi_sources(sources, pypi_replacement_source):\r\n    return [pypi_replacement_source] + [\r\n        source for source in sources if not is_pypi_url(source[\"url\"])\r\n    ]\r\n\r\n\r\ndef create_mirror_source(url):\r\n    return {\r\n        \"url\": url,\r\n        \"verify_ssl\": url.startswith(\"https://\"),\r\n        \"name\": urlparse(url).hostname,\r\n    }\r\n\r\n\r\ndef download_file(url, filename):\r\n    \"\"\"Downloads file from url to a path with filename\"\"\"\r\n    r = _get_requests_session().get(url, stream=True)\r\n    if not r.ok:\r\n        raise IOError(\"Unable to download file\")\r\n\r\n    with open(filename, \"wb\") as f:\r\n        f.write(r.content)\r\n\r\n\r\ndef normalize_drive(path):\r\n    \"\"\"Normalize drive in path so they stay consistent.\r\n\r\n    This currently only affects local drives on Windows, which can be\r\n    identified with either upper or lower cased drive names. The case is\r\n    always converted to uppercase because it seems to be preferred.\r\n\r\n    See: <https://github.com/pypa/pipenv/issues/1218>\r\n    \"\"\"\r\n    if os.name != \"nt\" or not isinstance(path, six.string_types):\r\n        return path\r\n\r\n    drive, tail = os.path.splitdrive(path)\r\n    # Only match (lower cased) local drives (e.g. 'c:'), not UNC mounts.\r\n    if drive.islower() and len(drive) == 2 and drive[1] == \":\":\r\n        return \"{}{}\".format(drive.upper(), tail)\r\n\r\n    return path\r\n\r\n\r\ndef is_readonly_path(fn):\r\n    \"\"\"Check if a provided path exists and is readonly.\r\n\r\n    Permissions check is `bool(path.stat & stat.S_IREAD)` or `not os.access(path, os.W_OK)`\r\n    \"\"\"\r\n    if os.path.exists(fn):\r\n        return (os.stat(fn).st_mode & stat.S_IREAD) or not os.access(fn, os.W_OK)\r\n\r\n    return False\r\n\r\n\r\ndef set_write_bit(fn):\r\n    if isinstance(fn, six.string_types) and not os.path.exists(fn):\r\n        return\r\n    os.chmod(fn, stat.S_IWRITE | stat.S_IWUSR | stat.S_IRUSR)\r\n    return\r\n\r\n\r\ndef rmtree(directory, ignore_errors=False):\r\n    shutil.rmtree(\r\n        directory, ignore_errors=ignore_errors, onerror=handle_remove_readonly\r\n    )\r\n\r\n\r\ndef handle_remove_readonly(func, path, exc):\r\n    \"\"\"Error handler for shutil.rmtree.\r\n\r\n    Windows source repo folders are read-only by default, so this error handler\r\n    attempts to set them as writeable and then proceed with deletion.\"\"\"\r\n    # Check for read-only attribute\r\n    default_warning_message = (\r\n        \"Unable to remove file due to permissions restriction: {!r}\"\r\n    )\r\n    # split the initial exception out into its type, exception, and traceback\r\n    exc_type, exc_exception, exc_tb = exc\r\n    if is_readonly_path(path):\r\n        # Apply write permission and call original function\r\n        set_write_bit(path)\r\n        try:\r\n            func(path)\r\n        except (OSError, IOError) as e:\r\n            if e.errno in [errno.EACCES, errno.EPERM]:\r\n                warnings.warn(default_warning_message.format(path), ResourceWarning)\r\n                return\r\n\r\n    if exc_exception.errno in [errno.EACCES, errno.EPERM]:\r\n        warnings.warn(default_warning_message.format(path), ResourceWarning)\r\n        return\r\n\r\n    raise exc\r\n\r\n\r\ndef escape_cmd(cmd):\r\n    if any(special_char in cmd for special_char in [\"<\", \">\", \"&\", \".\", \"^\", \"|\", \"?\"]):\r\n        cmd = '\\\"{0}\\\"'.format(cmd)\r\n    return cmd\r\n\r\n\r\ndef safe_expandvars(value):\r\n    \"\"\"Call os.path.expandvars if value is a string, otherwise do nothing.\r\n    \"\"\"\r\n    if isinstance(value, six.string_types):\r\n        return os.path.expandvars(value)\r\n    return value\r\n\r\n\r\ndef get_vcs_deps(\r\n    project=None,\r\n    dev=False,\r\n    pypi_mirror=None,\r\n    packages=None,\r\n    reqs=None\r\n):\r\n    from .vendor.requirementslib.models.requirements import Requirement\r\n\r\n    section = \"vcs_dev_packages\" if dev else \"vcs_packages\"\r\n    if reqs is None:\r\n        reqs = []\r\n    lockfile = {}\r\n    if not reqs:\r\n        if not project and not packages:\r\n            raise ValueError(\r\n                \"Must supply either a project or a pipfile section to lock vcs dependencies.\"\r\n            )\r\n        if not packages:\r\n            try:\r\n                packages = getattr(project, section)\r\n            except AttributeError:\r\n                return [], []\r\n        reqs = [Requirement.from_pipfile(name, entry) for name, entry in packages.items()]\r\n    result = []\r\n    for requirement in reqs:\r\n        name = requirement.normalized_name\r\n        commit_hash = None\r\n        if requirement.is_vcs:\r\n            try:\r\n                with temp_path(), locked_repository(requirement) as repo:\r\n                    from pipenv.vendor.requirementslib.models.requirements import Requirement\r\n                    # from distutils.sysconfig import get_python_lib\r\n                    # sys.path = [repo.checkout_directory, \"\", \".\", get_python_lib(plat_specific=0)]\r\n                    commit_hash = repo.get_commit_hash()\r\n                    name = requirement.normalized_name\r\n                    version = requirement._specifiers = \"=={0}\".format(requirement.req.setup_info.version)\r\n                    lockfile[name] = requirement.pipfile_entry[1]\r\n                    lockfile[name]['ref'] = commit_hash\r\n                    result.append(requirement)\r\n            except OSError:\r\n                continue\r\n    return result, lockfile\r\n\r\n\r\ndef translate_markers(pipfile_entry):\r\n    \"\"\"Take a pipfile entry and normalize its markers\r\n\r\n    Provide a pipfile entry which may have 'markers' as a key or it may have\r\n    any valid key from `packaging.markers.marker_context.keys()` and standardize\r\n    the format into {'markers': 'key == \"some_value\"'}.\r\n\r\n    :param pipfile_entry: A dictionariy of keys and values representing a pipfile entry\r\n    :type pipfile_entry: dict\r\n    :returns: A normalized dictionary with cleaned marker entries\r\n    \"\"\"\r\n    if not isinstance(pipfile_entry, Mapping):\r\n        raise TypeError(\"Entry is not a pipfile formatted mapping.\")\r\n    from .vendor.packaging.markers import default_environment\r\n    from .vendor.vistir.misc import dedup\r\n\r\n    allowed_marker_keys = [\"markers\"] + list(default_environment().keys())\r\n    provided_keys = list(pipfile_entry.keys()) if hasattr(pipfile_entry, \"keys\") else []\r\n    pipfile_markers = set(provided_keys) & set(allowed_marker_keys)\r\n    new_pipfile = dict(pipfile_entry).copy()\r\n    marker_set = set()\r\n    if \"markers\" in new_pipfile:\r\n        marker_str = new_pipfile.pop(\"markers\")\r\n        if marker_str:\r\n            marker = str(Marker(marker_str))\r\n            if 'extra' not in marker:\r\n                marker_set.add(marker)\r\n    for m in pipfile_markers:\r\n        entry = \"{0}\".format(pipfile_entry[m])\r\n        if m != \"markers\":\r\n            marker_set.add(str(Marker(\"{0} {1}\".format(m, entry))))\r\n            new_pipfile.pop(m)\r\n    if marker_set:\r\n        new_pipfile[\"markers\"] = str(Marker(\" or \".join(\r\n            \"{0}\".format(s) if \" and \" in s else s\r\n            for s in sorted(dedup(marker_set))\r\n        ))).replace('\"', \"'\")\r\n    return new_pipfile\r\n\r\n\r\ndef clean_resolved_dep(dep, is_top_level=False, pipfile_entry=None):\r\n    from .vendor.requirementslib.utils import is_vcs\r\n    name = pep423_name(dep[\"name\"])\r\n    lockfile = {}\r\n    # We use this to determine if there are any markers on top level packages\r\n    # So we can make sure those win out during resolution if the packages reoccur\r\n    if \"version\" in dep and dep[\"version\"] and not dep.get(\"editable\", False):\r\n        version = \"{0}\".format(dep[\"version\"])\r\n        if not version.startswith(\"==\"):\r\n            version = \"=={0}\".format(version)\r\n        lockfile[\"version\"] = version\r\n    if is_vcs(dep):\r\n        ref = dep.get(\"ref\", None)\r\n        if ref is not None:\r\n            lockfile[\"ref\"] = ref\r\n        vcs_type = next(iter(k for k in dep.keys() if k in VCS_LIST), None)\r\n        if vcs_type:\r\n            lockfile[vcs_type] = dep[vcs_type]\r\n        if \"subdirectory\" in dep:\r\n            lockfile[\"subdirectory\"] = dep[\"subdirectory\"]\r\n    for key in [\"hashes\", \"index\", \"extras\", \"editable\"]:\r\n        if key in dep:\r\n            lockfile[key] = dep[key]\r\n    # In case we lock a uri or a file when the user supplied a path\r\n    # remove the uri or file keys from the entry and keep the path\r\n    fs_key = next(iter(k for k in [\"path\", \"file\"] if k in dep), None)\r\n    pipfile_fs_key = None\r\n    if pipfile_entry:\r\n        pipfile_fs_key = next(iter(k for k in [\"path\", \"file\"] if k in pipfile_entry), None)\r\n    if fs_key and pipfile_fs_key and fs_key != pipfile_fs_key:\r\n        lockfile[pipfile_fs_key] = pipfile_entry[pipfile_fs_key]\r\n    elif fs_key is not None:\r\n        lockfile[fs_key] = dep[fs_key]\r\n\r\n    # If a package is **PRESENT** in the pipfile but has no markers, make sure we\r\n    # **NEVER** include markers in the lockfile\r\n    if \"markers\" in dep and dep.get(\"markers\", \"\").strip():\r\n        # First, handle the case where there is no top level dependency in the pipfile\r\n        if not is_top_level:\r\n            translated = translate_markers(dep).get(\"markers\", \"\").strip()\r\n            if translated:\r\n                try:\r\n                    lockfile[\"markers\"] = translated\r\n                except TypeError:\r\n                    pass\r\n        # otherwise make sure we are prioritizing whatever the pipfile says about the markers\r\n        # If the pipfile says nothing, then we should put nothing in the lockfile\r\n        else:\r\n            try:\r\n                pipfile_entry = translate_markers(pipfile_entry)\r\n                lockfile[\"markers\"] = pipfile_entry.get(\"markers\")\r\n            except TypeError:\r\n                pass\r\n    return {name: lockfile}\r\n\r\n\r\ndef get_workon_home():\r\n    from ._compat import Path\r\n\r\n    workon_home = os.environ.get(\"WORKON_HOME\")\r\n    if not workon_home:\r\n        if os.name == \"nt\":\r\n            workon_home = \"~/.virtualenvs\"\r\n        else:\r\n            workon_home = os.path.join(\r\n                os.environ.get(\"XDG_DATA_HOME\", \"~/.local/share\"), \"virtualenvs\"\r\n            )\r\n    # Create directory if it does not already exist\r\n    expanded_path = Path(os.path.expandvars(workon_home)).expanduser()\r\n    mkdir_p(str(expanded_path))\r\n    return expanded_path\r\n\r\n\r\ndef is_virtual_environment(path):\r\n    \"\"\"Check if a given path is a virtual environment's root.\r\n\r\n    This is done by checking if the directory contains a Python executable in\r\n    its bin/Scripts directory. Not technically correct, but good enough for\r\n    general usage.\r\n    \"\"\"\r\n    if not path.is_dir():\r\n        return False\r\n    for bindir_name in ('bin', 'Scripts'):\r\n        for python in path.joinpath(bindir_name).glob('python*'):\r\n            try:\r\n                exeness = python.is_file() and os.access(str(python), os.X_OK)\r\n            except OSError:\r\n                exeness = False\r\n            if exeness:\r\n                return True\r\n    return False\r\n\r\n\r\n@contextmanager\r\ndef locked_repository(requirement):\r\n    from .vendor.vistir.path import create_tracked_tempdir\r\n    if not requirement.is_vcs:\r\n        return\r\n    original_base = os.environ.pop(\"PIP_SHIMS_BASE_MODULE\", None)\r\n    os.environ[\"PIP_SHIMS_BASE_MODULE\"] = fs_str(\"pipenv.patched.notpip\")\r\n    src_dir = create_tracked_tempdir(prefix=\"pipenv-\", suffix=\"-src\")\r\n    try:\r\n        with requirement.req.locked_vcs_repo(src_dir=src_dir) as repo:\r\n            yield repo\r\n    finally:\r\n        if original_base:\r\n            os.environ[\"PIP_SHIMS_BASE_MODULE\"] = original_base\r\n\r\n\r\n@contextmanager\r\ndef chdir(path):\r\n    \"\"\"Context manager to change working directories.\"\"\"\r\n    from ._compat import Path\r\n    if not path:\r\n        return\r\n    prev_cwd = Path.cwd().as_posix()\r\n    if isinstance(path, Path):\r\n        path = path.as_posix()\r\n    os.chdir(str(path))\r\n    try:\r\n        yield\r\n    finally:\r\n        os.chdir(prev_cwd)\r\n\r\n\r\ndef looks_like_dir(path):\r\n    seps = (sep for sep in (os.path.sep, os.path.altsep) if sep is not None)\r\n    return any(sep in path for sep in seps)\r\n\r\n\r\ndef parse_indexes(line):\r\n    from argparse import ArgumentParser\r\n    parser = ArgumentParser(\"indexes\")\r\n    parser.add_argument(\r\n        \"--index\", \"-i\", \"--index-url\",\r\n        metavar=\"index_url\", action=\"store\", nargs=\"?\",\r\n    )\r\n    parser.add_argument(\r\n        \"--extra-index-url\", \"--extra-index\",\r\n        metavar=\"extra_indexes\", action=\"append\",\r\n    )\r\n    parser.add_argument(\"--trusted-host\", metavar=\"trusted_hosts\", action=\"append\")\r\n    args, remainder = parser.parse_known_args(line.split())\r\n    index = [] if not args.index else [args.index]\r\n    extra_indexes = [] if not args.extra_index_url else args.extra_index_url\r\n    indexes = index + extra_indexes\r\n    trusted_hosts = args.trusted_host if args.trusted_host else []\r\n    return indexes, trusted_hosts, remainder\r\n\r\n\r\n@contextmanager\r\ndef sys_version(version_tuple):\r\n    \"\"\"\r\n    Set a temporary sys.version_info tuple\r\n\r\n    :param version_tuple: a fake sys.version_info tuple\r\n    \"\"\"\r\n\r\n    old_version = sys.version_info\r\n    sys.version_info = version_tuple\r\n    yield\r\n    sys.version_info = old_version\r\n\r\n\r\ndef add_to_set(original_set, element):\r\n    \"\"\"Given a set and some arbitrary element, add the element(s) to the set\"\"\"\r\n    if not element:\r\n        return original_set\r\n    if isinstance(element, Set):\r\n        original_set |= element\r\n    elif isinstance(element, (list, tuple)):\r\n        original_set |= set(element)\r\n    else:\r\n        original_set.add(element)\r\n    return original_set\r\n\r\n\r\ndef is_url_equal(url, other_url):\r\n    # type: (str, str) -> bool\r\n    \"\"\"\r\n    Compare two urls by scheme, host, and path, ignoring auth\r\n\r\n    :param str url: The initial URL to compare\r\n    :param str url: Second url to compare to the first\r\n    :return: Whether the URLs are equal without **auth**, **query**, and **fragment**\r\n    :rtype: bool\r\n\r\n    >>> is_url_equal(\"https://user:pass@mydomain.com/some/path?some_query\",\r\n                     \"https://user2:pass2@mydomain.com/some/path\")\r\n    True\r\n\r\n    >>> is_url_equal(\"https://user:pass@mydomain.com/some/path?some_query\",\r\n                 \"https://mydomain.com/some?some_query\")\r\n    False\r\n    \"\"\"\r\n    if not isinstance(url, six.string_types):\r\n        raise TypeError(\"Expected string for url, received {0!r}\".format(url))\r\n    if not isinstance(other_url, six.string_types):\r\n        raise TypeError(\"Expected string for url, received {0!r}\".format(other_url))\r\n    parsed_url = urllib3_util.parse_url(url)\r\n    parsed_other_url = urllib3_util.parse_url(other_url)\r\n    unparsed = parsed_url._replace(auth=None, query=None, fragment=None).url\r\n    unparsed_other = parsed_other_url._replace(auth=None, query=None, fragment=None).url\r\n    return unparsed == unparsed_other\r\n\r\n\r\n@lru_cache()\r\ndef make_posix(path):\r\n    # type: (str) -> str\r\n    \"\"\"\r\n    Convert a path with possible windows-style separators to a posix-style path\r\n    (with **/** separators instead of **\\\\** separators).\r\n\r\n    :param Text path: A path to convert.\r\n    :return: A converted posix-style path\r\n    :rtype: Text\r\n\r\n    >>> make_posix(\"c:/users/user/venvs/some_venv\\\\Lib\\\\site-packages\")\r\n    \"c:/users/user/venvs/some_venv/Lib/site-packages\"\r\n\r\n    >>> make_posix(\"c:\\\\users\\\\user\\\\venvs\\\\some_venv\")\r\n    \"c:/users/user/venvs/some_venv\"\r\n    \"\"\"\r\n    if not isinstance(path, six.string_types):\r\n        raise TypeError(\"Expected a string for path, received {0!r}...\".format(path))\r\n    starts_with_sep = path.startswith(os.path.sep)\r\n    separated = normalize_path(path).split(os.path.sep)\r\n    if isinstance(separated, (list, tuple)):\r\n        path = posixpath.join(*separated)\r\n        if starts_with_sep:\r\n            path = \"/{0}\".format(path)\r\n    return path\r\n\r\n\r\ndef get_pipenv_dist(pkg=\"pipenv\", pipenv_site=None):\r\n    from .resolver import find_site_path\r\n    pipenv_libdir = os.path.dirname(os.path.abspath(__file__))\r\n    if pipenv_site is None:\r\n        pipenv_site = os.path.dirname(pipenv_libdir)\r\n    pipenv_dist, _ = find_site_path(pkg, site_dir=pipenv_site)\r\n    return pipenv_dist\r\n\r\n\r\ndef find_python(finder, line=None):\r\n    \"\"\"\r\n    Given a `pythonfinder.Finder` instance and an optional line, find a corresponding python\r\n\r\n    :param finder: A :class:`pythonfinder.Finder` instance to use for searching\r\n    :type finder: :class:pythonfinder.Finder`\r\n    :param str line: A version, path, name, or nothing, defaults to None\r\n    :return: A path to python\r\n    :rtype: str\r\n    \"\"\"\r\n\r\n    if line and not isinstance(line, six.string_types):\r\n        raise TypeError(\r\n            \"Invalid python search type: expected string, received {0!r}\".format(line)\r\n        )\r\n    if line and os.path.isabs(line):\r\n        if os.name == \"nt\":\r\n            line = make_posix(line)\r\n        return line\r\n    if not finder:\r\n        from pipenv.vendor.pythonfinder import Finder\r\n        finder = Finder(global_search=True)\r\n    if not line:\r\n        result = next(iter(finder.find_all_python_versions()), None)\r\n    elif line and line[0].isdigit() or re.match(r'[\\d\\.]+', line):\r\n        result = finder.find_python_version(line)\r\n    else:\r\n        result = finder.find_python_version(name=line)\r\n    if not result:\r\n        result = finder.which(line)\r\n    if not result and not line.startswith(\"python\"):\r\n        line = \"python{0}\".format(line)\r\n        result = find_python(finder, line)\r\n\r\n    if result:\r\n        if not isinstance(result, six.string_types):\r\n            return result.path.as_posix()\r\n        return result\r\n    return\r\n\r\n\r\ndef is_python_command(line):\r\n    \"\"\"\r\n    Given an input, checks whether the input is a request for python or notself.\r\n\r\n    This can be a version, a python runtime name, or a generic 'python' or 'pythonX.Y'\r\n\r\n    :param str line: A potential request to find python\r\n    :returns: Whether the line is a python lookup\r\n    :rtype: bool\r\n    \"\"\"\r\n\r\n    if not isinstance(line, six.string_types):\r\n        raise TypeError(\"Not a valid command to check: {0!r}\".format(line))\r\n\r\n    from pipenv.vendor.pythonfinder.utils import PYTHON_IMPLEMENTATIONS\r\n    is_version = re.match(r'[\\d\\.]+', line)\r\n    if (line.startswith(\"python\") or is_version\r\n            or any(line.startswith(v) for v in PYTHON_IMPLEMENTATIONS)):\r\n        return True\r\n    # we are less sure about this but we can guess\r\n    if line.startswith(\"py\"):\r\n        return True\r\n    return False\r\n\r\n\r\n# def make_marker_from_specifier(spec):\r\n#     # type: (str) -> Optional[Marker]\r\n#     \"\"\"Given a python version specifier, create a marker\r\n\r\n#     :param spec: A specifier\r\n#     :type spec: str\r\n#     :return: A new marker\r\n#     :rtype: Optional[:class:`packaging.marker.Marker`]\r\n#     \"\"\"\r\n#     from .vendor.packaging.markers import Marker\r\n#     from .vendor.packaging.specifiers import SpecifierSet, Specifier\r\n#     from .vendor.requirementslib.models.markers import cleanup_pyspecs, format_pyversion\r\n#     if not any(spec.startswith(k) for k in Specifier._operators.keys()):\r\n#         if spec.strip().lower() in [\"any\", \"<any>\", \"*\"]:\r\n#             return None\r\n#         spec = \"=={0}\".format(spec)\r\n#     elif spec.startswith(\"==\") and spec.count(\"=\") > 3:\r\n#         spec = \"=={0}\".format(spec.lstrip(\"=\"))\r\n#     if not spec:\r\n#         return None\r\n#     marker_segments = []\r\n#     print(spec)\r\n#     for marker_segment in cleanup_pyspecs(spec):\r\n#         print(marker_segment)\r\n#         marker_segments.append(format_pyversion(marker_segment))\r\n#     marker_str = \" and \".join(marker_segments)\r\n#     return Marker(marker_str)\r\n\r\n\r\n@contextlib.contextmanager\r\ndef interrupt_handled_subprocess(\r\n    cmd, verbose=False, return_object=True, write_to_stdout=False, combine_stderr=True,\r\n    block=True, nospin=True, env=None\r\n):\r\n    \"\"\"Given a :class:`subprocess.Popen` instance, wrap it in exception handlers.\r\n\r\n    Terminates the subprocess when and if a `SystemExit` or `KeyboardInterrupt` are\r\n    processed.\r\n\r\n    Arguments:\r\n        :param str cmd: A command to run\r\n        :param bool verbose: Whether to run with verbose mode enabled, default False\r\n        :param bool return_object: Whether to return a subprocess instance or a 2-tuple, default True\r\n        :param bool write_to_stdout: Whether to write directly to stdout, default False\r\n        :param bool combine_stderr: Whether to combine stdout and stderr, default True\r\n        :param bool block: Whether the subprocess should be a blocking subprocess, default True\r\n        :param bool nospin: Whether to suppress the spinner with the subprocess, default True\r\n        :param Optional[Dict[str, str]] env: A dictionary to merge into the subprocess environment\r\n        :return: A subprocess, wrapped in exception handlers, as a context manager\r\n        :rtype: :class:`subprocess.Popen` obj: An instance of a running subprocess\r\n    \"\"\"\r\n    obj = run(\r\n        cmd, verbose=verbose, return_object=True, write_to_stdout=False,\r\n        combine_stderr=False, block=True, nospin=True, env=env,\r\n    )\r\n    try:\r\n        yield obj\r\n    except (SystemExit, KeyboardInterrupt):\r\n        if os.name == \"nt\":\r\n            os.kill(obj.pid, signal.CTRL_BREAK_EVENT)\r\n        else:\r\n            os.kill(obj.pid, signal.SIGINT)\r\n        obj.wait()\r\n        raise\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- env/Lib/site-packages/pipenv/utils.py	(revision 7de091c5b19e7b06e80c151f7100df6d0f893820)
+++ env/Lib/site-packages/pipenv/utils.py	(date 1591098437585)
@@ -1191,7 +1191,7 @@
     lockfile_name, lockfile_dict = lockfile_entry.copy().popitem()
     lockfile_version = lockfile_dict.get("version", "")
     # Keep pins from the lockfile
-    if prefer_pipfile and lockfile_version != version and version.startswith("=="):
+    if prefer_pipfile and lockfile_version != version and version.startswith("==") and "*" not in version:
         lockfile_dict["version"] = version
     lockfile_entry[lockfile_name] = lockfile_dict
     return lockfile_entry
@@ -1877,7 +1877,6 @@
                     # sys.path = [repo.checkout_directory, "", ".", get_python_lib(plat_specific=0)]
                     commit_hash = repo.get_commit_hash()
                     name = requirement.normalized_name
-                    version = requirement._specifiers = "=={0}".format(requirement.req.setup_info.version)
                     lockfile[name] = requirement.pipfile_entry[1]
                     lockfile[name]['ref'] = commit_hash
                     result.append(requirement)
Index: env/Lib/site-packages/pipenv/vendor/toml/LICENSE
===================================================================
--- env/Lib/site-packages/pipenv/vendor/toml/LICENSE	(date 1591098444001)
+++ env/Lib/site-packages/pipenv/vendor/toml/LICENSE	(date 1591098444001)
@@ -0,0 +1,27 @@
+The MIT License
+
+Copyright 2013-2019 William Pearson
+Copyright 2015-2016 Julien Enselme
+Copyright 2016 Google Inc.
+Copyright 2017 Samuel Vasko
+Copyright 2017 Nate Prewitt
+Copyright 2017 Jack Evans
+Copyright 2019 Filippo Broggini
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
\ No newline at end of file
Index: env/Lib/site-packages/pipenv/vendor/pythonfinder/models/windows.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># -*- coding=utf-8 -*-\r\nfrom __future__ import absolute_import, print_function\r\n\r\nimport operator\r\nfrom collections import defaultdict\r\n\r\nfrom pipenv.vendor import attr\r\n\r\nfrom ..environment import MYPY_RUNNING\r\nfrom ..exceptions import InvalidPythonVersion\r\nfrom ..utils import ensure_path\r\nfrom .mixins import BaseFinder\r\nfrom .path import PathEntry\r\nfrom .python import PythonVersion, VersionMap\r\n\r\nif MYPY_RUNNING:\r\n    from typing import DefaultDict, Tuple, List, Optional, Union, TypeVar, Type, Any\r\n\r\n    FinderType = TypeVar(\"FinderType\")\r\n\r\n\r\n@attr.s\r\nclass WindowsFinder(BaseFinder):\r\n    paths = attr.ib(default=attr.Factory(list), type=list)\r\n    version_list = attr.ib(default=attr.Factory(list), type=list)\r\n    _versions = attr.ib()  # type: DefaultDict[Tuple, PathEntry]\r\n    _pythons = attr.ib()  # type: DefaultDict[str, PathEntry]\r\n\r\n    def find_all_python_versions(\r\n        self,\r\n        major=None,  # type: Optional[Union[str, int]]\r\n        minor=None,  # type: Optional[int]\r\n        patch=None,  # type: Optional[int]\r\n        pre=None,  # type: Optional[bool]\r\n        dev=None,  # type: Optional[bool]\r\n        arch=None,  # type: Optional[str]\r\n        name=None,  # type: Optional[str]\r\n    ):\r\n        # type (...) -> List[PathEntry]\r\n        version_matcher = operator.methodcaller(\r\n            \"matches\", major, minor, patch, pre, dev, arch, python_name=name\r\n        )\r\n        pythons = [py for py in self.version_list if version_matcher(py)]\r\n        version_sort = operator.attrgetter(\"version_sort\")\r\n        return [c.comes_from for c in sorted(pythons, key=version_sort, reverse=True)]\r\n\r\n    def find_python_version(\r\n        self,\r\n        major=None,  # type: Optional[Union[str, int]]\r\n        minor=None,  # type: Optional[int]\r\n        patch=None,  # type: Optional[int]\r\n        pre=None,  # type: Optional[bool]\r\n        dev=None,  # type: Optional[bool]\r\n        arch=None,  # type: Optional[str]\r\n        name=None,  # type: Optional[str]\r\n    ):\r\n        # type: (...) -> Optional[PathEntry]\r\n        return next(\r\n            iter(\r\n                v\r\n                for v in self.find_all_python_versions(\r\n                    major=major,\r\n                    minor=minor,\r\n                    patch=patch,\r\n                    pre=pre,\r\n                    dev=dev,\r\n                    arch=arch,\r\n                    name=name,\r\n                )\r\n            ),\r\n            None,\r\n        )\r\n\r\n    @_versions.default\r\n    def get_versions(self):\r\n        # type: () -> DefaultDict[Tuple, PathEntry]\r\n        versions = defaultdict(PathEntry)  # type: DefaultDict[Tuple, PathEntry]\r\n        from pythonfinder._vendor.pep514tools import environment as pep514env\r\n\r\n        env_versions = pep514env.findall()\r\n        path = None\r\n        for version_object in env_versions:\r\n            install_path = getattr(version_object.info, \"install_path\", None)\r\n            name = getattr(version_object, \"tag\", None)\r\n            company = getattr(version_object, \"company\", None)\r\n            if install_path is None:\r\n                continue\r\n            try:\r\n                path = ensure_path(install_path.__getattr__(\"\"))\r\n            except AttributeError:\r\n                continue\r\n            try:\r\n                py_version = PythonVersion.from_windows_launcher(\r\n                    version_object, name=name, company=company\r\n                )\r\n            except InvalidPythonVersion:\r\n                continue\r\n            if py_version is None:\r\n                continue\r\n            self.version_list.append(py_version)\r\n            python_path = (\r\n                py_version.comes_from.path\r\n                if py_version.comes_from\r\n                else py_version.executable\r\n            )\r\n            python_kwargs = {python_path: py_version} if python_path is not None else {}\r\n            base_dir = PathEntry.create(\r\n                path, is_root=True, only_python=True, pythons=python_kwargs\r\n            )\r\n            versions[py_version.version_tuple[:5]] = base_dir\r\n            self.paths.append(base_dir)\r\n        return versions\r\n\r\n    @property\r\n    def versions(self):\r\n        # type: () -> DefaultDict[Tuple, PathEntry]\r\n        if not self._versions:\r\n            self._versions = self.get_versions()\r\n        return self._versions\r\n\r\n    @_pythons.default\r\n    def get_pythons(self):\r\n        # type: () -> DefaultDict[str, PathEntry]\r\n        pythons = defaultdict()  # type: DefaultDict[str, PathEntry]\r\n        for version in self.version_list:\r\n            _path = ensure_path(version.comes_from.path)\r\n            pythons[_path.as_posix()] = version.comes_from\r\n        return pythons\r\n\r\n    @property\r\n    def pythons(self):\r\n        # type: () -> DefaultDict[str, PathEntry]\r\n        return self._pythons\r\n\r\n    @pythons.setter\r\n    def pythons(self, value):\r\n        # type: (DefaultDict[str, PathEntry]) -> None\r\n        self._pythons = value\r\n\r\n    @classmethod\r\n    def create(cls, *args, **kwargs):\r\n        # type: (Type[FinderType], Any, Any) -> FinderType\r\n        return cls()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- env/Lib/site-packages/pipenv/vendor/pythonfinder/models/windows.py	(revision 7de091c5b19e7b06e80c151f7100df6d0f893820)
+++ env/Lib/site-packages/pipenv/vendor/pythonfinder/models/windows.py	(date 1591098443801)
@@ -42,7 +42,10 @@
         )
         pythons = [py for py in self.version_list if version_matcher(py)]
         version_sort = operator.attrgetter("version_sort")
-        return [c.comes_from for c in sorted(pythons, key=version_sort, reverse=True)]
+        return [
+            c.comes_from for c in sorted(pythons, key=version_sort, reverse=True)
+            if c.comes_from
+        ]
 
     def find_python_version(
         self,
Index: env/Lib/site-packages/pipenv/vendor/pythonfinder/models/python.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># -*- coding=utf-8 -*-\r\nfrom __future__ import absolute_import, print_function\r\n\r\nimport logging\r\nimport operator\r\nimport platform\r\nimport sys\r\nfrom collections import defaultdict\r\n\r\nfrom pipenv.vendor import attr\r\nimport six\r\nfrom packaging.version import Version\r\n\r\nfrom ..compat import Path, lru_cache\r\nfrom ..environment import ASDF_DATA_DIR, MYPY_RUNNING, PYENV_ROOT, SYSTEM_ARCH\r\nfrom ..exceptions import InvalidPythonVersion\r\nfrom ..utils import (\r\n    RE_MATCHER,\r\n    _filter_none,\r\n    ensure_path,\r\n    get_python_version,\r\n    guess_company,\r\n    is_in_path,\r\n    looks_like_python,\r\n    optional_instance_of,\r\n    parse_asdf_version_order,\r\n    parse_pyenv_version_order,\r\n    parse_python_version,\r\n    path_is_pythoncore,\r\n    unnest,\r\n)\r\nfrom .mixins import BaseFinder, BasePath\r\n\r\nif MYPY_RUNNING:\r\n    from typing import (\r\n        DefaultDict,\r\n        Optional,\r\n        Callable,\r\n        Generator,\r\n        Any,\r\n        Union,\r\n        Tuple,\r\n        List,\r\n        Dict,\r\n        Type,\r\n        TypeVar,\r\n        Iterator,\r\n        overload,\r\n    )\r\n    from .path import PathEntry\r\n    from .._vendor.pep514tools.environment import Environment\r\nelse:\r\n\r\n    def overload(f):\r\n        return f\r\n\r\n\r\nlogger = logging.getLogger(__name__)\r\n\r\n\r\n@attr.s(slots=True)\r\nclass PythonFinder(BaseFinder, BasePath):\r\n    root = attr.ib(default=None, validator=optional_instance_of(Path), type=Path)\r\n    # should come before versions, because its value is used in versions's default initializer.\r\n    #: Whether to ignore any paths which raise exceptions and are not actually python\r\n    ignore_unsupported = attr.ib(default=True, type=bool)\r\n    #: Glob path for python versions off of the root directory\r\n    version_glob_path = attr.ib(default=\"versions/*\", type=str)\r\n    #: The function to use to sort version order when returning an ordered verion set\r\n    sort_function = attr.ib(default=None)  # type: Callable\r\n    #: The root locations used for discovery\r\n    roots = attr.ib(default=attr.Factory(defaultdict), type=defaultdict)\r\n    #: List of paths discovered during search\r\n    paths = attr.ib(type=list)\r\n    #: shim directory\r\n    shim_dir = attr.ib(default=\"shims\", type=str)\r\n    #: Versions discovered in the specified paths\r\n    _versions = attr.ib(default=attr.Factory(defaultdict), type=defaultdict)\r\n    _pythons = attr.ib(default=attr.Factory(defaultdict), type=defaultdict)\r\n\r\n    def __del__(self):\r\n        # type: () -> None\r\n        self._versions = defaultdict()\r\n        self._pythons = defaultdict()\r\n        self.roots = defaultdict()\r\n        self.paths = []\r\n\r\n    @property\r\n    def expanded_paths(self):\r\n        # type: () -> Generator\r\n        return (\r\n            path for path in unnest(p for p in self.versions.values()) if path is not None\r\n        )\r\n\r\n    @property\r\n    def is_pyenv(self):\r\n        # type: () -> bool\r\n        return is_in_path(str(self.root), PYENV_ROOT)\r\n\r\n    @property\r\n    def is_asdf(self):\r\n        # type: () -> bool\r\n        return is_in_path(str(self.root), ASDF_DATA_DIR)\r\n\r\n    def get_version_order(self):\r\n        # type: () -> List[Path]\r\n        version_paths = [\r\n            p\r\n            for p in self.root.glob(self.version_glob_path)\r\n            if not (p.parent.name == \"envs\" or p.name == \"envs\")\r\n        ]\r\n        versions = {v.name: v for v in version_paths}\r\n        version_order = []  # type: List[Path]\r\n        if self.is_pyenv:\r\n            version_order = [\r\n                versions[v] for v in parse_pyenv_version_order() if v in versions\r\n            ]\r\n        elif self.is_asdf:\r\n            version_order = [\r\n                versions[v] for v in parse_asdf_version_order() if v in versions\r\n            ]\r\n        for version in version_order:\r\n            if version in version_paths:\r\n                version_paths.remove(version)\r\n        if version_order:\r\n            version_order += version_paths\r\n        else:\r\n            version_order = version_paths\r\n        return version_order\r\n\r\n    def get_bin_dir(self, base):\r\n        # type: (Union[Path, str]) -> Path\r\n        if isinstance(base, six.string_types):\r\n            base = Path(base)\r\n        return base / \"bin\"\r\n\r\n    @classmethod\r\n    def version_from_bin_dir(cls, entry):\r\n        # type: (PathEntry) -> Optional[PathEntry]\r\n        py_version = None\r\n        py_version = next(iter(entry.find_all_python_versions()), None)\r\n        return py_version\r\n\r\n    def _iter_version_bases(self):\r\n        # type: () -> Iterator[Tuple[Path, PathEntry]]\r\n        from .path import PathEntry\r\n\r\n        for p in self.get_version_order():\r\n            bin_dir = self.get_bin_dir(p)\r\n            if bin_dir.exists() and bin_dir.is_dir():\r\n                entry = PathEntry.create(\r\n                    path=bin_dir.absolute(), only_python=False, name=p.name, is_root=True\r\n                )\r\n                self.roots[p] = entry\r\n                yield (p, entry)\r\n\r\n    def _iter_versions(self):\r\n        # type: () -> Iterator[Tuple[Path, PathEntry, Tuple]]\r\n        for base_path, entry in self._iter_version_bases():\r\n            version = None\r\n            version_entry = None\r\n            try:\r\n                version = PythonVersion.parse(entry.name)\r\n            except (ValueError, InvalidPythonVersion):\r\n                version_entry = next(iter(entry.find_all_python_versions()), None)\r\n                if version is None:\r\n                    if not self.ignore_unsupported:\r\n                        raise\r\n                    continue\r\n                if version_entry is not None:\r\n                    version = version_entry.py_version.as_dict()\r\n            except Exception:\r\n                if not self.ignore_unsupported:\r\n                    raise\r\n                logger.warning(\r\n                    \"Unsupported Python version %r, ignoring...\",\r\n                    base_path.name,\r\n                    exc_info=True,\r\n                )\r\n                continue\r\n            if version is not None:\r\n                version_tuple = (\r\n                    version.get(\"major\"),\r\n                    version.get(\"minor\"),\r\n                    version.get(\"patch\"),\r\n                    version.get(\"is_prerelease\"),\r\n                    version.get(\"is_devrelease\"),\r\n                    version.get(\"is_debug\"),\r\n                )\r\n                yield (base_path, entry, version_tuple)\r\n\r\n    @property\r\n    def versions(self):\r\n        # type: () -> DefaultDict[Tuple, PathEntry]\r\n        if not self._versions:\r\n            for base_path, entry, version_tuple in self._iter_versions():\r\n                self._versions[version_tuple] = entry\r\n        return self._versions\r\n\r\n    def _iter_pythons(self):\r\n        # type: () -> Iterator\r\n        for path, entry, version_tuple in self._iter_versions():\r\n            if path.as_posix() in self._pythons:\r\n                yield self._pythons[path.as_posix()]\r\n            elif version_tuple not in self.versions:\r\n                for python in entry.find_all_python_versions():\r\n                    yield python\r\n            else:\r\n                yield self.versions[version_tuple]\r\n\r\n    @paths.default\r\n    def get_paths(self):\r\n        # type: () -> List[PathEntry]\r\n        _paths = [base for _, base in self._iter_version_bases()]\r\n        return _paths\r\n\r\n    @property\r\n    def pythons(self):\r\n        # type: () -> DefaultDict[str, PathEntry]\r\n        if not self._pythons:\r\n            from .path import PathEntry\r\n\r\n            self._pythons = defaultdict(PathEntry)  # type: DefaultDict[str, PathEntry]\r\n            for python in self._iter_pythons():\r\n                python_path = python.path.as_posix()  # type: ignore\r\n                self._pythons[python_path] = python\r\n        return self._pythons\r\n\r\n    @pythons.setter\r\n    def pythons(self, value):\r\n        # type: (DefaultDict[str, PathEntry]) -> None\r\n        self._pythons = value\r\n\r\n    def get_pythons(self):\r\n        # type: () -> DefaultDict[str, PathEntry]\r\n        return self.pythons\r\n\r\n    @overload\r\n    @classmethod\r\n    def create(cls, root, sort_function, version_glob_path=None, ignore_unsupported=True):\r\n        # type: (str, Callable, Optional[str], bool) -> PythonFinder\r\n        root = ensure_path(root)\r\n        if not version_glob_path:\r\n            version_glob_path = \"versions/*\"\r\n        return cls(\r\n            root=root,\r\n            path=root,\r\n            ignore_unsupported=ignore_unsupported,  # type: ignore\r\n            sort_function=sort_function,\r\n            version_glob_path=version_glob_path,\r\n        )\r\n\r\n    def find_all_python_versions(\r\n        self,\r\n        major=None,  # type: Optional[Union[str, int]]\r\n        minor=None,  # type: Optional[int]\r\n        patch=None,  # type: Optional[int]\r\n        pre=None,  # type: Optional[bool]\r\n        dev=None,  # type: Optional[bool]\r\n        arch=None,  # type: Optional[str]\r\n        name=None,  # type: Optional[str]\r\n    ):\r\n        # type: (...) -> List[PathEntry]\r\n        \"\"\"Search for a specific python version on the path. Return all copies\r\n\r\n        :param major: Major python version to search for.\r\n        :type major: int\r\n        :param int minor: Minor python version to search for, defaults to None\r\n        :param int patch: Patch python version to search for, defaults to None\r\n        :param bool pre: Search for prereleases (default None) - prioritize releases if None\r\n        :param bool dev: Search for devreleases (default None) - prioritize releases if None\r\n        :param str arch: Architecture to include, e.g. '64bit', defaults to None\r\n        :param str name: The name of a python version, e.g. ``anaconda3-5.3.0``\r\n        :return: A list of :class:`~pythonfinder.models.PathEntry` instances matching the version requested.\r\n        :rtype: List[:class:`~pythonfinder.models.PathEntry`]\r\n        \"\"\"\r\n\r\n        call_method = \"find_all_python_versions\" if self.is_dir else \"find_python_version\"\r\n        sub_finder = operator.methodcaller(\r\n            call_method, major, minor, patch, pre, dev, arch, name\r\n        )\r\n        if not any([major, minor, patch, name]):\r\n            pythons = [\r\n                next(iter(py for py in base.find_all_python_versions()), None)\r\n                for _, base in self._iter_version_bases()\r\n            ]\r\n        else:\r\n            pythons = [sub_finder(path) for path in self.paths]\r\n        pythons = [p for p in pythons if p and p.is_python and p.as_python is not None]\r\n        version_sort = operator.attrgetter(\"as_python.version_sort\")\r\n        paths = [\r\n            p\r\n            for p in sorted(list(pythons), key=version_sort, reverse=True)\r\n            if p is not None\r\n        ]\r\n        return paths\r\n\r\n    def find_python_version(\r\n        self,\r\n        major=None,  # type: Optional[Union[str, int]]\r\n        minor=None,  # type: Optional[int]\r\n        patch=None,  # type: Optional[int]\r\n        pre=None,  # type: Optional[bool]\r\n        dev=None,  # type: Optional[bool]\r\n        arch=None,  # type: Optional[str]\r\n        name=None,  # type: Optional[str]\r\n    ):\r\n        # type: (...) -> Optional[PathEntry]\r\n        \"\"\"Search or self for the specified Python version and return the first match.\r\n\r\n        :param major: Major version number.\r\n        :type major: int\r\n        :param int minor: Minor python version to search for, defaults to None\r\n        :param int patch: Patch python version to search for, defaults to None\r\n        :param bool pre: Search for prereleases (default None) - prioritize releases if None\r\n        :param bool dev: Search for devreleases (default None) - prioritize releases if None\r\n        :param str arch: Architecture to include, e.g. '64bit', defaults to None\r\n        :param str name: The name of a python version, e.g. ``anaconda3-5.3.0``\r\n        :returns: A :class:`~pythonfinder.models.PathEntry` instance matching the version requested.\r\n        \"\"\"\r\n\r\n        sub_finder = operator.methodcaller(\r\n            \"find_python_version\", major, minor, patch, pre, dev, arch, name\r\n        )\r\n        version_sort = operator.attrgetter(\"as_python.version_sort\")\r\n        unnested = [sub_finder(self.roots[path]) for path in self.roots]\r\n        unnested = [\r\n            p\r\n            for p in unnested\r\n            if p is not None and p.is_python and p.as_python is not None\r\n        ]\r\n        paths = sorted(list(unnested), key=version_sort, reverse=True)\r\n        return next(iter(p for p in paths if p is not None), None)\r\n\r\n    def which(self, name):\r\n        # type: (str) -> Optional[PathEntry]\r\n        \"\"\"Search in this path for an executable.\r\n\r\n        :param executable: The name of an executable to search for.\r\n        :type executable: str\r\n        :returns: :class:`~pythonfinder.models.PathEntry` instance.\r\n        \"\"\"\r\n\r\n        matches = (p.which(name) for p in self.paths)\r\n        non_empty_match = next(iter(m for m in matches if m is not None), None)\r\n        return non_empty_match\r\n\r\n\r\n@attr.s(slots=True)\r\nclass PythonVersion(object):\r\n    major = attr.ib(default=0, type=int)\r\n    minor = attr.ib(default=None)  # type: Optional[int]\r\n    patch = attr.ib(default=None)  # type: Optional[int]\r\n    is_prerelease = attr.ib(default=False, type=bool)\r\n    is_postrelease = attr.ib(default=False, type=bool)\r\n    is_devrelease = attr.ib(default=False, type=bool)\r\n    is_debug = attr.ib(default=False, type=bool)\r\n    version = attr.ib(default=None)  # type: Version\r\n    architecture = attr.ib(default=None)  # type: Optional[str]\r\n    comes_from = attr.ib(default=None)  # type: Optional[PathEntry]\r\n    executable = attr.ib(default=None)  # type: Optional[str]\r\n    company = attr.ib(default=None)  # type: Optional[str]\r\n    name = attr.ib(default=None, type=str)\r\n\r\n    def __getattribute__(self, key):\r\n        result = super(PythonVersion, self).__getattribute__(key)\r\n        if key in [\"minor\", \"patch\"] and result is None:\r\n            executable = None  # type: Optional[str]\r\n            if self.executable:\r\n                executable = self.executable\r\n            elif self.comes_from:\r\n                executable = self.comes_from.path.as_posix()\r\n            if executable is not None:\r\n                if not isinstance(executable, six.string_types):\r\n                    executable = executable.as_posix()\r\n                instance_dict = self.parse_executable(executable)\r\n                for k in instance_dict.keys():\r\n                    try:\r\n                        super(PythonVersion, self).__getattribute__(k)\r\n                    except AttributeError:\r\n                        continue\r\n                    else:\r\n                        setattr(self, k, instance_dict[k])\r\n                result = instance_dict.get(key)\r\n        return result\r\n\r\n    @property\r\n    def version_sort(self):\r\n        # type: () -> Tuple[int, int, Optional[int], int, int]\r\n        \"\"\"\r\n        A tuple for sorting against other instances of the same class.\r\n\r\n        Returns a tuple of the python version but includes points for core python,\r\n        non-dev,  and non-prerelease versions.  So released versions will have 2 points\r\n        for this value.  E.g. ``(1, 3, 6, 6, 2)`` is a release, ``(1, 3, 6, 6, 1)`` is a\r\n        prerelease, ``(1, 3, 6, 6, 0)`` is a dev release, and ``(1, 3, 6, 6, 3)`` is a\r\n        postrelease.  ``(0, 3, 7, 3, 2)`` represents a non-core python release, e.g. by\r\n        a repackager of python like Continuum.\r\n        \"\"\"\r\n        company_sort = 1 if (self.company and self.company == \"PythonCore\") else 0\r\n        release_sort = 2\r\n        if self.is_postrelease:\r\n            release_sort = 3\r\n        elif self.is_prerelease:\r\n            release_sort = 1\r\n        elif self.is_devrelease:\r\n            release_sort = 0\r\n        elif self.is_debug:\r\n            release_sort = 1\r\n        return (\r\n            company_sort,\r\n            self.major,\r\n            self.minor,\r\n            self.patch if self.patch else 0,\r\n            release_sort,\r\n        )\r\n\r\n    @property\r\n    def version_tuple(self):\r\n        # type: () -> Tuple[int, Optional[int], Optional[int], bool, bool, bool]\r\n        \"\"\"\r\n        Provides a version tuple for using as a dictionary key.\r\n\r\n        :return: A tuple describing the python version meetadata contained.\r\n        :rtype: tuple\r\n        \"\"\"\r\n\r\n        return (\r\n            self.major,\r\n            self.minor,\r\n            self.patch,\r\n            self.is_prerelease,\r\n            self.is_devrelease,\r\n            self.is_debug,\r\n        )\r\n\r\n    def matches(\r\n        self,\r\n        major=None,  # type: Optional[int]\r\n        minor=None,  # type: Optional[int]\r\n        patch=None,  # type: Optional[int]\r\n        pre=False,  # type: bool\r\n        dev=False,  # type: bool\r\n        arch=None,  # type: Optional[str]\r\n        debug=False,  # type: bool\r\n        python_name=None,  # type: Optional[str]\r\n    ):\r\n        # type: (...) -> bool\r\n        result = False\r\n        if arch:\r\n            own_arch = self.get_architecture()\r\n            if arch.isdigit():\r\n                arch = \"{0}bit\".format(arch)\r\n        if (\r\n            (major is None or self.major and self.major == major)\r\n            and (minor is None or self.minor and self.minor == minor)\r\n            and (patch is None or self.patch and self.patch == patch)\r\n            and (pre is None or self.is_prerelease == pre)\r\n            and (dev is None or self.is_devrelease == dev)\r\n            and (arch is None or own_arch == arch)\r\n            and (debug is None or self.is_debug == debug)\r\n            and (\r\n                python_name is None\r\n                or (python_name and self.name)\r\n                and (self.name == python_name or self.name.startswith(python_name))\r\n            )\r\n        ):\r\n            result = True\r\n        return result\r\n\r\n    def as_major(self):\r\n        # type: () -> PythonVersion\r\n        self_dict = attr.asdict(self, recurse=False, filter=_filter_none).copy()\r\n        self_dict.update({\"minor\": None, \"patch\": None})\r\n        return self.create(**self_dict)\r\n\r\n    def as_minor(self):\r\n        # type: () -> PythonVersion\r\n        self_dict = attr.asdict(self, recurse=False, filter=_filter_none).copy()\r\n        self_dict.update({\"patch\": None})\r\n        return self.create(**self_dict)\r\n\r\n    def as_dict(self):\r\n        # type: () -> Dict[str, Union[int, bool, Version, None]]\r\n        return {\r\n            \"major\": self.major,\r\n            \"minor\": self.minor,\r\n            \"patch\": self.patch,\r\n            \"is_prerelease\": self.is_prerelease,\r\n            \"is_postrelease\": self.is_postrelease,\r\n            \"is_devrelease\": self.is_devrelease,\r\n            \"is_debug\": self.is_debug,\r\n            \"version\": self.version,\r\n            \"company\": self.company,\r\n        }\r\n\r\n    def update_metadata(self, metadata):\r\n        # type: (Dict[str, Union[str, int, Version]]) -> None\r\n        \"\"\"\r\n        Update the metadata on the current :class:`pythonfinder.models.python.PythonVersion`\r\n\r\n        Given a parsed version dictionary from :func:`pythonfinder.utils.parse_python_version`,\r\n        update the instance variables of the current version instance to reflect the newly\r\n        supplied values.\r\n        \"\"\"\r\n\r\n        for key in metadata:\r\n            try:\r\n                _ = getattr(self, key)\r\n            except AttributeError:\r\n                continue\r\n            else:\r\n                setattr(self, key, metadata[key])\r\n\r\n    @classmethod\r\n    @lru_cache(maxsize=1024)\r\n    def parse(cls, version):\r\n        # type: (str) -> Dict[str, Union[str, int, Version]]\r\n        \"\"\"\r\n        Parse a valid version string into a dictionary\r\n\r\n        Raises:\r\n            ValueError -- Unable to parse version string\r\n            ValueError -- Not a valid python version\r\n            TypeError -- NoneType or unparseable type passed in\r\n\r\n        :param str version: A valid version string\r\n        :return: A dictionary with metadata about the specified python version.\r\n        :rtype: dict\r\n        \"\"\"\r\n\r\n        if version is None:\r\n            raise TypeError(\"Must pass a value to parse!\")\r\n        version_dict = parse_python_version(str(version))\r\n        if not version_dict:\r\n            raise ValueError(\"Not a valid python version: %r\" % version)\r\n        return version_dict\r\n\r\n    def get_architecture(self):\r\n        # type: () -> str\r\n        if self.architecture:\r\n            return self.architecture\r\n        arch = None\r\n        if self.comes_from is not None:\r\n            arch, _ = platform.architecture(self.comes_from.path.as_posix())\r\n        elif self.executable is not None:\r\n            arch, _ = platform.architecture(self.executable)\r\n        if arch is None:\r\n            arch, _ = platform.architecture(sys.executable)\r\n        self.architecture = arch\r\n        return self.architecture\r\n\r\n    @classmethod\r\n    def from_path(cls, path, name=None, ignore_unsupported=True, company=None):\r\n        # type: (Union[str, PathEntry], Optional[str], bool, Optional[str]) -> PythonVersion\r\n        \"\"\"\r\n        Parses a python version from a system path.\r\n\r\n        Raises:\r\n            ValueError -- Not a valid python path\r\n\r\n        :param path: A string or :class:`~pythonfinder.models.path.PathEntry`\r\n        :type path: str or :class:`~pythonfinder.models.path.PathEntry` instance\r\n        :param str name: Name of the python distribution in question\r\n        :param bool ignore_unsupported: Whether to ignore or error on unsupported paths.\r\n        :param Optional[str] company: The company or vendor packaging the distribution.\r\n        :return: An instance of a PythonVersion.\r\n        :rtype: :class:`~pythonfinder.models.python.PythonVersion`\r\n        \"\"\"\r\n\r\n        from .path import PathEntry\r\n\r\n        if not isinstance(path, PathEntry):\r\n            path = PathEntry.create(path, is_root=False, only_python=True, name=name)\r\n        from ..environment import IGNORE_UNSUPPORTED\r\n\r\n        ignore_unsupported = ignore_unsupported or IGNORE_UNSUPPORTED\r\n        path_name = getattr(path, \"name\", path.path.name)  # str\r\n        if not path.is_python:\r\n            if not (ignore_unsupported or IGNORE_UNSUPPORTED):\r\n                raise ValueError(\"Not a valid python path: %s\" % path.path)\r\n        try:\r\n            instance_dict = cls.parse(path_name)\r\n        except Exception:\r\n            instance_dict = cls.parse_executable(path.path.absolute().as_posix())\r\n        else:\r\n            if instance_dict.get(\"minor\") is None and looks_like_python(path.path.name):\r\n                instance_dict = cls.parse_executable(path.path.absolute().as_posix())\r\n\r\n        if (\r\n            not isinstance(instance_dict.get(\"version\"), Version)\r\n            and not ignore_unsupported\r\n        ):\r\n            raise ValueError(\"Not a valid python path: %s\" % path)\r\n        if instance_dict.get(\"patch\") is None:\r\n            instance_dict = cls.parse_executable(path.path.absolute().as_posix())\r\n        if name is None:\r\n            name = path_name\r\n        if company is None:\r\n            company = guess_company(path.path.as_posix())\r\n        instance_dict.update(\r\n            {\"comes_from\": path, \"name\": name, \"executable\": path.path.as_posix()}\r\n        )\r\n        return cls(**instance_dict)  # type: ignore\r\n\r\n    @classmethod\r\n    @lru_cache(maxsize=1024)\r\n    def parse_executable(cls, path):\r\n        # type: (str) -> Dict[str, Optional[Union[str, int, Version]]]\r\n        result_dict = {}  # type: Dict[str, Optional[Union[str, int, Version]]]\r\n        result_version = None  # type: Optional[str]\r\n        if path is None:\r\n            raise TypeError(\"Must pass a valid path to parse.\")\r\n        if not isinstance(path, six.string_types):\r\n            path = path.as_posix()\r\n        # if not looks_like_python(path):\r\n        #     raise ValueError(\"Path %r does not look like a valid python path\" % path)\r\n        try:\r\n            result_version = get_python_version(path)\r\n        except Exception:\r\n            raise ValueError(\"Not a valid python path: %r\" % path)\r\n        if result_version is None:\r\n            raise ValueError(\"Not a valid python path: %s\" % path)\r\n        result_dict = cls.parse(result_version.strip())\r\n        return result_dict\r\n\r\n    @classmethod\r\n    def from_windows_launcher(cls, launcher_entry, name=None, company=None):\r\n        # type: (Environment, Optional[str], Optional[str]) -> PythonVersion\r\n        \"\"\"Create a new PythonVersion instance from a Windows Launcher Entry\r\n\r\n        :param launcher_entry: A python launcher environment object.\r\n        :param Optional[str] name: The name of the distribution.\r\n        :param Optional[str] company: The name of the distributing company.\r\n        :return: An instance of a PythonVersion.\r\n        :rtype: :class:`~pythonfinder.models.python.PythonVersion`\r\n        \"\"\"\r\n\r\n        from .path import PathEntry\r\n\r\n        creation_dict = cls.parse(launcher_entry.info.version)\r\n        base_path = ensure_path(launcher_entry.info.install_path.__getattr__(\"\"))\r\n        default_path = base_path / \"python.exe\"\r\n        if not default_path.exists():\r\n            default_path = base_path / \"Scripts\" / \"python.exe\"\r\n        exe_path = ensure_path(\r\n            getattr(launcher_entry.info.install_path, \"executable_path\", default_path)\r\n        )\r\n        company = getattr(launcher_entry, \"company\", guess_company(exe_path.as_posix()))\r\n        creation_dict.update(\r\n            {\r\n                \"architecture\": getattr(\r\n                    launcher_entry.info, \"sys_architecture\", SYSTEM_ARCH\r\n                ),\r\n                \"executable\": exe_path,\r\n                \"name\": name,\r\n                \"company\": company,\r\n            }\r\n        )\r\n        py_version = cls.create(**creation_dict)\r\n        comes_from = PathEntry.create(exe_path, only_python=True, name=name)\r\n        py_version.comes_from = comes_from\r\n        py_version.name = comes_from.name\r\n        return py_version\r\n\r\n    @classmethod\r\n    def create(cls, **kwargs):\r\n        # type: (...) -> PythonVersion\r\n        if \"architecture\" in kwargs:\r\n            if kwargs[\"architecture\"].isdigit():\r\n                kwargs[\"architecture\"] = \"{0}bit\".format(kwargs[\"architecture\"])\r\n        return cls(**kwargs)\r\n\r\n\r\n@attr.s\r\nclass VersionMap(object):\r\n    versions = attr.ib(\r\n        factory=defaultdict\r\n    )  # type: DefaultDict[Tuple[int, Optional[int], Optional[int], bool, bool, bool], List[PathEntry]]\r\n\r\n    def add_entry(self, entry):\r\n        # type: (...) -> None\r\n        version = entry.as_python  # type: PythonVersion\r\n        if version:\r\n            _ = self.versions[version.version_tuple]\r\n            paths = {p.path for p in self.versions.get(version.version_tuple, [])}\r\n            if entry.path not in paths:\r\n                self.versions[version.version_tuple].append(entry)\r\n\r\n    def merge(self, target):\r\n        # type: (VersionMap) -> None\r\n        for version, entries in target.versions.items():\r\n            if version not in self.versions:\r\n                self.versions[version] = entries\r\n            else:\r\n                current_entries = {\r\n                    p.path\r\n                    for p in self.versions[version]  # type: ignore\r\n                    if version in self.versions\r\n                }\r\n                new_entries = {p.path for p in entries}\r\n                new_entries -= current_entries\r\n                self.versions[version].extend(\r\n                    [e for e in entries if e.path in new_entries]\r\n                )\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- env/Lib/site-packages/pipenv/vendor/pythonfinder/models/python.py	(revision 7de091c5b19e7b06e80c151f7100df6d0f893820)
+++ env/Lib/site-packages/pipenv/vendor/pythonfinder/models/python.py	(date 1591098443801)
@@ -18,6 +18,7 @@
     RE_MATCHER,
     _filter_none,
     ensure_path,
+    expand_paths,
     get_python_version,
     guess_company,
     is_in_path,
@@ -286,12 +287,10 @@
             ]
         else:
             pythons = [sub_finder(path) for path in self.paths]
-        pythons = [p for p in pythons if p and p.is_python and p.as_python is not None]
+        pythons = expand_paths(pythons, True)
         version_sort = operator.attrgetter("as_python.version_sort")
         paths = [
-            p
-            for p in sorted(list(pythons), key=version_sort, reverse=True)
-            if p is not None
+            p for p in sorted(pythons, key=version_sort, reverse=True) if p is not None
         ]
         return paths
 
Index: env/Lib/site-packages/pipenv-2020.6.2.dist-info/zip-safe
===================================================================
--- env/Lib/site-packages/pipenv-2020.6.2.dist-info/zip-safe	(date 1591098444289)
+++ env/Lib/site-packages/pipenv-2020.6.2.dist-info/zip-safe	(date 1591098444289)
@@ -0,0 +1,1 @@
+
Index: env/Lib/site-packages/pipenv/vendor/pythonfinder/models/path.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># -*- coding=utf-8 -*-\r\nfrom __future__ import absolute_import, print_function\r\n\r\nimport operator\r\nimport os\r\nimport sys\r\nfrom collections import defaultdict\r\nfrom itertools import chain\r\n\r\nfrom pipenv.vendor import attr\r\nimport six\r\nfrom cached_property import cached_property\r\nfrom ..compat import Path, fs_str\r\n\r\nfrom ..environment import (\r\n    ASDF_DATA_DIR,\r\n    ASDF_INSTALLED,\r\n    MYPY_RUNNING,\r\n    PYENV_INSTALLED,\r\n    PYENV_ROOT,\r\n    SHIM_PATHS,\r\n    get_shim_paths,\r\n)\r\nfrom ..exceptions import InvalidPythonVersion\r\nfrom ..utils import (\r\n    Iterable,\r\n    Sequence,\r\n    dedup,\r\n    ensure_path,\r\n    expand_paths,\r\n    filter_pythons,\r\n    is_in_path,\r\n    normalize_path,\r\n    optional_instance_of,\r\n    parse_asdf_version_order,\r\n    parse_pyenv_version_order,\r\n    path_is_known_executable,\r\n    split_version_and_name,\r\n    unnest,\r\n)\r\nfrom .mixins import BaseFinder, BasePath\r\n\r\nif MYPY_RUNNING:\r\n    from typing import (\r\n        Optional,\r\n        Dict,\r\n        DefaultDict,\r\n        Iterator,\r\n        List,\r\n        Union,\r\n        Tuple,\r\n        Generator,\r\n        Callable,\r\n        Type,\r\n        Any,\r\n        TypeVar,\r\n    )\r\n    from .python import PythonFinder, PythonVersion\r\n    from .windows import WindowsFinder\r\n\r\n    FinderType = TypeVar(\"FinderType\", BaseFinder, PythonFinder, WindowsFinder)\r\n    ChildType = Union[PythonFinder, \"PathEntry\"]\r\n    PathType = Union[PythonFinder, \"PathEntry\"]\r\n\r\n\r\n@attr.s\r\nclass SystemPath(object):\r\n    global_search = attr.ib(default=True)\r\n    paths = attr.ib(\r\n        default=attr.Factory(defaultdict)\r\n    )  # type: DefaultDict[str, Union[PythonFinder, PathEntry]]\r\n    _executables = attr.ib(default=attr.Factory(list))  # type: List[PathEntry]\r\n    _python_executables = attr.ib(\r\n        default=attr.Factory(dict)\r\n    )  # type: Dict[str, PathEntry]\r\n    path_order = attr.ib(default=attr.Factory(list))  # type: List[str]\r\n    python_version_dict = attr.ib()  # type: DefaultDict[Tuple, List[PythonVersion]]\r\n    only_python = attr.ib(default=False, type=bool)\r\n    pyenv_finder = attr.ib(default=None)  # type: Optional[PythonFinder]\r\n    asdf_finder = attr.ib(default=None)  # type: Optional[PythonFinder]\r\n    windows_finder = attr.ib(default=None)  # type: Optional[WindowsFinder]\r\n    system = attr.ib(default=False, type=bool)\r\n    _version_dict = attr.ib(\r\n        default=attr.Factory(defaultdict)\r\n    )  # type: DefaultDict[Tuple, List[PathEntry]]\r\n    ignore_unsupported = attr.ib(default=False, type=bool)\r\n\r\n    __finders = attr.ib(\r\n        default=attr.Factory(dict)\r\n    )  # type: Dict[str, Union[WindowsFinder, PythonFinder]]\r\n\r\n    def _register_finder(self, finder_name, finder):\r\n        # type: (str, Union[WindowsFinder, PythonFinder]) -> \"SystemPath\"\r\n        if finder_name not in self.__finders:\r\n            self.__finders[finder_name] = finder\r\n        return self\r\n\r\n    def clear_caches(self):\r\n        for key in [\"executables\", \"python_executables\", \"version_dict\", \"path_entries\"]:\r\n            if key in self.__dict__:\r\n                del self.__dict__[key]\r\n        for finder in list(self.__finders.keys()):\r\n            del self.__finders[finder]\r\n        self.__finders = {}\r\n        return attr.evolve(\r\n            self,\r\n            executables=[],\r\n            python_executables={},\r\n            python_version_dict=defaultdict(list),\r\n            version_dict=defaultdict(list),\r\n            pyenv_finder=None,\r\n            windows_finder=None,\r\n            asdf_finder=None,\r\n            path_order=[],\r\n            paths=defaultdict(PathEntry),\r\n        )\r\n\r\n    def __del__(self):\r\n        for key in [\"executables\", \"python_executables\", \"version_dict\", \"path_entries\"]:\r\n            try:\r\n                del self.__dict__[key]\r\n            except KeyError:\r\n                pass\r\n        for finder in list(self.__finders.keys()):\r\n            del self.__finders[finder]\r\n        self.__finders = {}\r\n        self._python_executables = {}\r\n        self._executables = []\r\n        self.python_version_dict = defaultdict(list)\r\n        self._version_dict = defaultdict(list)\r\n        self.path_order = []\r\n        self.pyenv_finder = None\r\n        self.asdf_finder = None\r\n        self.paths = defaultdict(PathEntry)\r\n        self.__finders = {}\r\n\r\n    @property\r\n    def finders(self):\r\n        # type: () -> List[str]\r\n        return [k for k in self.__finders.keys()]\r\n\r\n    @staticmethod\r\n    def check_for_pyenv():\r\n        return PYENV_INSTALLED or os.path.exists(normalize_path(PYENV_ROOT))\r\n\r\n    @staticmethod\r\n    def check_for_asdf():\r\n        return ASDF_INSTALLED or os.path.exists(normalize_path(ASDF_DATA_DIR))\r\n\r\n    @python_version_dict.default\r\n    def create_python_version_dict(self):\r\n        # type: () -> DefaultDict[Tuple, List[PythonVersion]]\r\n        return defaultdict(list)\r\n\r\n    @cached_property\r\n    def executables(self):\r\n        # type: () -> List[PathEntry]\r\n        self.executables = [\r\n            p\r\n            for p in chain(*(child.children.values() for child in self.paths.values()))\r\n            if p.is_executable\r\n        ]\r\n        return self.executables\r\n\r\n    @cached_property\r\n    def python_executables(self):\r\n        # type: () -> Dict[str, PathEntry]\r\n        python_executables = {}\r\n        for child in self.paths.values():\r\n            if child.pythons:\r\n                python_executables.update(dict(child.pythons))\r\n        for finder_name, finder in self.__finders.items():\r\n            if finder.pythons:\r\n                python_executables.update(dict(finder.pythons))\r\n        self._python_executables = python_executables\r\n        return self._python_executables\r\n\r\n    @cached_property\r\n    def version_dict(self):\r\n        # type: () -> DefaultDict[Tuple, List[PathEntry]]\r\n        self._version_dict = defaultdict(\r\n            list\r\n        )  # type: DefaultDict[Tuple, List[PathEntry]]\r\n        for finder_name, finder in self.__finders.items():\r\n            for version, entry in finder.versions.items():\r\n                if finder_name == \"windows\":\r\n                    if entry not in self._version_dict[version]:\r\n                        self._version_dict[version].append(entry)\r\n                    continue\r\n                if entry not in self._version_dict[version] and entry.is_python:\r\n                    self._version_dict[version].append(entry)\r\n        for p, entry in self.python_executables.items():\r\n            version = entry.as_python  # type: PythonVersion\r\n            if not version:\r\n                continue\r\n            if not isinstance(version, tuple):\r\n                version = version.version_tuple\r\n            if version and entry not in self._version_dict[version]:\r\n                self._version_dict[version].append(entry)\r\n        return self._version_dict\r\n\r\n    def _run_setup(self):\r\n        # type: () -> \"SystemPath\"\r\n        if not self.__class__ == SystemPath:\r\n            return self\r\n        new_instance = self\r\n        path_order = new_instance.path_order[:]\r\n        path_entries = self.paths.copy()\r\n        if self.global_search and \"PATH\" in os.environ:\r\n            path_order = path_order + os.environ[\"PATH\"].split(os.pathsep)\r\n        path_order = list(dedup(path_order))\r\n        path_instances = [\r\n            ensure_path(p.strip('\"'))\r\n            for p in path_order\r\n            if not any(\r\n                is_in_path(normalize_path(str(p)), normalize_path(shim))\r\n                for shim in SHIM_PATHS\r\n            )\r\n        ]\r\n        path_entries.update(\r\n            {\r\n                p.as_posix(): PathEntry.create(\r\n                    path=p.absolute(), is_root=True, only_python=self.only_python\r\n                )\r\n                for p in path_instances\r\n            }\r\n        )\r\n        new_instance = attr.evolve(\r\n            new_instance,\r\n            path_order=[p.as_posix() for p in path_instances],\r\n            paths=path_entries,\r\n        )\r\n        if os.name == \"nt\" and \"windows\" not in self.finders:\r\n            new_instance = new_instance._setup_windows()\r\n        #: slice in pyenv\r\n        if self.check_for_pyenv() and \"pyenv\" not in self.finders:\r\n            new_instance = new_instance._setup_pyenv()\r\n        #: slice in asdf\r\n        if self.check_for_asdf() and \"asdf\" not in self.finders:\r\n            new_instance = new_instance._setup_asdf()\r\n        venv = os.environ.get(\"VIRTUAL_ENV\")\r\n        if os.name == \"nt\":\r\n            bin_dir = \"Scripts\"\r\n        else:\r\n            bin_dir = \"bin\"\r\n        if venv and (new_instance.system or new_instance.global_search):\r\n            p = ensure_path(venv)\r\n            path_order = [(p / bin_dir).as_posix()] + new_instance.path_order\r\n            new_instance = attr.evolve(new_instance, path_order=path_order)\r\n            paths = new_instance.paths.copy()\r\n            paths[p] = new_instance.get_path(p.joinpath(bin_dir))\r\n            new_instance = attr.evolve(new_instance, paths=paths)\r\n        if new_instance.system:\r\n            syspath = Path(sys.executable)\r\n            syspath_bin = syspath.parent\r\n            if syspath_bin.name != bin_dir and syspath_bin.joinpath(bin_dir).exists():\r\n                syspath_bin = syspath_bin / bin_dir\r\n            path_order = [syspath_bin.as_posix()] + new_instance.path_order\r\n            paths = new_instance.paths.copy()\r\n            paths[syspath_bin] = PathEntry.create(\r\n                path=syspath_bin, is_root=True, only_python=False\r\n            )\r\n            new_instance = attr.evolve(new_instance, path_order=path_order, paths=paths)\r\n        return new_instance\r\n\r\n    def _get_last_instance(self, path):\r\n        # type: (str) -> int\r\n        reversed_paths = reversed(self.path_order)\r\n        paths = [normalize_path(p) for p in reversed_paths]\r\n        normalized_target = normalize_path(path)\r\n        last_instance = next(iter(p for p in paths if normalized_target in p), None)\r\n        if last_instance is None:\r\n            raise ValueError(\"No instance found on path for target: {0!s}\".format(path))\r\n        path_index = self.path_order.index(last_instance)\r\n        return path_index\r\n\r\n    def _slice_in_paths(self, start_idx, paths):\r\n        # type: (int, List[Path]) -> \"SystemPath\"\r\n        before_path = []  # type: List[str]\r\n        after_path = []  # type: List[str]\r\n        if start_idx == 0:\r\n            after_path = self.path_order[:]\r\n        elif start_idx == -1:\r\n            before_path = self.path_order[:]\r\n        else:\r\n            before_path = self.path_order[: start_idx + 1]\r\n            after_path = self.path_order[start_idx + 2 :]\r\n        path_order = before_path + [p.as_posix() for p in paths] + after_path\r\n        if path_order == self.path_order:\r\n            return self\r\n        return attr.evolve(self, path_order=path_order)\r\n\r\n    def _remove_path(self, path):\r\n        # type: (str) -> \"SystemPath\"\r\n        path_copy = [p for p in reversed(self.path_order[:])]\r\n        new_order = []\r\n        target = normalize_path(path)\r\n        path_map = {normalize_path(pth): pth for pth in self.paths.keys()}\r\n        new_paths = self.paths.copy()\r\n        if target in path_map:\r\n            del new_paths[path_map[target]]\r\n        for current_path in path_copy:\r\n            normalized = normalize_path(current_path)\r\n            if normalized != target:\r\n                new_order.append(normalized)\r\n        new_order = [p for p in reversed(new_order)]\r\n        return attr.evolve(self, path_order=new_order, paths=new_paths)\r\n\r\n    def _setup_asdf(self):\r\n        # type: () -> \"SystemPath\"\r\n        if \"asdf\" in self.finders and self.asdf_finder is not None:\r\n            return self\r\n        from .python import PythonFinder\r\n\r\n        os_path = os.environ[\"PATH\"].split(os.pathsep)\r\n        asdf_finder = PythonFinder.create(\r\n            root=ASDF_DATA_DIR,\r\n            ignore_unsupported=True,\r\n            sort_function=parse_asdf_version_order,\r\n            version_glob_path=\"installs/python/*\",\r\n        )\r\n        asdf_index = None\r\n        try:\r\n            asdf_index = self._get_last_instance(ASDF_DATA_DIR)\r\n        except ValueError:\r\n            asdf_index = 0 if is_in_path(next(iter(os_path), \"\"), ASDF_DATA_DIR) else -1\r\n        if asdf_index is None:\r\n            # we are in a virtualenv without global pyenv on the path, so we should\r\n            # not write pyenv to the path here\r\n            return self\r\n        # * These are the root paths for the finder\r\n        _ = [p for p in asdf_finder.roots]\r\n        new_instance = self._slice_in_paths(asdf_index, [asdf_finder.root])\r\n        paths = self.paths.copy()\r\n        paths[asdf_finder.root] = asdf_finder\r\n        paths.update(asdf_finder.roots)\r\n        return (\r\n            attr.evolve(new_instance, paths=paths, asdf_finder=asdf_finder)\r\n            ._remove_path(normalize_path(os.path.join(ASDF_DATA_DIR, \"shims\")))\r\n            ._register_finder(\"asdf\", asdf_finder)\r\n        )\r\n\r\n    def reload_finder(self, finder_name):\r\n        # type: (str) -> \"SystemPath\"\r\n        if finder_name is None:\r\n            raise TypeError(\"Must pass a string as the name of the target finder\")\r\n        finder_attr = \"{0}_finder\".format(finder_name)\r\n        setup_attr = \"_setup_{0}\".format(finder_name)\r\n        try:\r\n            current_finder = getattr(self, finder_attr)  # type: Any\r\n        except AttributeError:\r\n            raise ValueError(\"Must pass a valid finder to reload.\")\r\n        try:\r\n            setup_fn = getattr(self, setup_attr)\r\n        except AttributeError:\r\n            raise ValueError(\"Finder has no valid setup function: %s\" % finder_name)\r\n        if current_finder is None:\r\n            # TODO: This is called 'reload', should we load a new finder for the first\r\n            # time here? lets just skip that for now to avoid unallowed finders\r\n            pass\r\n        if (finder_name == \"pyenv\" and not PYENV_INSTALLED) or (\r\n            finder_name == \"asdf\" and not ASDF_INSTALLED\r\n        ):\r\n            # Don't allow loading of finders that aren't explicitly 'installed' as it were\r\n            return self\r\n        setattr(self, finder_attr, None)\r\n        if finder_name in self.__finders:\r\n            del self.__finders[finder_name]\r\n        return setup_fn()\r\n\r\n    def _setup_pyenv(self):\r\n        # type: () -> \"SystemPath\"\r\n        if \"pyenv\" in self.finders and self.pyenv_finder is not None:\r\n            return self\r\n        from .python import PythonFinder\r\n\r\n        os_path = os.environ[\"PATH\"].split(os.pathsep)\r\n\r\n        pyenv_finder = PythonFinder.create(\r\n            root=PYENV_ROOT,\r\n            sort_function=parse_pyenv_version_order,\r\n            version_glob_path=\"versions/*\",\r\n            ignore_unsupported=self.ignore_unsupported,\r\n        )\r\n        pyenv_index = None\r\n        try:\r\n            pyenv_index = self._get_last_instance(PYENV_ROOT)\r\n        except ValueError:\r\n            pyenv_index = 0 if is_in_path(next(iter(os_path), \"\"), PYENV_ROOT) else -1\r\n        if pyenv_index is None:\r\n            # we are in a virtualenv without global pyenv on the path, so we should\r\n            # not write pyenv to the path here\r\n            return self\r\n        # * These are the root paths for the finder\r\n        _ = [p for p in pyenv_finder.roots]\r\n        new_instance = self._slice_in_paths(pyenv_index, [pyenv_finder.root])\r\n        paths = new_instance.paths.copy()\r\n        paths[pyenv_finder.root] = pyenv_finder\r\n        paths.update(pyenv_finder.roots)\r\n        return (\r\n            attr.evolve(new_instance, paths=paths, pyenv_finder=pyenv_finder)\r\n            ._remove_path(os.path.join(PYENV_ROOT, \"shims\"))\r\n            ._register_finder(\"pyenv\", pyenv_finder)\r\n        )\r\n\r\n    def _setup_windows(self):\r\n        # type: () -> \"SystemPath\"\r\n        if \"windows\" in self.finders and self.windows_finder is not None:\r\n            return self\r\n        from .windows import WindowsFinder\r\n\r\n        windows_finder = WindowsFinder.create()\r\n        root_paths = (p for p in windows_finder.paths if p.is_root)\r\n        path_addition = [p.path.as_posix() for p in root_paths]\r\n        new_path_order = self.path_order[:] + path_addition\r\n        new_paths = self.paths.copy()\r\n        new_paths.update({p.path: p for p in root_paths})\r\n        return attr.evolve(\r\n            self,\r\n            windows_finder=windows_finder,\r\n            path_order=new_path_order,\r\n            paths=new_paths,\r\n        )._register_finder(\"windows\", windows_finder)\r\n\r\n    def get_path(self, path):\r\n        # type: (Union[str, Path]) -> PathType\r\n        if path is None:\r\n            raise TypeError(\"A path must be provided in order to generate a path entry.\")\r\n        path = ensure_path(path)\r\n        _path = self.paths.get(path)\r\n        if not _path:\r\n            _path = self.paths.get(path.as_posix())\r\n        if not _path and path.as_posix() in self.path_order:\r\n            _path = PathEntry.create(\r\n                path=path.absolute(), is_root=True, only_python=self.only_python\r\n            )\r\n            self.paths[path.as_posix()] = _path\r\n        if not _path:\r\n            raise ValueError(\"Path not found or generated: {0!r}\".format(path))\r\n        return _path\r\n\r\n    def _get_paths(self):\r\n        # type: () -> Generator[Union[PathType, WindowsFinder], None, None]\r\n        for path in self.path_order:\r\n            try:\r\n                entry = self.get_path(path)\r\n            except ValueError:\r\n                continue\r\n            else:\r\n                yield entry\r\n\r\n    @cached_property\r\n    def path_entries(self):\r\n        # type: () -> List[Union[PathType, WindowsFinder]]\r\n        paths = list(self._get_paths())\r\n        return paths\r\n\r\n    def find_all(self, executable):\r\n        # type: (str) -> List[Union[PathEntry, FinderType]]\r\n        \"\"\"\r\n        Search the path for an executable. Return all copies.\r\n\r\n        :param executable: Name of the executable\r\n        :type executable: str\r\n        :returns: List[PathEntry]\r\n        \"\"\"\r\n\r\n        sub_which = operator.methodcaller(\"which\", executable)\r\n        filtered = (sub_which(self.get_path(k)) for k in self.path_order)\r\n        return list(filtered)\r\n\r\n    def which(self, executable):\r\n        # type: (str) -> Union[PathEntry, None]\r\n        \"\"\"\r\n        Search for an executable on the path.\r\n\r\n        :param executable: Name of the executable to be located.\r\n        :type executable: str\r\n        :returns: :class:`~pythonfinder.models.PathEntry` object.\r\n        \"\"\"\r\n\r\n        sub_which = operator.methodcaller(\"which\", executable)\r\n        filtered = (sub_which(self.get_path(k)) for k in self.path_order)\r\n        return next(iter(f for f in filtered if f is not None), None)\r\n\r\n    def _filter_paths(self, finder):\r\n        # type: (Callable) -> Iterator\r\n        for path in self._get_paths():\r\n            if path is None:\r\n                continue\r\n            python_versions = finder(path)\r\n            if python_versions is not None:\r\n                for python in python_versions:\r\n                    if python is not None:\r\n                        yield python\r\n\r\n    def _get_all_pythons(self, finder):\r\n        # type: (Callable) -> Iterator\r\n        for python in self._filter_paths(finder):\r\n            if python is not None and python.is_python:\r\n                yield python\r\n\r\n    def get_pythons(self, finder):\r\n        # type: (Callable) -> Iterator\r\n        sort_key = operator.attrgetter(\"as_python.version_sort\")\r\n        pythons = [entry for entry in self._get_all_pythons(finder)]\r\n        for python in sorted(pythons, key=sort_key, reverse=True):\r\n            if python is not None:\r\n                yield python\r\n\r\n    def find_all_python_versions(\r\n        self,\r\n        major=None,  # type: Optional[Union[str, int]]\r\n        minor=None,  # type: Optional[int]\r\n        patch=None,  # type: Optional[int]\r\n        pre=None,  # type: Optional[bool]\r\n        dev=None,  # type: Optional[bool]\r\n        arch=None,  # type: Optional[str]\r\n        name=None,  # type: Optional[str]\r\n    ):\r\n        # type (...) -> List[PathEntry]\r\n        \"\"\"Search for a specific python version on the path. Return all copies\r\n\r\n        :param major: Major python version to search for.\r\n        :type major: int\r\n        :param int minor: Minor python version to search for, defaults to None\r\n        :param int patch: Patch python version to search for, defaults to None\r\n        :param bool pre: Search for prereleases (default None) - prioritize releases if None\r\n        :param bool dev: Search for devreleases (default None) - prioritize releases if None\r\n        :param str arch: Architecture to include, e.g. '64bit', defaults to None\r\n        :param str name: The name of a python version, e.g. ``anaconda3-5.3.0``\r\n        :return: A list of :class:`~pythonfinder.models.PathEntry` instances matching the version requested.\r\n        :rtype: List[:class:`~pythonfinder.models.PathEntry`]\r\n        \"\"\"\r\n\r\n        sub_finder = operator.methodcaller(\r\n            \"find_all_python_versions\", major, minor, patch, pre, dev, arch, name\r\n        )\r\n        alternate_sub_finder = None\r\n        if major and not (minor or patch or pre or dev or arch or name):\r\n            alternate_sub_finder = operator.methodcaller(\r\n                \"find_all_python_versions\", None, None, None, None, None, None, major\r\n            )\r\n        if os.name == \"nt\" and self.windows_finder:\r\n            windows_finder_version = sub_finder(self.windows_finder)\r\n            if windows_finder_version:\r\n                return windows_finder_version\r\n        values = list(self.get_pythons(sub_finder))\r\n        if not values and alternate_sub_finder is not None:\r\n            values = list(self.get_pythons(alternate_sub_finder))\r\n        return values\r\n\r\n    def find_python_version(\r\n        self,\r\n        major=None,  # type: Optional[Union[str, int]]\r\n        minor=None,  # type: Optional[Union[str, int]]\r\n        patch=None,  # type: Optional[Union[str, int]]\r\n        pre=None,  # type: Optional[bool]\r\n        dev=None,  # type: Optional[bool]\r\n        arch=None,  # type: Optional[str]\r\n        name=None,  # type: Optional[str]\r\n        sort_by_path=False,  # type: bool\r\n    ):\r\n        # type: (...) -> PathEntry\r\n        \"\"\"Search for a specific python version on the path.\r\n\r\n        :param major: Major python version to search for.\r\n        :type major: int\r\n        :param int minor: Minor python version to search for, defaults to None\r\n        :param int patch: Patch python version to search for, defaults to None\r\n        :param bool pre: Search for prereleases (default None) - prioritize releases if None\r\n        :param bool dev: Search for devreleases (default None) - prioritize releases if None\r\n        :param str arch: Architecture to include, e.g. '64bit', defaults to None\r\n        :param str name: The name of a python version, e.g. ``anaconda3-5.3.0``\r\n        :param bool sort_by_path: Whether to sort by path -- default sort is by version(default: False)\r\n        :return: A :class:`~pythonfinder.models.PathEntry` instance matching the version requested.\r\n        :rtype: :class:`~pythonfinder.models.PathEntry`\r\n        \"\"\"\r\n\r\n        major, minor, patch, name = split_version_and_name(major, minor, patch, name)\r\n        sub_finder = operator.methodcaller(\r\n            \"find_python_version\", major, minor, patch, pre, dev, arch, name\r\n        )\r\n        alternate_sub_finder = None\r\n        if name and not (minor or patch or pre or dev or arch or major):\r\n            alternate_sub_finder = operator.methodcaller(\r\n                \"find_all_python_versions\", None, None, None, None, None, None, name\r\n            )\r\n        if major and minor and patch:\r\n            _tuple_pre = pre if pre is not None else False\r\n            _tuple_dev = dev if dev is not None else False\r\n            version_tuple = (major, minor, patch, _tuple_pre, _tuple_dev)\r\n            version_tuple_pre = (major, minor, patch, True, False)\r\n        if os.name == \"nt\" and self.windows_finder:\r\n            windows_finder_version = sub_finder(self.windows_finder)\r\n            if windows_finder_version:\r\n                return windows_finder_version\r\n        if sort_by_path:\r\n            paths = [self.get_path(k) for k in self.path_order]\r\n            for path in paths:\r\n                found_version = sub_finder(path)\r\n                if found_version:\r\n                    return found_version\r\n            if alternate_sub_finder:\r\n                for path in paths:\r\n                    found_version = alternate_sub_finder(path)\r\n                    if found_version:\r\n                        return found_version\r\n\r\n        ver = next(iter(self.get_pythons(sub_finder)), None)\r\n        if not ver and alternate_sub_finder is not None:\r\n            ver = next(iter(self.get_pythons(alternate_sub_finder)), None)\r\n        if ver:\r\n            if ver.as_python.version_tuple[:5] in self.python_version_dict:\r\n                self.python_version_dict[ver.as_python.version_tuple[:5]].append(ver)\r\n            else:\r\n                self.python_version_dict[ver.as_python.version_tuple[:5]] = [ver]\r\n        return ver\r\n\r\n    @classmethod\r\n    def create(\r\n        cls,\r\n        path=None,  # type: str\r\n        system=False,  # type: bool\r\n        only_python=False,  # type: bool\r\n        global_search=True,  # type: bool\r\n        ignore_unsupported=True,  # type: bool\r\n    ):\r\n        # type: (...) -> SystemPath\r\n        \"\"\"Create a new :class:`pythonfinder.models.SystemPath` instance.\r\n\r\n        :param path: Search path to prepend when searching, defaults to None\r\n        :param path: str, optional\r\n        :param bool system: Whether to use the running python by default instead of searching, defaults to False\r\n        :param bool only_python: Whether to search only for python executables, defaults to False\r\n        :param bool ignore_unsupported: Whether to ignore unsupported python versions, if False, an error is raised, defaults to True\r\n        :return: A new :class:`pythonfinder.models.SystemPath` instance.\r\n        :rtype: :class:`pythonfinder.models.SystemPath`\r\n        \"\"\"\r\n\r\n        path_entries = defaultdict(\r\n            PathEntry\r\n        )  # type: DefaultDict[str, Union[PythonFinder, PathEntry]]\r\n        paths = []  # type: List[str]\r\n        if ignore_unsupported:\r\n            os.environ[\"PYTHONFINDER_IGNORE_UNSUPPORTED\"] = fs_str(\"1\")\r\n        if global_search:\r\n            if \"PATH\" in os.environ:\r\n                paths = os.environ[\"PATH\"].split(os.pathsep)\r\n        path_order = []  # type: List[str]\r\n        if path:\r\n            path_order = [path]\r\n            path_instance = ensure_path(path)\r\n            path_entries.update(\r\n                {\r\n                    path_instance.as_posix(): PathEntry.create(\r\n                        path=path_instance.absolute(),\r\n                        is_root=True,\r\n                        only_python=only_python,\r\n                    )\r\n                }\r\n            )\r\n            paths = [path] + paths\r\n        paths = [p for p in paths if not any(is_in_path(p, shim) for shim in SHIM_PATHS)]\r\n        _path_objects = [ensure_path(p.strip('\"')) for p in paths]\r\n        paths = [p.as_posix() for p in _path_objects]\r\n        path_entries.update(\r\n            {\r\n                p.as_posix(): PathEntry.create(\r\n                    path=p.absolute(), is_root=True, only_python=only_python\r\n                )\r\n                for p in _path_objects\r\n            }\r\n        )\r\n        instance = cls(\r\n            paths=path_entries,\r\n            path_order=path_order,\r\n            only_python=only_python,\r\n            system=system,\r\n            global_search=global_search,\r\n            ignore_unsupported=ignore_unsupported,\r\n        )\r\n        instance = instance._run_setup()\r\n        return instance\r\n\r\n\r\n@attr.s(slots=True)\r\nclass PathEntry(BasePath):\r\n    is_root = attr.ib(default=True, type=bool, cmp=False)\r\n\r\n    def __lt__(self, other):\r\n        # type: (BasePath) -> bool\r\n        return self.path.as_posix() < other.path.as_posix()\r\n\r\n    def __lte__(self, other):\r\n        # type: (BasePath) -> bool\r\n        return self.path.as_posix() <= other.path.as_posix()\r\n\r\n    def __gt__(self, other):\r\n        # type: (BasePath) -> bool\r\n        return self.path.as_posix() > other.path.as_posix()\r\n\r\n    def __gte__(self, other):\r\n        # type: (BasePath) -> bool\r\n        return self.path.as_posix() >= other.path.as_posix()\r\n\r\n    def __del__(self):\r\n        if getattr(self, \"_children\"):\r\n            del self._children\r\n        BasePath.__del__(self)\r\n\r\n    def _filter_children(self):\r\n        # type: () -> Iterator[Path]\r\n        if self.only_python:\r\n            children = filter_pythons(self.path)\r\n        else:\r\n            children = self.path.iterdir()\r\n        return children\r\n\r\n    def _gen_children(self):\r\n        # type: () -> Iterator\r\n        shim_paths = get_shim_paths()\r\n        pass_name = self.name != self.path.name\r\n        pass_args = {\"is_root\": False, \"only_python\": self.only_python}\r\n        if pass_name:\r\n            if self.name is not None and isinstance(self.name, six.string_types):\r\n                pass_args[\"name\"] = self.name  # type: ignore\r\n            elif self.path is not None and isinstance(self.path.name, six.string_types):\r\n                pass_args[\"name\"] = self.path.name  # type: ignore\r\n\r\n        if not self.is_dir:\r\n            yield (self.path.as_posix(), self)\r\n        elif self.is_root:\r\n            for child in self._filter_children():\r\n                if any(is_in_path(str(child), shim) for shim in shim_paths):\r\n                    continue\r\n                if self.only_python:\r\n                    try:\r\n                        entry = PathEntry.create(path=child, **pass_args)  # type: ignore\r\n                    except (InvalidPythonVersion, ValueError):\r\n                        continue\r\n                else:\r\n                    entry = PathEntry.create(path=child, **pass_args)  # type: ignore\r\n                yield (child.as_posix(), entry)\r\n        return\r\n\r\n    @property\r\n    def children(self):\r\n        # type: () -> Dict[str, PathEntry]\r\n        children = getattr(self, \"_children\", {})  # type: Dict[str, PathEntry]\r\n        if not children:\r\n            for child_key, child_val in self._gen_children():\r\n                children[child_key] = child_val\r\n            self.children = children\r\n        return self._children\r\n\r\n    @children.setter\r\n    def children(self, val):\r\n        # type: (Dict[str, PathEntry]) -> None\r\n        self._children = val\r\n\r\n    @children.deleter\r\n    def children(self):\r\n        # type: () -> None\r\n        del self._children\r\n\r\n    @classmethod\r\n    def create(cls, path, is_root=False, only_python=False, pythons=None, name=None):\r\n        # type: (Union[str, Path], bool, bool, Dict[str, PythonVersion], Optional[str]) -> PathEntry\r\n        \"\"\"Helper method for creating new :class:`pythonfinder.models.PathEntry` instances.\r\n\r\n        :param str path: Path to the specified location.\r\n        :param bool is_root: Whether this is a root from the environment PATH variable, defaults to False\r\n        :param bool only_python: Whether to search only for python executables, defaults to False\r\n        :param dict pythons: A dictionary of existing python objects (usually from a finder), defaults to None\r\n        :param str name: Name of the python version, e.g. ``anaconda3-5.3.0``\r\n        :return: A new instance of the class.\r\n        :rtype: :class:`pythonfinder.models.PathEntry`\r\n        \"\"\"\r\n\r\n        target = ensure_path(path)\r\n        guessed_name = False\r\n        if not name:\r\n            guessed_name = True\r\n            name = target.name\r\n        creation_args = {\r\n            \"path\": target,\r\n            \"is_root\": is_root,\r\n            \"only_python\": only_python,\r\n            \"name\": name,\r\n        }\r\n        if pythons:\r\n            creation_args[\"pythons\"] = pythons\r\n        _new = cls(**creation_args)\r\n        if pythons and only_python:\r\n            children = {}\r\n            child_creation_args = {\"is_root\": False, \"only_python\": only_python}\r\n            if not guessed_name:\r\n                child_creation_args[\"name\"] = _new.name  # type: ignore\r\n            for pth, python in pythons.items():\r\n                if any(shim in normalize_path(str(pth)) for shim in SHIM_PATHS):\r\n                    continue\r\n                pth = ensure_path(pth)\r\n                children[pth.as_posix()] = PathEntry(  # type: ignore\r\n                    py_version=python, path=pth, **child_creation_args\r\n                )\r\n            _new._children = children\r\n        return _new\r\n\r\n\r\n@attr.s\r\nclass VersionPath(SystemPath):\r\n    base = attr.ib(default=None, validator=optional_instance_of(Path))  # type: Path\r\n    name = attr.ib(default=None)  # type: str\r\n\r\n    @classmethod\r\n    def create(cls, path, only_python=True, pythons=None, name=None):\r\n        \"\"\"Accepts a path to a base python version directory.\r\n\r\n        Generates the version listings for it\"\"\"\r\n        from .path import PathEntry\r\n\r\n        path = ensure_path(path)\r\n        path_entries = defaultdict(PathEntry)\r\n        bin_ = \"{base}/bin\"\r\n        if path.as_posix().endswith(Path(bin_).name):\r\n            path = path.parent\r\n        bin_dir = ensure_path(bin_.format(base=path.as_posix()))\r\n        if not name:\r\n            name = path.name\r\n        current_entry = PathEntry.create(\r\n            bin_dir, is_root=True, only_python=True, pythons=pythons, name=name\r\n        )\r\n        path_entries[bin_dir.as_posix()] = current_entry\r\n        return cls(name=name, base=bin_dir, paths=path_entries)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- env/Lib/site-packages/pipenv/vendor/pythonfinder/models/path.py	(revision 7de091c5b19e7b06e80c151f7100df6d0f893820)
+++ env/Lib/site-packages/pipenv/vendor/pythonfinder/models/path.py	(date 1591098443798)
@@ -27,7 +27,6 @@
     Sequence,
     dedup,
     ensure_path,
-    expand_paths,
     filter_pythons,
     is_in_path,
     normalize_path,
Index: env/Lib/site-packages/pipenv-2020.6.2.dist-info/WHEEL
===================================================================
--- env/Lib/site-packages/pipenv-2020.6.2.dist-info/WHEEL	(date 1591098444261)
+++ env/Lib/site-packages/pipenv-2020.6.2.dist-info/WHEEL	(date 1591098444261)
@@ -0,0 +1,6 @@
+Wheel-Version: 1.0
+Generator: bdist_wheel (0.34.2)
+Root-Is-Purelib: true
+Tag: py2-none-any
+Tag: py3-none-any
+
Index: env/Lib/site-packages/pipenv-2020.6.2.dist-info/top_level.txt
===================================================================
--- env/Lib/site-packages/pipenv-2020.6.2.dist-info/top_level.txt	(date 1591098444289)
+++ env/Lib/site-packages/pipenv-2020.6.2.dist-info/top_level.txt	(date 1591098444289)
@@ -0,0 +1,1 @@
+pipenv
Index: env/Lib/site-packages/pipenv-2020.6.2.dist-info/entry_points.txt
===================================================================
--- env/Lib/site-packages/pipenv-2020.6.2.dist-info/entry_points.txt	(date 1591098444288)
+++ env/Lib/site-packages/pipenv-2020.6.2.dist-info/entry_points.txt	(date 1591098444288)
@@ -0,0 +1,4 @@
+[console_scripts]
+pipenv = pipenv:cli
+pipenv-resolver = pipenv.resolver:main
+
Index: env/Lib/site-packages/pipenv-2020.6.2.dist-info/RECORD
===================================================================
--- env/Lib/site-packages/pipenv-2020.6.2.dist-info/RECORD	(date 1591098487892)
+++ env/Lib/site-packages/pipenv-2020.6.2.dist-info/RECORD	(date 1591098487892)
@@ -0,0 +1,2038 @@
+../../Scripts/pipenv-resolver.exe,sha256=M6E7YSF-Wr1BRLBGk0lu62sfFGd4Go5gVbr6nJ4qoDo,97171
+../../Scripts/pipenv.exe,sha256=BlpPyLdixbkOmbvaaGbC4V6RggNfBEqYN6ql7T9Wm_U,97160
+pipenv-2020.6.2.dist-info/INSTALLER,sha256=zuuue4knoyJ-UwPPXg8fezS7VCrXJQrAP7zeNuwvFQg,4
+pipenv-2020.6.2.dist-info/LICENSE,sha256=LT0pQT1YjMH-gr_BNeFzD9gjxJzRJsrQf-b1NEM9Qj8,1089
+pipenv-2020.6.2.dist-info/METADATA,sha256=FlbELS94e1oO7sesp1MoCc6z1JOtU76Bku9L6v-j7ZQ,13409
+pipenv-2020.6.2.dist-info/RECORD,,
+pipenv-2020.6.2.dist-info/WHEEL,sha256=kGT74LWyRUZrL4VgLh6_g12IeVl_9u9ZVhadrgXZUEY,110
+pipenv-2020.6.2.dist-info/entry_points.txt,sha256=LqLVTg_M6Xfae0-wb2Sg_6T48FXbDY8wEXYC8PxlrWs,78
+pipenv-2020.6.2.dist-info/top_level.txt,sha256=U2mu5YX2F0WINWNw3UyWlki6obCg31YRjlgxs-iSpYY,7
+pipenv-2020.6.2.dist-info/zip-safe,sha256=AbpHGcgLb-kRsJGnwFEktk7uzpZOCcBY74-YBdrKVGs,1
+pipenv/__init__.py,sha256=z0MgvFnLZxf-kI1Kfvd9kqTTyRbddZhQOVBSEiYya0Y,1532
+pipenv/__main__.py,sha256=ivWkejleJNXQGxPoGH6SZNeJbbiSjhTgP2tivNTEqHo,60
+pipenv/__pycache__/__init__.cpython-37.pyc,,
+pipenv/__pycache__/__main__.cpython-37.pyc,,
+pipenv/__pycache__/__version__.cpython-37.pyc,,
+pipenv/__pycache__/_compat.cpython-37.pyc,,
+pipenv/__pycache__/cmdparse.cpython-37.pyc,,
+pipenv/__pycache__/core.cpython-37.pyc,,
+pipenv/__pycache__/environment.cpython-37.pyc,,
+pipenv/__pycache__/environments.cpython-37.pyc,,
+pipenv/__pycache__/exceptions.cpython-37.pyc,,
+pipenv/__pycache__/help.cpython-37.pyc,,
+pipenv/__pycache__/installers.cpython-37.pyc,,
+pipenv/__pycache__/pep508checker.cpython-37.pyc,,
+pipenv/__pycache__/progress.cpython-37.pyc,,
+pipenv/__pycache__/project.cpython-37.pyc,,
+pipenv/__pycache__/resolver.cpython-37.pyc,,
+pipenv/__pycache__/shells.cpython-37.pyc,,
+pipenv/__pycache__/utils.cpython-37.pyc,,
+pipenv/__version__.py,sha256=s2xcaNaetH2HYMUJzqEiYm48B3Yt001SjKZTqPe9rwg,219
+pipenv/_compat.py,sha256=I98loe0816HRjbarZkLKr8bIZbNwId9Sj-SkP1KO13M,4693
+pipenv/cli/__init__.py,sha256=Pf6B1u8Reo9l_Mmf1hsd4ZBIAA9zrRX4vF2h5jBduWY,98
+pipenv/cli/__pycache__/__init__.cpython-37.pyc,,
+pipenv/cli/__pycache__/command.cpython-37.pyc,,
+pipenv/cli/__pycache__/options.cpython-37.pyc,,
+pipenv/cli/command.py,sha256=Sh1M6M_ZH4sjeJARsvfb8xY1boUfH7eGIfOcWwoptLU,21846
+pipenv/cli/options.py,sha256=x81T-gNTHCRjU0TzoKfZsUNksI4OLqf-IQ_AMViO-j4,15525
+pipenv/cmdparse.py,sha256=EhtDzKX06mqg2bGTDFsfSKJ_N0OiKuV4Pt9NSlVuCgk,3071
+pipenv/core.py,sha256=Eo6ayzoXvO8c2mjhxsX9dwXm7-_TmZsmG4ecCkPQSGk,110129
+pipenv/environment.py,sha256=1rHMblReL1NH9AuiKtFFI2GMWLoPjg-TbqF4SYD68Ks,42646
+pipenv/environments.py,sha256=avmGyv8_4QU0AXT2sUIYEPJckwwdf4uFbBw0RW54W1s,13403
+pipenv/exceptions.py,sha256=nDk70bauOAzyNg2pxI7f8JeJjge8ahTm40mKOQHHfMI,17908
+pipenv/help.py,sha256=PIdx8N6_yc-tuzMTeXDBFjisSj-7KISaLh9cOAm2gu4,2411
+pipenv/installers.py,sha256=aBM3nUpXlQtFuMpTDXePvn8SzQZp-Qj8cVCF5YAjtd0,7603
+pipenv/patched/README.md,sha256=5Wb8KpoDzlpF75xev-E-4WLMFLBmry9UOJyw9P56eGc,693
+pipenv/patched/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+pipenv/patched/__pycache__/__init__.cpython-37.pyc,,
+pipenv/patched/__pycache__/crayons.cpython-37.pyc,,
+pipenv/patched/crayons.LICENSE,sha256=3bNiymFecP3ZRFFCGR-VkbIP72WDqQBUO8pSX-AMEqA,1053
+pipenv/patched/crayons.py,sha256=7CNyDXBHArW3rvl0z4ZBgQDQSrw1YwEle7xh5GlohTg,5085
+pipenv/patched/notpip/LICENSE.txt,sha256=W6Ifuwlk-TatfRU2LR7W1JMcyMj5_y1NkRkOEJvnRDE,1090
+pipenv/patched/notpip/__init__.py,sha256=IfKY47RP_HSAjcuA-WSfb7a5TilYn0-wRTsK1nroPMw,491
+pipenv/patched/notpip/__main__.py,sha256=cPKbL-dqcYHNF4TXlRqOWOwrTVWTHAefY0Sbg3seY5s,751
+pipenv/patched/notpip/__pycache__/__init__.cpython-37.pyc,,
+pipenv/patched/notpip/__pycache__/__main__.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/__init__.py,sha256=R5Yuc7m8W2IWQGW5rObj0RGLpjw98twb6-FmNz4fZRo,571
+pipenv/patched/notpip/_internal/__pycache__/__init__.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/__pycache__/build_env.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/__pycache__/cache.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/__pycache__/configuration.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/__pycache__/exceptions.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/__pycache__/legacy_resolve.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/__pycache__/locations.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/__pycache__/main.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/__pycache__/pep425tags.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/__pycache__/pyproject.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/__pycache__/self_outdated_check.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/__pycache__/wheel_builder.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/build_env.py,sha256=sJ07dmqsNWNeBVCgeftJub5eDqPSAMkFlZzjcqiFoOs,7733
+pipenv/patched/notpip/_internal/cache.py,sha256=lN58nc3G80NrlJ3l_kK5dNaIHRWwVpkaaF2zFu2KZoM,11785
+pipenv/patched/notpip/_internal/cli/__init__.py,sha256=FkHBgpxxb-_gd6r1FjnNhfMOzAUYyXoXKJ6abijfcFU,132
+pipenv/patched/notpip/_internal/cli/__pycache__/__init__.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/cli/__pycache__/autocompletion.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/cli/__pycache__/base_command.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/cli/__pycache__/cmdoptions.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/cli/__pycache__/command_context.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/cli/__pycache__/main.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/cli/__pycache__/main_parser.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/cli/__pycache__/parser.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/cli/__pycache__/req_command.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/cli/__pycache__/status_codes.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/cli/autocompletion.py,sha256=OXB5pbWcLAxiPEFjqhQdGGIOivJL42Mp4EDAqTH-XRs,6619
+pipenv/patched/notpip/_internal/cli/base_command.py,sha256=b-hJd-Adh9ry-1HyRZgXojYqOwhxzID2ixmmAGokTY8,8164
+pipenv/patched/notpip/_internal/cli/cmdoptions.py,sha256=mSCd3g_2dSjn3dOcxhGlfpBROOxZaqvQUrTa5Up_16M,28277
+pipenv/patched/notpip/_internal/cli/command_context.py,sha256=AgYrNaZhh6wtAR0TF9VahKUw-vwwCfhw4bga08HvhrY,1011
+pipenv/patched/notpip/_internal/cli/main.py,sha256=8SpcGygRj7uDDhurUcpLh1W_z0vOAAhAkw89BblRb6g,2718
+pipenv/patched/notpip/_internal/cli/main_parser.py,sha256=jle9YpEl_dp219o7qj0e8K8xFJknljidTzVflAaDhYY,2927
+pipenv/patched/notpip/_internal/cli/parser.py,sha256=_eh-iEwWVsDEW3YT9mMNroyVv3GRBpTD3AqO6LQKPxU,9559
+pipenv/patched/notpip/_internal/cli/req_command.py,sha256=W-HKPzXsou2GLd9FLIZ6Q0Ib5fYv4tV6LEolel9u-_s,12787
+pipenv/patched/notpip/_internal/cli/status_codes.py,sha256=F6uDG6Gj7RNKQJUDnd87QKqI16Us-t-B0wPF_4QMpWc,156
+pipenv/patched/notpip/_internal/commands/__init__.py,sha256=6OGuQRAnV2lYxj91EVTpMfIq9g5_8cT5foy0dlmwZ70,4020
+pipenv/patched/notpip/_internal/commands/__pycache__/__init__.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/commands/__pycache__/check.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/commands/__pycache__/completion.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/commands/__pycache__/configuration.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/commands/__pycache__/debug.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/commands/__pycache__/download.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/commands/__pycache__/freeze.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/commands/__pycache__/hash.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/commands/__pycache__/help.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/commands/__pycache__/install.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/commands/__pycache__/list.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/commands/__pycache__/search.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/commands/__pycache__/show.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/commands/__pycache__/uninstall.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/commands/__pycache__/wheel.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/commands/check.py,sha256=WPFHFTb4p8mEAT4hHQwjeJdBVWUgNvzcDtGBbzR963Q,1559
+pipenv/patched/notpip/_internal/commands/completion.py,sha256=x-DWCxdwPNbDfSYkgyQNttgwXoFV_FsXvV130MZQUZ0,3011
+pipenv/patched/notpip/_internal/commands/configuration.py,sha256=Tl40XSonjS5LpipCXEeyg8eDzbkQXz5YfVeTCVty9t0,7316
+pipenv/patched/notpip/_internal/commands/debug.py,sha256=F2lyKU0uoD01RFr1L912H2Zc9rnRIfvIf7wTX-kij7g,4353
+pipenv/patched/notpip/_internal/commands/download.py,sha256=dl8rYWbPQI_rslBFK7ravNW_ASApsElVDyaGJlV_H_4,5133
+pipenv/patched/notpip/_internal/commands/freeze.py,sha256=NknE6qylQbF2KXvvEb1zr09s2yRPW44HP6DtYpQRalM,3572
+pipenv/patched/notpip/_internal/commands/hash.py,sha256=puviOQSrr4_PIMLc7NtATTzDjG5pEZsP5qWW4pX8jdQ,1807
+pipenv/patched/notpip/_internal/commands/help.py,sha256=J1nHZyAS2qQVs6mJWRT_7q7yvtwb87Bz1hQYp3Zn2MU,1253
+pipenv/patched/notpip/_internal/commands/install.py,sha256=7V5GrA2hWS1_v2klukH43BS-Ym435WQWqonyVzZpjK8,26702
+pipenv/patched/notpip/_internal/commands/list.py,sha256=OY1WhFe1t2rOyivZ1xo7rCc56da1fHI7meLv9Neddos,10743
+pipenv/patched/notpip/_internal/commands/search.py,sha256=Q-r-Y7wavALgYRRDAY16WS49sAju4EX8xAOf57sn0Lk,5364
+pipenv/patched/notpip/_internal/commands/show.py,sha256=9D53HuwRYwsDdMIyXVqEoBTxqGnmCu2y0yzPEEg69ZM,6882
+pipenv/patched/notpip/_internal/commands/uninstall.py,sha256=0C_YkADWLvUgrr2GnCp--GwyanvqwUOPAKnPauMz5D0,3109
+pipenv/patched/notpip/_internal/commands/wheel.py,sha256=KDtyAB0YgIExhvrtREMlDY0equkKuVWGdNRsg41BH-c,7350
+pipenv/patched/notpip/_internal/configuration.py,sha256=Rj1NGgicdBqgYt9FXWDXLDmhckqVFR0mXZk_B2gYdsg,14330
+pipenv/patched/notpip/_internal/distributions/__init__.py,sha256=dBpr-ALgrbrrJqD0NNBbKK1qfmJ9kuJQjXPk0YbRtI0,1049
+pipenv/patched/notpip/_internal/distributions/__pycache__/__init__.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/distributions/__pycache__/base.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/distributions/__pycache__/installed.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/distributions/__pycache__/sdist.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/distributions/__pycache__/wheel.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/distributions/base.py,sha256=zwbR510Cs1Pdht-fh73sagjd_zAdefDbugWzZUQLpYQ,1515
+pipenv/patched/notpip/_internal/distributions/installed.py,sha256=hMnN9pLuVXCg6DJCU1-EudAKZ_BBVacvyucU_1F7BlI,832
+pipenv/patched/notpip/_internal/distributions/sdist.py,sha256=vHMu5b6nUxy2xfFPqOQAn_j-PFD7-8YRH-_AlkLXwwg,4212
+pipenv/patched/notpip/_internal/distributions/wheel.py,sha256=wHEpRTB6TVz2IsK7GkFdrhGUENyzj8iR-EXcrdgPQI4,1384
+pipenv/patched/notpip/_internal/exceptions.py,sha256=yWhjjifA5_Ty2ltUt3zuQr1fkgKGC1sFdqAwLYChEsE,10337
+pipenv/patched/notpip/_internal/index/__init__.py,sha256=vpt-JeTZefh8a-FC22ZeBSXFVbuBcXSGiILhQZJaNpQ,30
+pipenv/patched/notpip/_internal/index/__pycache__/__init__.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/index/__pycache__/collector.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/index/__pycache__/package_finder.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/index/collector.py,sha256=9j3XVXMRLZ_KehrodgGnkFuYpRpMLoD9_VXqFAzict0,18144
+pipenv/patched/notpip/_internal/index/package_finder.py,sha256=aCubGFmtVZfbGUg3wUzAeDavtUgr2tKy_q36Hxn2-Qo,39461
+pipenv/patched/notpip/_internal/legacy_resolve.py,sha256=fyaMLg35ltF7lR83BCKGcHHkdGpvrjltJj2xaYZCGFE,17464
+pipenv/patched/notpip/_internal/locations.py,sha256=CubzBcfuZgPDqtb8rZrvb6yOyDE9l32spwZhTa9lN5c,6824
+pipenv/patched/notpip/_internal/main.py,sha256=Ii8sKGBtWtSYdPql5lcxsjF0Uy3_HeEBK0n_OWUd0zc,473
+pipenv/patched/notpip/_internal/models/__init__.py,sha256=3DHUd_qxpPozfzouoqa9g9ts1Czr5qaHfFxbnxriepM,63
+pipenv/patched/notpip/_internal/models/__pycache__/__init__.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/models/__pycache__/candidate.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/models/__pycache__/format_control.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/models/__pycache__/index.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/models/__pycache__/link.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/models/__pycache__/scheme.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/models/__pycache__/search_scope.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/models/__pycache__/selection_prefs.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/models/__pycache__/target_python.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/models/__pycache__/wheel.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/models/candidate.py,sha256=sex8ovNyX8ACQczNWcZ1IAoaA3ck7yNkdETxWeZpAYU,1314
+pipenv/patched/notpip/_internal/models/format_control.py,sha256=lTk0-klbxsBzPSr5pOAhDK7djTh1Lk-nzM5sA8wdVDE,2727
+pipenv/patched/notpip/_internal/models/index.py,sha256=nmXUsld6TXR20gG64Mtz0cYBkOzm3catQ8mE_NRhObM,1078
+pipenv/patched/notpip/_internal/models/link.py,sha256=_KBRc-6KDYWYTfb6WhX9UcuOM4dib8cgIQiW6wb1QV4,6989
+pipenv/patched/notpip/_internal/models/scheme.py,sha256=vvhBrrno7eVDXcdKHiZWwxhPHf4VG5uSCEkC0QDR2RU,679
+pipenv/patched/notpip/_internal/models/search_scope.py,sha256=0-JYuBKKeorgRt9uwcEQOQinaSlQU3QRtaWYGwvd5V8,4006
+pipenv/patched/notpip/_internal/models/selection_prefs.py,sha256=_8jR7pjlwbaBEMbrY6I8xQe-rhBsOyvNAFWaIYbvock,1944
+pipenv/patched/notpip/_internal/models/target_python.py,sha256=bQw_tOdpFiZmGAUhV2dkHdC8YLX0OXW8ts1v01VTEWE,3871
+pipenv/patched/notpip/_internal/models/wheel.py,sha256=JFnHAHHHtyTBsN-Vn5uoFxNdHN9jKMTZGF4CSz5awPs,2820
+pipenv/patched/notpip/_internal/network/__init__.py,sha256=jf6Tt5nV_7zkARBrKojIXItgejvoegVJVKUbhAa5Ioc,50
+pipenv/patched/notpip/_internal/network/__pycache__/__init__.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/network/__pycache__/auth.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/network/__pycache__/cache.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/network/__pycache__/download.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/network/__pycache__/session.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/network/__pycache__/utils.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/network/__pycache__/xmlrpc.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/network/auth.py,sha256=NlWeJVQb4UhvIAv5sd9knkNyEgruSUcvBCZgYmPc-sE,11227
+pipenv/patched/notpip/_internal/network/cache.py,sha256=gwWd5vxWBkASajyqgsU2sTYYyrXPc3dAFm3-gw3hl9s,2502
+pipenv/patched/notpip/_internal/network/download.py,sha256=RJsJWqdTVe_kDjQrGoIlkb-ahWfFPRH7u8ciYefs0YY,6458
+pipenv/patched/notpip/_internal/network/session.py,sha256=_g80tcp4zouhDAk6PoYlV7h-seDR9E6LypYdQtrs-C0,15008
+pipenv/patched/notpip/_internal/network/utils.py,sha256=z2Vp6ao_vopyD_YNpDa9ODf3KzHnQWAC8OXj20BBDT0,1995
+pipenv/patched/notpip/_internal/network/xmlrpc.py,sha256=TSTe3aqvL5agRZuwuNDDXuhtjVyfFH9yolih9EvSwps,1651
+pipenv/patched/notpip/_internal/operations/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+pipenv/patched/notpip/_internal/operations/__pycache__/__init__.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/operations/__pycache__/check.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/operations/__pycache__/freeze.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/operations/__pycache__/prepare.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/operations/build/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+pipenv/patched/notpip/_internal/operations/build/__pycache__/__init__.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/operations/build/__pycache__/metadata.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/operations/build/__pycache__/metadata_legacy.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/operations/build/__pycache__/wheel.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/operations/build/__pycache__/wheel_legacy.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/operations/build/metadata.py,sha256=SLyk7_YV95RVQZ8_fxiYDBWXodi0fGrPbLmDw3Pv6LI,1397
+pipenv/patched/notpip/_internal/operations/build/metadata_legacy.py,sha256=YOq1kMLjiSYrUFr7jJvJM2sjbt5ElVxEWlT4a7qOEfI,4083
+pipenv/patched/notpip/_internal/operations/build/wheel.py,sha256=3OOra_Ukbnue57hNE_skkkjIAoDCwEN0shdgUTxzFkk,1523
+pipenv/patched/notpip/_internal/operations/build/wheel_legacy.py,sha256=sB_v4m1X2jvmDrNxDOicRvMHnA4nbtX4poqY3SWaK3I,3421
+pipenv/patched/notpip/_internal/operations/check.py,sha256=YgvaGX7j872FzQsE3ZEK7MtFA_duFKz6eMPJ6VAGXTE,5461
+pipenv/patched/notpip/_internal/operations/freeze.py,sha256=NEe0GyK4RIwVa-Sl95Xyaa46F7ZELUadPgP2v8VHUy0,10378
+pipenv/patched/notpip/_internal/operations/install/__init__.py,sha256=mX7hyD2GNBO2mFGokDQ30r_GXv7Y_PLdtxcUv144e-s,51
+pipenv/patched/notpip/_internal/operations/install/__pycache__/__init__.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/operations/install/__pycache__/editable_legacy.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/operations/install/__pycache__/legacy.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/operations/install/__pycache__/wheel.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/operations/install/editable_legacy.py,sha256=88I83tUXarc9aiBSqibzUBLqgOSP5rT9Md59VVnnA2I,1578
+pipenv/patched/notpip/_internal/operations/install/legacy.py,sha256=bGDqkuaoKaPf1qIxonM7l5NvRA55aZ08dYta2RCGJU4,4728
+pipenv/patched/notpip/_internal/operations/install/wheel.py,sha256=iZL12vCE1wEkYTUIyZBfP8wv9cvS3_5RojhdWUs9EI0,23228
+pipenv/patched/notpip/_internal/operations/prepare.py,sha256=Vuzzz46OkppZbLoUL18uG_odlrpMQzq0iC1fmqYSTFo,20895
+pipenv/patched/notpip/_internal/pep425tags.py,sha256=JByVbVFbjm9eBjrcQrV9oc5HmB7JwwPUfptUL1FGRjo,5544
+pipenv/patched/notpip/_internal/pyproject.py,sha256=tjANmdxVReBX-GgIZyQ68L6fhnI-Fe7luX5p24YVXK8,7476
+pipenv/patched/notpip/_internal/req/__init__.py,sha256=j_TizBvNx2bZKG-4ZrPughuJZHkp1fUUwo6az1zVNpQ,2707
+pipenv/patched/notpip/_internal/req/__pycache__/__init__.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/req/__pycache__/constructors.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/req/__pycache__/req_file.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/req/__pycache__/req_install.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/req/__pycache__/req_set.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/req/__pycache__/req_tracker.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/req/__pycache__/req_uninstall.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/req/constructors.py,sha256=hEQ7loTYM8VP1oNSujyTsHrqdiHlkQJjq7NRLzeJqHQ,14676
+pipenv/patched/notpip/_internal/req/req_file.py,sha256=q-BQt3FI_BVApoTO6cmseFooOIbJf4tMLz4tgcnrB30,18719
+pipenv/patched/notpip/_internal/req/req_install.py,sha256=pDFNRkw5v-0hCZBZum76AS69Z_8s3GoyNvJm4s4kGnw,31054
+pipenv/patched/notpip/_internal/req/req_set.py,sha256=WnsdcwX6mUuq3J5KCU6JWQq0v1j9Wx1RnGdOjxnEhYQ,8360
+pipenv/patched/notpip/_internal/req/req_tracker.py,sha256=LGwBvAoyLMmlwo_zVve7wyGX5pTwqd0-Jfaw4yuPiJw,4813
+pipenv/patched/notpip/_internal/req/req_uninstall.py,sha256=TBCIvtrTIwL9X4AbDJ_WLa90pyJGD8_evSovZ2Vyht0,23771
+pipenv/patched/notpip/_internal/self_outdated_check.py,sha256=tRQ60tY2EORphtq3yEpJnDK37DHXvCy7p0bfBhkXqYA,8225
+pipenv/patched/notpip/_internal/utils/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+pipenv/patched/notpip/_internal/utils/__pycache__/__init__.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/utils/__pycache__/appdirs.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/utils/__pycache__/compat.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/utils/__pycache__/deprecation.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/utils/__pycache__/distutils_args.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/utils/__pycache__/encoding.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/utils/__pycache__/entrypoints.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/utils/__pycache__/filesystem.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/utils/__pycache__/filetypes.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/utils/__pycache__/glibc.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/utils/__pycache__/hashes.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/utils/__pycache__/inject_securetransport.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/utils/__pycache__/logging.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/utils/__pycache__/marker_files.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/utils/__pycache__/misc.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/utils/__pycache__/models.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/utils/__pycache__/packaging.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/utils/__pycache__/pkg_resources.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/utils/__pycache__/setuptools_build.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/utils/__pycache__/subprocess.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/utils/__pycache__/temp_dir.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/utils/__pycache__/typing.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/utils/__pycache__/ui.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/utils/__pycache__/unpacking.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/utils/__pycache__/urls.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/utils/__pycache__/virtualenv.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/utils/__pycache__/wheel.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/utils/appdirs.py,sha256=L2C6DzeSI0rx27utuObNgN9I9IuZAHDwHzCvHVhzUQI,1180
+pipenv/patched/notpip/_internal/utils/compat.py,sha256=j_XA2cgLEDUHZtp5RrQMwRxIHpGlrR2gpf7xZa9Dmn8,8941
+pipenv/patched/notpip/_internal/utils/deprecation.py,sha256=OYS4_x8nQlXh8a4N-NlFD5jTLgVpYzpNvRQ1yj7Sh8s,3372
+pipenv/patched/notpip/_internal/utils/distutils_args.py,sha256=y5uWLweVqwoFzV-VGT3kBRTPAgYECCxFbe-j1uaJTNU,1368
+pipenv/patched/notpip/_internal/utils/encoding.py,sha256=APcTiU9P-k_Hc72opyCLPyxbn4Hc3SRGz2iLCVw1SXM,1338
+pipenv/patched/notpip/_internal/utils/entrypoints.py,sha256=oN-jSjxfc8DPhtCW1gFiXWg0tf878iolnT2eB6FptUQ,1188
+pipenv/patched/notpip/_internal/utils/filesystem.py,sha256=NjlxE1Ee2ryvswH7570bJJBRPZ1c8VP-6IGheRfx0EQ,5327
+pipenv/patched/notpip/_internal/utils/filetypes.py,sha256=iVph7cQjh8efhSSmcEih3QCPIoAsPbb5NINDnjDHLIQ,589
+pipenv/patched/notpip/_internal/utils/glibc.py,sha256=x0kTKFHfiLhyYCVZvzNg4VfGItEKOcnc9DaDQLXRG80,3315
+pipenv/patched/notpip/_internal/utils/hashes.py,sha256=v0IHoNASjjVs7rdjS7NQIP51ofzkWqaB93KKJa1VldI,4032
+pipenv/patched/notpip/_internal/utils/inject_securetransport.py,sha256=3uHN0FJjJTzrrfPWjBVW5dytYMbHbGIyrtX_KnwyVkQ,828
+pipenv/patched/notpip/_internal/utils/logging.py,sha256=8ySZf843092zJUowQuNcMwUMwwg-jojxsPxkLvc8cC8,13213
+pipenv/patched/notpip/_internal/utils/marker_files.py,sha256=CO5djQlrPIozJpJybViH_insoAaBGY1aqEt6-cC-iW0,741
+pipenv/patched/notpip/_internal/utils/misc.py,sha256=KYFC1EuvUOS8v3bChEJZa86d3MRqMvAe225nW2GdbBM,25643
+pipenv/patched/notpip/_internal/utils/models.py,sha256=IA0hw_T4awQzui0kqfIEASm5yLtgZAB08ag59Nip5G8,1148
+pipenv/patched/notpip/_internal/utils/packaging.py,sha256=ri9VOJ8lBZp5RReErKhcjh4xuOJiprSg1t2Ou5gOB0k,3165
+pipenv/patched/notpip/_internal/utils/pkg_resources.py,sha256=rWO703RBfdKI64NDFaLlXZPjcueqlpuOH5Iy56RSSak,1308
+pipenv/patched/notpip/_internal/utils/setuptools_build.py,sha256=yFyqTrLqYFHITkvClMS06YJh6ltgXUXDx7WP2ApSTyE,5169
+pipenv/patched/notpip/_internal/utils/subprocess.py,sha256=YAFYoqGcmFc-zwl8sijy5BFzQBbcPm9JjM4aFeV4aLM,10066
+pipenv/patched/notpip/_internal/utils/temp_dir.py,sha256=sVVXF_q2REWtHbWgYcbic7n2PVrWXsZ016SLn-cC2z0,8777
+pipenv/patched/notpip/_internal/utils/typing.py,sha256=SBtbEcWE03iI-V1O-B7X8bEq1EDInpi1ykQi3NNhXIg,1419
+pipenv/patched/notpip/_internal/utils/ui.py,sha256=UAv19RdbE0j6oJi7sf1-6fOiLuMwlDiqZNbUsd1AAss,14073
+pipenv/patched/notpip/_internal/utils/unpacking.py,sha256=G3xwPs9adKgIWWdH5H_qNZZhEEvj1iOZRqx8XQqriT4,9510
+pipenv/patched/notpip/_internal/utils/urls.py,sha256=UB8Bkb77lhZpftHOyw0C1-VDbaI_VW_3FKRFWhekCm0,1535
+pipenv/patched/notpip/_internal/utils/virtualenv.py,sha256=Lu6mwwYrPPxWLu8Yx5T3e2irMGaHwgzd84GuW6GT_Kw,3414
+pipenv/patched/notpip/_internal/utils/wheel.py,sha256=ThPxCg5VxmVHR5A95WNjmd2wCXiF2sl-5RXb1S1Cjt8,7428
+pipenv/patched/notpip/_internal/vcs/__init__.py,sha256=pBBUuLhdGka-A2zr8VnR0Oojg57g4DSY9D9lEpnkmJE,707
+pipenv/patched/notpip/_internal/vcs/__pycache__/__init__.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/vcs/__pycache__/bazaar.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/vcs/__pycache__/git.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/vcs/__pycache__/mercurial.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/vcs/__pycache__/subversion.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/vcs/__pycache__/versioncontrol.cpython-37.pyc,,
+pipenv/patched/notpip/_internal/vcs/bazaar.py,sha256=7USM6J6Qbj4v6tHezmxwcjikfVzpkvUROvLYNzs3NrA,4101
+pipenv/patched/notpip/_internal/vcs/git.py,sha256=Rqz3dd2PLcQPMo-BtZmyTSVbcvmeWY-zXXE4WnwjiZ8,14256
+pipenv/patched/notpip/_internal/vcs/mercurial.py,sha256=nhhLRVGS8BwO_47q4UrSv7I1KdOIOzW1QrK_17tRVlg,5290
+pipenv/patched/notpip/_internal/vcs/subversion.py,sha256=IydWHFWQE9Z5S768aXhqhhqqSDNupk9diWa209Qp3wE,12454
+pipenv/patched/notpip/_internal/vcs/versioncontrol.py,sha256=rSO2GaWVJ0iqpfM7gISCYLfCmwC4bzS_inpYnmY9gLE,22798
+pipenv/patched/notpip/_internal/wheel_builder.py,sha256=optfyV7m9_1ZRYYvY-j1chHJd8azO4FanrJI01ZC9Po,9675
+pipenv/patched/notpip/_vendor/__init__.py,sha256=QveYbu1qZT4HsMqiVxvjbA6ZnSh75jEMd_Umi-ReR48,4675
+pipenv/patched/notpip/_vendor/__pycache__/__init__.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/__pycache__/appdirs.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/__pycache__/contextlib2.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/__pycache__/distro.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/__pycache__/ipaddress.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/__pycache__/pyparsing.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/__pycache__/retrying.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/__pycache__/six.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/appdirs.LICENSE.txt,sha256=Nt200KdFqTqyAyA9cZCBSxuJcn0lTK_0jHp6-71HAAs,1097
+pipenv/patched/notpip/_vendor/appdirs.py,sha256=kVvdzRSQW6hsZYPMrct3jav-CGIZ4horsK7KnUTjt7w,26130
+pipenv/patched/notpip/_vendor/cachecontrol/LICENSE.txt,sha256=YjcWF1a8R7Zc8_gg2TmV12-YzL1GWN_BDuCb1FWty0c,553
+pipenv/patched/notpip/_vendor/cachecontrol/__init__.py,sha256=pJtAaUxOsMPnytI1A3juAJkXYDr8krdSnsg4Yg3OBEg,302
+pipenv/patched/notpip/_vendor/cachecontrol/__pycache__/__init__.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/cachecontrol/__pycache__/_cmd.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/cachecontrol/__pycache__/adapter.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/cachecontrol/__pycache__/cache.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/cachecontrol/__pycache__/compat.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/cachecontrol/__pycache__/controller.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/cachecontrol/__pycache__/filewrapper.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/cachecontrol/__pycache__/heuristics.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/cachecontrol/__pycache__/serialize.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/cachecontrol/__pycache__/wrapper.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/cachecontrol/_cmd.py,sha256=OHj0ODL1SZjp7vH4SQm8bLKfEY-r15c608mOOb2Rh1w,1367
+pipenv/patched/notpip/_vendor/cachecontrol/adapter.py,sha256=CeQNT2od4tMh9nojX8yrRVyrTPnpmWrpZwNZnj31Xx4,4900
+pipenv/patched/notpip/_vendor/cachecontrol/cache.py,sha256=1fc4wJP8HYt1ycnJXeEw5pCpeBL2Cqxx6g9Fb0AYDWQ,805
+pipenv/patched/notpip/_vendor/cachecontrol/caches/__init__.py,sha256=-gHNKYvaeD0kOk5M74eOrsSgIKUtC6i6GfbmugGweEo,86
+pipenv/patched/notpip/_vendor/cachecontrol/caches/__pycache__/__init__.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/cachecontrol/caches/__pycache__/file_cache.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/cachecontrol/caches/__pycache__/redis_cache.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/cachecontrol/caches/file_cache.py,sha256=nYVKsJtXh6gJXvdn1iWyrhxvkwpQrK-eKoMRzuiwkKk,4153
+pipenv/patched/notpip/_vendor/cachecontrol/caches/redis_cache.py,sha256=P91SCXCcwo1fAUsxr-0UVje8LVRndKhtVIiBkoL-ldA,874
+pipenv/patched/notpip/_vendor/cachecontrol/compat.py,sha256=RVmzxAzT7b530_KcG_DtGS85b7gDcADzPJcwESnvOj8,767
+pipenv/patched/notpip/_vendor/cachecontrol/controller.py,sha256=qpW2esv95Cd3jMVUZYjdmkmNPSWtLD2KxPiTAwixB28,14167
+pipenv/patched/notpip/_vendor/cachecontrol/filewrapper.py,sha256=vACKO8Llzu_ZWyjV1Fxn1MA4TGU60N5N3GSrAFdAY2Q,2533
+pipenv/patched/notpip/_vendor/cachecontrol/heuristics.py,sha256=BFGHJ3yQcxvZizfo90LLZ04T_Z5XSCXvFotrp7Us0sc,4070
+pipenv/patched/notpip/_vendor/cachecontrol/serialize.py,sha256=4Ut7BSwJhe8C_t9YPd3uGY59pcgBunLaLzpz1hAQzXc,7127
+pipenv/patched/notpip/_vendor/cachecontrol/wrapper.py,sha256=5LX0uJwkNQUtYSEw3aGmGu9WY8wGipd81mJ8lG0d0M4,690
+pipenv/patched/notpip/_vendor/certifi/LICENSE,sha256=anCkv2sBABbVmmS4rkrY3H9e8W8ftFPMLs13HFo0ETE,1048
+pipenv/patched/notpip/_vendor/certifi/__init__.py,sha256=JVwzDhkMttyVVtfNDrU_i0v2a-WmtEBXq0Z8oz4Ghzk,52
+pipenv/patched/notpip/_vendor/certifi/__main__.py,sha256=E5_NRS6fnF_JzY4nUr7BqWIAszJbUVIITeBkAuHEErU,71
+pipenv/patched/notpip/_vendor/certifi/__pycache__/__init__.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/certifi/__pycache__/__main__.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/certifi/__pycache__/core.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/certifi/cacert.pem,sha256=cyvv5Jx1gHACNEj2GaOrsIj0Tk8FmSvHR42uhzvlatg,281457
+pipenv/patched/notpip/_vendor/certifi/core.py,sha256=EuFc2BsToG5O1-qsx4BSjQ1r1-7WRtH87b1WflZOWhI,218
+pipenv/patched/notpip/_vendor/chardet/LICENSE,sha256=YJXp_6d33SKDn3gBqoRbMcntB_PWv4om3F0t7IzMDvM,26432
+pipenv/patched/notpip/_vendor/chardet/__init__.py,sha256=YsP5wQlsHJ2auF1RZJfypiSrCA7_bQiRm3ES_NI76-Y,1559
+pipenv/patched/notpip/_vendor/chardet/__pycache__/__init__.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/chardet/__pycache__/big5freq.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/chardet/__pycache__/big5prober.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/chardet/__pycache__/chardistribution.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/chardet/__pycache__/charsetgroupprober.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/chardet/__pycache__/charsetprober.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/chardet/__pycache__/codingstatemachine.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/chardet/__pycache__/compat.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/chardet/__pycache__/cp949prober.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/chardet/__pycache__/enums.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/chardet/__pycache__/escprober.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/chardet/__pycache__/escsm.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/chardet/__pycache__/eucjpprober.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/chardet/__pycache__/euckrfreq.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/chardet/__pycache__/euckrprober.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/chardet/__pycache__/euctwfreq.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/chardet/__pycache__/euctwprober.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/chardet/__pycache__/gb2312freq.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/chardet/__pycache__/gb2312prober.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/chardet/__pycache__/hebrewprober.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/chardet/__pycache__/jisfreq.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/chardet/__pycache__/jpcntx.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/chardet/__pycache__/langbulgarianmodel.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/chardet/__pycache__/langcyrillicmodel.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/chardet/__pycache__/langgreekmodel.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/chardet/__pycache__/langhebrewmodel.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/chardet/__pycache__/langhungarianmodel.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/chardet/__pycache__/langthaimodel.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/chardet/__pycache__/langturkishmodel.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/chardet/__pycache__/latin1prober.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/chardet/__pycache__/mbcharsetprober.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/chardet/__pycache__/mbcsgroupprober.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/chardet/__pycache__/mbcssm.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/chardet/__pycache__/sbcharsetprober.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/chardet/__pycache__/sbcsgroupprober.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/chardet/__pycache__/sjisprober.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/chardet/__pycache__/universaldetector.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/chardet/__pycache__/utf8prober.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/chardet/__pycache__/version.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/chardet/big5freq.py,sha256=D_zK5GyzoVsRes0HkLJziltFQX0bKCLOrFe9_xDvO_8,31254
+pipenv/patched/notpip/_vendor/chardet/big5prober.py,sha256=kBxHbdetBpPe7xrlb-e990iot64g_eGSLd32lB7_h3M,1757
+pipenv/patched/notpip/_vendor/chardet/chardistribution.py,sha256=3woWS62KrGooKyqz4zQSnjFbJpa6V7g02daAibTwcl8,9411
+pipenv/patched/notpip/_vendor/chardet/charsetgroupprober.py,sha256=6bDu8YIiRuScX4ca9Igb0U69TA2PGXXDej6Cc4_9kO4,3787
+pipenv/patched/notpip/_vendor/chardet/charsetprober.py,sha256=KSmwJErjypyj0bRZmC5F5eM7c8YQgLYIjZXintZNstg,5110
+pipenv/patched/notpip/_vendor/chardet/cli/__init__.py,sha256=AbpHGcgLb-kRsJGnwFEktk7uzpZOCcBY74-YBdrKVGs,1
+pipenv/patched/notpip/_vendor/chardet/cli/__pycache__/__init__.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/chardet/cli/__pycache__/chardetect.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/chardet/cli/chardetect.py,sha256=_7UIb7UU_3cml1w6eZe-FojV5N5biJeHCyRN1ogrJyo,2828
+pipenv/patched/notpip/_vendor/chardet/codingstatemachine.py,sha256=VYp_6cyyki5sHgXDSZnXW4q1oelHc3cu9AyQTX7uug8,3590
+pipenv/patched/notpip/_vendor/chardet/compat.py,sha256=PKTzHkSbtbHDqS9PyujMbX74q1a8mMpeQTDVsQhZMRw,1134
+pipenv/patched/notpip/_vendor/chardet/cp949prober.py,sha256=TZ434QX8zzBsnUvL_8wm4AQVTZ2ZkqEEQL_lNw9f9ow,1855
+pipenv/patched/notpip/_vendor/chardet/enums.py,sha256=Aimwdb9as1dJKZaFNUH2OhWIVBVd6ZkJJ_WK5sNY8cU,1661
+pipenv/patched/notpip/_vendor/chardet/escprober.py,sha256=kkyqVg1Yw3DIOAMJ2bdlyQgUFQhuHAW8dUGskToNWSc,3950
+pipenv/patched/notpip/_vendor/chardet/escsm.py,sha256=RuXlgNvTIDarndvllNCk5WZBIpdCxQ0kcd9EAuxUh84,10510
+pipenv/patched/notpip/_vendor/chardet/eucjpprober.py,sha256=iD8Jdp0ISRjgjiVN7f0e8xGeQJ5GM2oeZ1dA8nbSeUw,3749
+pipenv/patched/notpip/_vendor/chardet/euckrfreq.py,sha256=-7GdmvgWez4-eO4SuXpa7tBiDi5vRXQ8WvdFAzVaSfo,13546
+pipenv/patched/notpip/_vendor/chardet/euckrprober.py,sha256=MqFMTQXxW4HbzIpZ9lKDHB3GN8SP4yiHenTmf8g_PxY,1748
+pipenv/patched/notpip/_vendor/chardet/euctwfreq.py,sha256=No1WyduFOgB5VITUA7PLyC5oJRNzRyMbBxaKI1l16MA,31621
+pipenv/patched/notpip/_vendor/chardet/euctwprober.py,sha256=13p6EP4yRaxqnP4iHtxHOJ6R2zxHq1_m8hTRjzVZ95c,1747
+pipenv/patched/notpip/_vendor/chardet/gb2312freq.py,sha256=JX8lsweKLmnCwmk8UHEQsLgkr_rP_kEbvivC4qPOrlc,20715
+pipenv/patched/notpip/_vendor/chardet/gb2312prober.py,sha256=gGvIWi9WhDjE-xQXHvNIyrnLvEbMAYgyUSZ65HUfylw,1754
+pipenv/patched/notpip/_vendor/chardet/hebrewprober.py,sha256=c3SZ-K7hvyzGY6JRAZxJgwJ_sUS9k0WYkvMY00YBYFo,13838
+pipenv/patched/notpip/_vendor/chardet/jisfreq.py,sha256=vpmJv2Bu0J8gnMVRPHMFefTRvo_ha1mryLig8CBwgOg,25777
+pipenv/patched/notpip/_vendor/chardet/jpcntx.py,sha256=PYlNqRUQT8LM3cT5FmHGP0iiscFlTWED92MALvBungo,19643
+pipenv/patched/notpip/_vendor/chardet/langbulgarianmodel.py,sha256=1HqQS9Pbtnj1xQgxitJMvw8X6kKr5OockNCZWfEQrPE,12839
+pipenv/patched/notpip/_vendor/chardet/langcyrillicmodel.py,sha256=LODajvsetH87yYDDQKA2CULXUH87tI223dhfjh9Zx9c,17948
+pipenv/patched/notpip/_vendor/chardet/langgreekmodel.py,sha256=8YAW7bU8YwSJap0kIJSbPMw1BEqzGjWzqcqf0WgUKAA,12688
+pipenv/patched/notpip/_vendor/chardet/langhebrewmodel.py,sha256=JSnqmE5E62tDLTPTvLpQsg5gOMO4PbdWRvV7Avkc0HA,11345
+pipenv/patched/notpip/_vendor/chardet/langhungarianmodel.py,sha256=RhapYSG5l0ZaO-VV4Fan5sW0WRGQqhwBM61yx3yxyOA,12592
+pipenv/patched/notpip/_vendor/chardet/langthaimodel.py,sha256=8l0173Gu_W6G8mxmQOTEF4ls2YdE7FxWf3QkSxEGXJQ,11290
+pipenv/patched/notpip/_vendor/chardet/langturkishmodel.py,sha256=W22eRNJsqI6uWAfwXSKVWWnCerYqrI8dZQTm_M0lRFk,11102
+pipenv/patched/notpip/_vendor/chardet/latin1prober.py,sha256=S2IoORhFk39FEFOlSFWtgVybRiP6h7BlLldHVclNkU8,5370
+pipenv/patched/notpip/_vendor/chardet/mbcharsetprober.py,sha256=AR95eFH9vuqSfvLQZN-L5ijea25NOBCoXqw8s5O9xLQ,3413
+pipenv/patched/notpip/_vendor/chardet/mbcsgroupprober.py,sha256=h6TRnnYq2OxG1WdD5JOyxcdVpn7dG0q-vB8nWr5mbh4,2012
+pipenv/patched/notpip/_vendor/chardet/mbcssm.py,sha256=SY32wVIF3HzcjY3BaEspy9metbNSKxIIB0RKPn7tjpI,25481
+pipenv/patched/notpip/_vendor/chardet/sbcharsetprober.py,sha256=LDSpCldDCFlYwUkGkwD2oFxLlPWIWXT09akH_2PiY74,5657
+pipenv/patched/notpip/_vendor/chardet/sbcsgroupprober.py,sha256=1IprcCB_k1qfmnxGC6MBbxELlKqD3scW6S8YIwdeyXA,3546
+pipenv/patched/notpip/_vendor/chardet/sjisprober.py,sha256=IIt-lZj0WJqK4rmUZzKZP4GJlE8KUEtFYVuY96ek5MQ,3774
+pipenv/patched/notpip/_vendor/chardet/universaldetector.py,sha256=qL0174lSZE442eB21nnktT9_VcAye07laFWUeUrjttY,12485
+pipenv/patched/notpip/_vendor/chardet/utf8prober.py,sha256=IdD8v3zWOsB8OLiyPi-y_fqwipRFxV9Nc1eKBLSuIEw,2766
+pipenv/patched/notpip/_vendor/chardet/version.py,sha256=sp3B08mrDXB-pf3K9fqJ_zeDHOCLC8RrngQyDFap_7g,242
+pipenv/patched/notpip/_vendor/colorama/LICENSE.txt,sha256=ysNcAmhuXQSlpxQL-zs25zrtSWZW6JEQLkKIhteTAxg,1491
+pipenv/patched/notpip/_vendor/colorama/__init__.py,sha256=DqjXH9URVP3IJwmMt7peYw50ns1RNAymIB9-XdPEFV8,239
+pipenv/patched/notpip/_vendor/colorama/__pycache__/__init__.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/colorama/__pycache__/ansi.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/colorama/__pycache__/ansitowin32.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/colorama/__pycache__/initialise.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/colorama/__pycache__/win32.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/colorama/__pycache__/winterm.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/colorama/ansi.py,sha256=Fi0un-QLqRm-v7o_nKiOqyC8PapBJK7DLV_q9LKtTO0,2524
+pipenv/patched/notpip/_vendor/colorama/ansitowin32.py,sha256=u8QaqdqS_xYSfNkPM1eRJLHz6JMWPodaJaP0mxgHCDc,10462
+pipenv/patched/notpip/_vendor/colorama/initialise.py,sha256=PprovDNxMTrvoNHFcL2NZjpH2XzDc8BLxLxiErfUl4k,1915
+pipenv/patched/notpip/_vendor/colorama/win32.py,sha256=bJ8Il9jwaBN5BJ8bmN6FoYZ1QYuMKv2j8fGrXh7TJjw,5404
+pipenv/patched/notpip/_vendor/colorama/winterm.py,sha256=2y_2b7Zsv34feAsP67mLOVc-Bgq51mdYGo571VprlrM,6438
+pipenv/patched/notpip/_vendor/contextlib2.LICENSE.txt,sha256=xqev-sas2tLS3YfS12hDhiSraSYY2x8CvqOxHT85ePA,6054
+pipenv/patched/notpip/_vendor/contextlib2.py,sha256=5HjGflUzwWAUfcILhSmC2GqvoYdZZzFzVfIDztHigUs,16915
+pipenv/patched/notpip/_vendor/distlib/LICENSE.txt,sha256=gI4QyKarjesUn_mz-xn0R6gICUYG1xKpylf-rTVSWZ0,14531
+pipenv/patched/notpip/_vendor/distlib/__init__.py,sha256=gzl1hjUXmDGrqRyU7ZLjBwJGAcMimQbrZ22XPVaKaRE,581
+pipenv/patched/notpip/_vendor/distlib/__pycache__/__init__.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/distlib/__pycache__/compat.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/distlib/__pycache__/database.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/distlib/__pycache__/index.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/distlib/__pycache__/locators.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/distlib/__pycache__/manifest.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/distlib/__pycache__/markers.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/distlib/__pycache__/metadata.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/distlib/__pycache__/resources.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/distlib/__pycache__/scripts.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/distlib/__pycache__/util.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/distlib/__pycache__/version.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/distlib/__pycache__/wheel.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/distlib/_backport/__init__.py,sha256=bqS_dTOH6uW9iGgd0uzfpPjo6vZ4xpPZ7kyfZJ2vNaw,274
+pipenv/patched/notpip/_vendor/distlib/_backport/__pycache__/__init__.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/distlib/_backport/__pycache__/misc.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/distlib/_backport/__pycache__/shutil.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/distlib/_backport/__pycache__/sysconfig.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/distlib/_backport/__pycache__/tarfile.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/distlib/_backport/misc.py,sha256=KWecINdbFNOxSOP1fGF680CJnaC6S4fBRgEtaYTw0ig,971
+pipenv/patched/notpip/_vendor/distlib/_backport/shutil.py,sha256=VW1t3uYqUjWZH7jV-6QiimLhnldoV5uIpH4EuiT1jfw,25647
+pipenv/patched/notpip/_vendor/distlib/_backport/sysconfig.cfg,sha256=swZKxq9RY5e9r3PXCrlvQPMsvOdiWZBTHLEbqS8LJLU,2617
+pipenv/patched/notpip/_vendor/distlib/_backport/sysconfig.py,sha256=BQHFlb6pubCl_dvT1NjtzIthylofjKisox239stDg0U,26854
+pipenv/patched/notpip/_vendor/distlib/_backport/tarfile.py,sha256=Ihp7rXRcjbIKw8COm9wSePV9ARGXbSF9gGXAMn2Q-KU,92628
+pipenv/patched/notpip/_vendor/distlib/compat.py,sha256=xdNZmqFN5HwF30HjRn5M415pcC2kgXRBXn767xS8v-M,41404
+pipenv/patched/notpip/_vendor/distlib/database.py,sha256=fhNzEDtb4HXrpxKyQvhVzDXcOiJlzrOM--UYnvCeZrI,51045
+pipenv/patched/notpip/_vendor/distlib/index.py,sha256=SXKzpQCERctxYDMp_OLee2f0J0e19ZhGdCIoMlUfUQM,21066
+pipenv/patched/notpip/_vendor/distlib/locators.py,sha256=c9E4cDEacJ_uKbuE5BqAVocoWp6rsuBGTkiNDQq3zV4,52100
+pipenv/patched/notpip/_vendor/distlib/manifest.py,sha256=nQEhYmgoreaBZzyFzwYsXxJARu3fo4EkunU163U16iE,14811
+pipenv/patched/notpip/_vendor/distlib/markers.py,sha256=6Ac3cCfFBERexiESWIOXmg-apIP8l2esafNSX3KMy-8,4387
+pipenv/patched/notpip/_vendor/distlib/metadata.py,sha256=OhbCKmf5lswE8unWBopI1hj7tRpHp4ZbFvU4d6aAEMM,40234
+pipenv/patched/notpip/_vendor/distlib/resources.py,sha256=2FGv0ZHF14KXjLIlL0R991lyQQGcewOS4mJ-5n-JVnc,10766
+pipenv/patched/notpip/_vendor/distlib/scripts.py,sha256=OAkEwxRvIzX-VSfhEttQEKJFVLA47gbW0OgQXJRs7OQ,16998
+pipenv/patched/notpip/_vendor/distlib/t32.exe,sha256=NS3xBCVAld35JVFNmb-1QRyVtThukMrwZVeXn4LhaEQ,96768
+pipenv/patched/notpip/_vendor/distlib/t64.exe,sha256=oAqHes78rUWVM0OtVqIhUvequl_PKhAhXYQWnUf7zR0,105984
+pipenv/patched/notpip/_vendor/distlib/util.py,sha256=f2jZCPrcLCt6LcnC0gUy-Fur60tXD8reA7k4rDpHMDw,59845
+pipenv/patched/notpip/_vendor/distlib/version.py,sha256=_n7F6juvQGAcn769E_SHa7fOcf5ERlEVymJ_EjPRwGw,23391
+pipenv/patched/notpip/_vendor/distlib/w32.exe,sha256=lJtnZdeUxTZWya_EW5DZos_K5rswRECGspIl8ZJCIXs,90112
+pipenv/patched/notpip/_vendor/distlib/w64.exe,sha256=0aRzoN2BO9NWW4ENy4_4vHkHR4qZTFZNVSAJJYlODTI,99840
+pipenv/patched/notpip/_vendor/distlib/wheel.py,sha256=bRtR5bNR_u_DwkwktN1bgZuwLVOJT1p_vNIUPyN8kJc,40452
+pipenv/patched/notpip/_vendor/distro.LICENSE,sha256=y16Ofl9KOYjhBjwULGDcLfdWBfTEZRXnduOspt-XbhQ,11325
+pipenv/patched/notpip/_vendor/distro.py,sha256=X2So5kjrRKyMbQJ90Xgy93HU5eFtujCzKaYNeoy1k1c,43251
+pipenv/patched/notpip/_vendor/html5lib/LICENSE,sha256=FqOZkWGekvGGgJMtoqkZn999ld8-yu3FLqBiGKq6_W8,1084
+pipenv/patched/notpip/_vendor/html5lib/__init__.py,sha256=V_balBaI-gbxCbXQB4dRdwjWXv_Y19Nbwz9JoppmiB4,1180
+pipenv/patched/notpip/_vendor/html5lib/__pycache__/__init__.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/html5lib/__pycache__/_ihatexml.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/html5lib/__pycache__/_inputstream.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/html5lib/__pycache__/_tokenizer.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/html5lib/__pycache__/_utils.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/html5lib/__pycache__/constants.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/html5lib/__pycache__/html5parser.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/html5lib/__pycache__/serializer.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/html5lib/_ihatexml.py,sha256=3LBtJMlzgwM8vpQiU1TvGmEEmNH72sV0yD8yS53y07A,16705
+pipenv/patched/notpip/_vendor/html5lib/_inputstream.py,sha256=SXA0AmEBYbMZfWz-D1twCWDiRKX2grL77MgxAiXbwk8,32624
+pipenv/patched/notpip/_vendor/html5lib/_tokenizer.py,sha256=BoXVnGXskTmmQh1xfOTvBxumcOI4XvNIl_gdgrEIk_8,76598
+pipenv/patched/notpip/_vendor/html5lib/_trie/__init__.py,sha256=8VR1bcgD2OpeS2XExpu5yBhP_Q1K-lwKbBKICBPf1kU,289
+pipenv/patched/notpip/_vendor/html5lib/_trie/__pycache__/__init__.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/html5lib/_trie/__pycache__/_base.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/html5lib/_trie/__pycache__/datrie.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/html5lib/_trie/__pycache__/py.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/html5lib/_trie/_base.py,sha256=CaybYyMro8uERQYjby2tTeSUatnWDfWroUN9N7ety5w,1013
+pipenv/patched/notpip/_vendor/html5lib/_trie/datrie.py,sha256=BEEByJj1anI9X-Z2Go-GYxTE4BIukl0XyIA3BtecChs,1196
+pipenv/patched/notpip/_vendor/html5lib/_trie/py.py,sha256=sdgEQ38FTY2cedJNlv6KSFvlN5eRE6Zq6B6509Y3yWI,1793
+pipenv/patched/notpip/_vendor/html5lib/_utils.py,sha256=ughpnZGQhz35yoGlKW-3LqAtSE5n1HRhflYVIc7BgFc,4033
+pipenv/patched/notpip/_vendor/html5lib/constants.py,sha256=4lmZWLtEPRLnl8NzftOoYTJdo6jpeMtP6dqQC0g_bWQ,83518
+pipenv/patched/notpip/_vendor/html5lib/filters/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+pipenv/patched/notpip/_vendor/html5lib/filters/__pycache__/__init__.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/html5lib/filters/__pycache__/alphabeticalattributes.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/html5lib/filters/__pycache__/base.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/html5lib/filters/__pycache__/inject_meta_charset.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/html5lib/filters/__pycache__/lint.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/html5lib/filters/__pycache__/optionaltags.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/html5lib/filters/__pycache__/sanitizer.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/html5lib/filters/__pycache__/whitespace.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/html5lib/filters/alphabeticalattributes.py,sha256=lViZc2JMCclXi_5gduvmdzrRxtO5Xo9ONnbHBVCsykU,919
+pipenv/patched/notpip/_vendor/html5lib/filters/base.py,sha256=z-IU9ZAYjpsVsqmVt7kuWC63jR11hDMr6CVrvuao8W0,286
+pipenv/patched/notpip/_vendor/html5lib/filters/inject_meta_charset.py,sha256=egDXUEHXmAG9504xz0K6ALDgYkvUrC2q15YUVeNlVQg,2945
+pipenv/patched/notpip/_vendor/html5lib/filters/lint.py,sha256=6lyp0XhtjHOZPT2IUDtBOcf69PKc-nUfOea6kgrGkOI,3661
+pipenv/patched/notpip/_vendor/html5lib/filters/optionaltags.py,sha256=8lWT75J0aBOHmPgfmqTHSfPpPMp01T84NKu0CRedxcE,10588
+pipenv/patched/notpip/_vendor/html5lib/filters/sanitizer.py,sha256=LTK0NA47y_MY24ztJwCdJkp2gSoxLpgcsvh5rhflFfQ,26266
+pipenv/patched/notpip/_vendor/html5lib/filters/whitespace.py,sha256=8eWqZxd4UC4zlFGW6iyY6f-2uuT8pOCSALc3IZt7_t4,1214
+pipenv/patched/notpip/_vendor/html5lib/html5parser.py,sha256=0OLY2LrqalhDul74b_fj2si_auT-WNgUqykrrJB5f3E,118981
+pipenv/patched/notpip/_vendor/html5lib/serializer.py,sha256=DrzTX0z70mE-UnOMSFv0C0ybRidG8G2UW5hgkA5Teb8,15776
+pipenv/patched/notpip/_vendor/html5lib/treeadapters/__init__.py,sha256=7iXTX77K9rqv7NGzlRoX8NtCuSl0Sah_5LntSngNxQw,715
+pipenv/patched/notpip/_vendor/html5lib/treeadapters/__pycache__/__init__.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/html5lib/treeadapters/__pycache__/genshi.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/html5lib/treeadapters/__pycache__/sax.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/html5lib/treeadapters/genshi.py,sha256=CH27pAsDKmu4ZGkAUrwty7u0KauGLCZRLPMzaO3M5vo,1715
+pipenv/patched/notpip/_vendor/html5lib/treeadapters/sax.py,sha256=BKS8woQTnKiqeffHsxChUqL4q2ZR_wb5fc9MJ3zQC8s,1776
+pipenv/patched/notpip/_vendor/html5lib/treebuilders/__init__.py,sha256=AysSJyvPfikCMMsTVvaxwkgDieELD5dfR8FJIAuq7hY,3592
+pipenv/patched/notpip/_vendor/html5lib/treebuilders/__pycache__/__init__.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/html5lib/treebuilders/__pycache__/base.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/html5lib/treebuilders/__pycache__/dom.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/html5lib/treebuilders/__pycache__/etree.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/html5lib/treebuilders/__pycache__/etree_lxml.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/html5lib/treebuilders/base.py,sha256=ISFpyqRvDlW1gaduw7SbBUGPVAIom3r0qaVWapKf_aE,14597
+pipenv/patched/notpip/_vendor/html5lib/treebuilders/dom.py,sha256=22whb0C71zXIsai5mamg6qzBEiigcBIvaDy4Asw3at0,8925
+pipenv/patched/notpip/_vendor/html5lib/treebuilders/etree.py,sha256=0a4Tc5jOQkEJMJag9zLJDQOQTBD0vPdJJRBOOqmm8y8,12782
+pipenv/patched/notpip/_vendor/html5lib/treebuilders/etree_lxml.py,sha256=9V0dXxbJYYq-Skgb5-_OL2NkVYpjioEb4CHajo0e9yI,14122
+pipenv/patched/notpip/_vendor/html5lib/treewalkers/__init__.py,sha256=yhXxHpjlSqfQyUag3v8-vWjMPriFBU8YRAPNpDgBTn8,5714
+pipenv/patched/notpip/_vendor/html5lib/treewalkers/__pycache__/__init__.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/html5lib/treewalkers/__pycache__/base.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/html5lib/treewalkers/__pycache__/dom.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/html5lib/treewalkers/__pycache__/etree.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/html5lib/treewalkers/__pycache__/etree_lxml.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/html5lib/treewalkers/__pycache__/genshi.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/html5lib/treewalkers/base.py,sha256=ouiOsuSzvI0KgzdWP8PlxIaSNs9falhbiinAEc_UIJY,7476
+pipenv/patched/notpip/_vendor/html5lib/treewalkers/dom.py,sha256=EHyFR8D8lYNnyDU9lx_IKigVJRyecUGua0mOi7HBukc,1413
+pipenv/patched/notpip/_vendor/html5lib/treewalkers/etree.py,sha256=UvMenhfrPts80JWBCzdF1YkW7Enns6lvYwdxRJzzD28,4568
+pipenv/patched/notpip/_vendor/html5lib/treewalkers/etree_lxml.py,sha256=Q1UQ4USJRcQo13PMFK1p5m8tUCVWu71cOhHGg4F9zwg,6327
+pipenv/patched/notpip/_vendor/html5lib/treewalkers/genshi.py,sha256=4D2PECZ5n3ZN3qu3jMl9yY7B81jnQApBQSVlfaIuYbA,2309
+pipenv/patched/notpip/_vendor/idna/LICENSE.rst,sha256=DUvHq9SNz7FOJCVO5AQGZzf_AWcUTiIpFKIRO4eUaD4,3947
+pipenv/patched/notpip/_vendor/idna/__init__.py,sha256=9Nt7xpyet3DmOrPUGooDdAwmHZZu1qUAy2EaJ93kGiQ,58
+pipenv/patched/notpip/_vendor/idna/__pycache__/__init__.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/idna/__pycache__/codec.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/idna/__pycache__/compat.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/idna/__pycache__/core.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/idna/__pycache__/idnadata.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/idna/__pycache__/intranges.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/idna/__pycache__/package_data.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/idna/__pycache__/uts46data.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/idna/codec.py,sha256=lvYb7yu7PhAqFaAIAdWcwgaWI2UmgseUua-1c0AsG0A,3299
+pipenv/patched/notpip/_vendor/idna/compat.py,sha256=R-h29D-6mrnJzbXxymrWUW7iZUvy-26TQwZ0ij57i4U,232
+pipenv/patched/notpip/_vendor/idna/core.py,sha256=JDCZZ_PLESqIgEbU8mPyoEufWwoOiIqygA17-QZIe3s,11733
+pipenv/patched/notpip/_vendor/idna/idnadata.py,sha256=HXaPFw6_YAJ0qppACPu0YLAULtRs3QovRM_CCZHGdY0,40899
+pipenv/patched/notpip/_vendor/idna/intranges.py,sha256=TY1lpxZIQWEP6tNqjZkFA5hgoMWOj1OBmnUG8ihT87E,1749
+pipenv/patched/notpip/_vendor/idna/package_data.py,sha256=kIzeKKXEouXLR4srqwf9Q3zv-NffKSOz5aSDOJARPB0,21
+pipenv/patched/notpip/_vendor/idna/uts46data.py,sha256=oLyNZ1pBaiBlj9zFzLFRd_P7J8MkRcgDisjExZR_4MY,198292
+pipenv/patched/notpip/_vendor/ipaddress.LICENSE,sha256=OGdUGetKeexhY5bXDxJUs6Qz-3CI-z9MybbAvNzsYWI,2573
+pipenv/patched/notpip/_vendor/ipaddress.py,sha256=-0RmurI31XgAaN20WCi0zrcuoat90nNA70_6yGlx2PU,79875
+pipenv/patched/notpip/_vendor/msgpack/COPYING,sha256=SS3tuoXaWHL3jmCRvNH-pHTWYNNay03ulkuKqz8AdCc,614
+pipenv/patched/notpip/_vendor/msgpack/__init__.py,sha256=LnKzG5v0RyZgs7KlY2-SZYDBn-toylovXxKiXR6C-IQ,1535
+pipenv/patched/notpip/_vendor/msgpack/__pycache__/__init__.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/msgpack/__pycache__/_version.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/msgpack/__pycache__/exceptions.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/msgpack/__pycache__/fallback.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/msgpack/_version.py,sha256=72BxB5FMl1q3Nz1hteHINzHhrFpXQ9nNtULaK52NLk8,20
+pipenv/patched/notpip/_vendor/msgpack/exceptions.py,sha256=dCTWei8dpkrMsQDcjQk74ATl9HsIBH0ybt8zOPNqMYc,1081
+pipenv/patched/notpip/_vendor/msgpack/fallback.py,sha256=vXo6S67Dmil9mz0PRBCLDu6znpv6CGKt9WPCEsdZx2A,37454
+pipenv/patched/notpip/_vendor/packaging/LICENSE,sha256=ytHvW9NA1z4HS6YU0m996spceUDD2MNIUuZcSQlobEg,197
+pipenv/patched/notpip/_vendor/packaging/LICENSE.APACHE,sha256=DOwG4OVfvD3FzuT8qbYH9my49OTbzzs8ATWU3RVnMuk,10173
+pipenv/patched/notpip/_vendor/packaging/LICENSE.BSD,sha256=tw5-m3QvHMb5SLNMFqo5_-zpQZY2S8iP8NIYDwAo-sU,1344
+pipenv/patched/notpip/_vendor/packaging/__about__.py,sha256=G5P2sPs0QxgVqD0zzcSjVLfY31ni6HVUh9ZWlHSAG3M,744
+pipenv/patched/notpip/_vendor/packaging/__init__.py,sha256=6enbp5XgRfjBjsI9-bn00HjHf5TH21PDMOKkJW8xw-w,562
+pipenv/patched/notpip/_vendor/packaging/__pycache__/__about__.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/packaging/__pycache__/__init__.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/packaging/__pycache__/_compat.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/packaging/__pycache__/_structures.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/packaging/__pycache__/_typing.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/packaging/__pycache__/markers.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/packaging/__pycache__/requirements.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/packaging/__pycache__/specifiers.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/packaging/__pycache__/tags.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/packaging/__pycache__/utils.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/packaging/__pycache__/version.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/packaging/_compat.py,sha256=Z-PwchK0cREbaRGF5MZP8LEv8JkC-qydn2FRrtjeixk,1138
+pipenv/patched/notpip/_vendor/packaging/_structures.py,sha256=ozkCX8Q8f2qE1Eic3YiQ4buDVfgz2iYevY9e7R2y3iY,2022
+pipenv/patched/notpip/_vendor/packaging/_typing.py,sha256=8i-5mVy3D7GNuvLGhocHBENZ3wb0-RxAX3U78JskN-8,1467
+pipenv/patched/notpip/_vendor/packaging/markers.py,sha256=ziUAFHx0Qg1bTv1Mb4E29Y2tBjbt0eSGeJsaYOKs95c,9555
+pipenv/patched/notpip/_vendor/packaging/requirements.py,sha256=T5dq6ZFQxa3OVoU9ig9pjMIVULau72nj0GZT_wbYGts,4985
+pipenv/patched/notpip/_vendor/packaging/specifiers.py,sha256=Nz8bnFp53cQInmRGZy50QXlIi2tkDXMfRuGyGps2IRE,31314
+pipenv/patched/notpip/_vendor/packaging/tags.py,sha256=lJ_91F0icMlFvMp7EiKWPSzgJclNsEYdjdErhryfGj4,23510
+pipenv/patched/notpip/_vendor/packaging/utils.py,sha256=v5Wk8B7gUL13Rzed6NNhCZlutPQT7jNV-7hr-WOtacU,1700
+pipenv/patched/notpip/_vendor/packaging/version.py,sha256=qRdNN0_XuPFOJ3fut8ehzxJrNYtBzqF8ZtagEvgNUUM,15480
+pipenv/patched/notpip/_vendor/pep517/LICENSE,sha256=GyKwSbUmfW38I6Z79KhNjsBLn9-xpR02DkK0NCyLQVQ,1081
+pipenv/patched/notpip/_vendor/pep517/__init__.py,sha256=nCw8ZdLH4c19g8xP_Ndag1KPdQhlSDKaL9pg-X7uNWU,84
+pipenv/patched/notpip/_vendor/pep517/__pycache__/__init__.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/pep517/__pycache__/_in_process.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/pep517/__pycache__/build.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/pep517/__pycache__/check.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/pep517/__pycache__/colorlog.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/pep517/__pycache__/compat.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/pep517/__pycache__/dirtools.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/pep517/__pycache__/envbuild.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/pep517/__pycache__/meta.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/pep517/__pycache__/wrappers.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/pep517/_in_process.py,sha256=v1Viek27-MGCOFu8eSlLd2jGCrIqc1fISnutGFoRDps,7792
+pipenv/patched/notpip/_vendor/pep517/build.py,sha256=WqM0-X4KyzY566qxGf3FeaYc1hw95H7YP0ElZ1zuTb0,3318
+pipenv/patched/notpip/_vendor/pep517/check.py,sha256=ST02kRWBrRMOxgnRm9clw18Q2X7sJGaD4j3h6GmBhJ8,5949
+pipenv/patched/notpip/_vendor/pep517/colorlog.py,sha256=Tk9AuYm_cLF3BKTBoSTJt9bRryn0aFojIQOwbfVUTxQ,4098
+pipenv/patched/notpip/_vendor/pep517/compat.py,sha256=M-5s4VNp8rjyT76ZZ_ibnPD44DYVzSQlyCEHayjtDPw,780
+pipenv/patched/notpip/_vendor/pep517/dirtools.py,sha256=2mkAkAL0mRz_elYFjRKuekTJVipH1zTn4tbf1EDev84,1129
+pipenv/patched/notpip/_vendor/pep517/envbuild.py,sha256=K4dIGAbkXf3RoQX_9RFpZvMvPrVSHtcbH7o9VSrNnlM,6024
+pipenv/patched/notpip/_vendor/pep517/meta.py,sha256=8mnM5lDnT4zXQpBTliJbRGfesH7iioHwozbDxALPS9Y,2463
+pipenv/patched/notpip/_vendor/pep517/wrappers.py,sha256=QiQaEQlfCrhRpPBFQiGVM9QjrKSlj8AvM39haoyfPRk,10599
+pipenv/patched/notpip/_vendor/pkg_resources/LICENSE,sha256=wyo6w5WvYyHv0ovnPQagDw22q4h9HCHU_sRhKNIFbVo,1078
+pipenv/patched/notpip/_vendor/pkg_resources/__init__.py,sha256=9pR3Cs4ibgkAi2gARhF1Q2W_h_AKPUdGWj-_KINK98Y,108421
+pipenv/patched/notpip/_vendor/pkg_resources/__pycache__/__init__.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/pkg_resources/__pycache__/py31compat.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/pkg_resources/py31compat.py,sha256=wp0zCCkc2s-ZVbgUKHDdf-drJ-9nDvC1ADuMLFL_KNE,580
+pipenv/patched/notpip/_vendor/progress/LICENSE,sha256=caE0lsYh8BtFT5qlT6YIpxL1jrJT5t0skQJ_54NAx3M,776
+pipenv/patched/notpip/_vendor/progress/__init__.py,sha256=fcbQQXo5np2CoQyhSH5XprkicwLZNLePR3uIahznSO0,4857
+pipenv/patched/notpip/_vendor/progress/__pycache__/__init__.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/progress/__pycache__/bar.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/progress/__pycache__/counter.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/progress/__pycache__/spinner.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/progress/bar.py,sha256=QuDuVNcmXgpxtNtxO0Fq72xKigxABaVmxYGBw4J3Z_E,2854
+pipenv/patched/notpip/_vendor/progress/counter.py,sha256=MznyBrvPWrOlGe4MZAlGUb9q3aODe6_aNYeAE_VNoYA,1372
+pipenv/patched/notpip/_vendor/progress/spinner.py,sha256=k8JbDW94T0-WXuXfxZIFhdoNPYp3jfnpXqBnfRv5fGs,1380
+pipenv/patched/notpip/_vendor/pyparsing.LICENSE,sha256=ENUSChaAWAT_2otojCIL-06POXQbVzIGBNRVowngGXI,1023
+pipenv/patched/notpip/_vendor/pyparsing.py,sha256=fxi1NTmXKl5XWoFUWtjdvm9dAkXgPHug1mDCC696mhY,272465
+pipenv/patched/notpip/_vendor/pytoml/LICENSE,sha256=N9iX9ipDJNjS8xPX0bmM0m-HLSrlmLfrmmmxwSm8wTU,881
+pipenv/patched/notpip/_vendor/pytoml/__init__.py,sha256=W_SKx36Hsew-Fty36BOpreLm4uF4V_Tgkm_z9rIoOE8,127
+pipenv/patched/notpip/_vendor/pytoml/__pycache__/__init__.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/pytoml/__pycache__/core.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/pytoml/__pycache__/parser.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/pytoml/__pycache__/test.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/pytoml/__pycache__/utils.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/pytoml/__pycache__/writer.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/pytoml/core.py,sha256=9CrLLTs1PdWjEwRnYzt_i4dhHcZvGxs_GsMlYAX3iY4,509
+pipenv/patched/notpip/_vendor/pytoml/parser.py,sha256=qsc0NRnTgdFZgRp9gmr6D_KWFelrwxLkTj9dVxUcqS8,10309
+pipenv/patched/notpip/_vendor/pytoml/test.py,sha256=2nQs4aX3XQEaaQCx6x_OJTS2Hb0_IiTZRqNOeDmLCzo,1021
+pipenv/patched/notpip/_vendor/pytoml/utils.py,sha256=JCLHx77Hu1R3F-bRgiROIiKyCzLwyebnp5P35cRJxWs,1665
+pipenv/patched/notpip/_vendor/pytoml/writer.py,sha256=4QQky9JSuRv60uzuhVZASU8T3CuobSkLG1285X6bDW8,3369
+pipenv/patched/notpip/_vendor/requests/LICENSE,sha256=vkGrrCxA-FMDB-jRcsWQtHb0pIi8amj43le3z2R4Zoc,582
+pipenv/patched/notpip/_vendor/requests/__init__.py,sha256=IeA4V3MQlWFt_ihmZiiYcTUb6L6W3yQS6nVAhomaQfI,4164
+pipenv/patched/notpip/_vendor/requests/__pycache__/__init__.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/requests/__pycache__/__version__.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/requests/__pycache__/_internal_utils.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/requests/__pycache__/adapters.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/requests/__pycache__/api.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/requests/__pycache__/auth.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/requests/__pycache__/certs.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/requests/__pycache__/compat.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/requests/__pycache__/cookies.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/requests/__pycache__/exceptions.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/requests/__pycache__/help.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/requests/__pycache__/hooks.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/requests/__pycache__/models.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/requests/__pycache__/packages.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/requests/__pycache__/sessions.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/requests/__pycache__/status_codes.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/requests/__pycache__/structures.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/requests/__pycache__/utils.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/requests/__version__.py,sha256=Bm-GFstQaFezsFlnmEMrJDe8JNROz9n2XXYtODdvjjc,436
+pipenv/patched/notpip/_vendor/requests/_internal_utils.py,sha256=Zx3PnEUccyfsB-ie11nZVAW8qClJy0gx1qNME7rgT18,1096
+pipenv/patched/notpip/_vendor/requests/adapters.py,sha256=784tV4BIhyS8p0rjgrQEsPV8QcNufI1jApPMjV5TuBE,21854
+pipenv/patched/notpip/_vendor/requests/api.py,sha256=fbUo11QoLOoNgWU6FfvNz8vMj9bE_cMmICXBa7TZHJs,6271
+pipenv/patched/notpip/_vendor/requests/auth.py,sha256=QB2-cSUj1jrvWZfPXttsZpyAacQgtKLVk14vQW9TpSE,10206
+pipenv/patched/notpip/_vendor/requests/certs.py,sha256=M5EbuLGpCcWnkjfVAgtY6beQ4JEYO6iS_EfFoQECffs,483
+pipenv/patched/notpip/_vendor/requests/compat.py,sha256=OnBKIe7F7Mtlgh8V-l3oNYoZTKh_zdmZVue6UvZ0s_4,1959
+pipenv/patched/notpip/_vendor/requests/cookies.py,sha256=Y-bKX6TvW3FnYlE6Au0SXtVVWcaNdFvuAwQxw-G0iTI,18430
+pipenv/patched/notpip/_vendor/requests/exceptions.py,sha256=bZUOWTCEZNiSf4pIZN0TcR_NQtY4wGVxSbWALGoV3pA,3215
+pipenv/patched/notpip/_vendor/requests/help.py,sha256=OjfmCAvhSL-Agt9LAHPJfoNd59pf7vY5CrughB-YXfk,3650
+pipenv/patched/notpip/_vendor/requests/hooks.py,sha256=QReGyy0bRcr5rkwCuObNakbYsc7EkiKeBwG4qHekr2Q,757
+pipenv/patched/notpip/_vendor/requests/models.py,sha256=o8RAmrl34XSwPicf-4pqbhVkRXSABuHEgZBF5Mp_haY,34365
+pipenv/patched/notpip/_vendor/requests/packages.py,sha256=KwTU_xWlvSRrrQ0MUTreQj4rkW5mbd6s4Uw5UANS4kE,749
+pipenv/patched/notpip/_vendor/requests/sessions.py,sha256=DjbCotDW6xSAaBsjbW-L8l4N0UcwmrxVNgSrZgIjGWM,29332
+pipenv/patched/notpip/_vendor/requests/status_codes.py,sha256=XWlcpBjbCtq9sSqpH9_KKxgnLTf9Z__wCWolq21ySlg,4129
+pipenv/patched/notpip/_vendor/requests/structures.py,sha256=zoP8qly2Jak5e89HwpqjN1z2diztI-_gaqts1raJJBc,2981
+pipenv/patched/notpip/_vendor/requests/utils.py,sha256=LtPJ1db6mJff2TJSJWKi7rBpzjPS3mSOrjC9zRhoD3A,30049
+pipenv/patched/notpip/_vendor/retrying.LICENSE,sha256=WNHhf_5RCaeuKWyq_K39vmp9F28LxKsB4SpomwSZ2L0,11357
+pipenv/patched/notpip/_vendor/retrying.py,sha256=JH47o2VAVxQh7xlewz563cYEJdkQ6HNWdRtbbHM9Nvo,9990
+pipenv/patched/notpip/_vendor/six.LICENSE,sha256=5zL1TaWPPpzwxI6LUSlIk2_Pc2G9WK-mOpo8OSv3lK0,1066
+pipenv/patched/notpip/_vendor/six.py,sha256=Q6WvEXZ1DGEASAo3CGNCJkKv2tPy8xkSmK-VHE9PYIA,34074
+pipenv/patched/notpip/_vendor/urllib3/LICENSE.txt,sha256=fA0TbuBYU4mt8tJWcbuZaHofdZKfRlt_Fu4_Ado3JV4,1115
+pipenv/patched/notpip/_vendor/urllib3/__init__.py,sha256=--dxP-3k5qC8gGCQJbU_jJK666_rbCduadrwRB25wZg,2683
+pipenv/patched/notpip/_vendor/urllib3/__pycache__/__init__.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/urllib3/__pycache__/_collections.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/urllib3/__pycache__/connection.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/urllib3/__pycache__/connectionpool.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/urllib3/__pycache__/exceptions.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/urllib3/__pycache__/fields.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/urllib3/__pycache__/filepost.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/urllib3/__pycache__/poolmanager.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/urllib3/__pycache__/request.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/urllib3/__pycache__/response.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/urllib3/_collections.py,sha256=GouVsNzwg6jADZTmimMI6oqmwKSswnMo9dh5tGNVWO4,10792
+pipenv/patched/notpip/_vendor/urllib3/connection.py,sha256=JaGozqRdvNogTwHDGxbp2N3Hi2MtJQrkbr7b5qcBGXk,15168
+pipenv/patched/notpip/_vendor/urllib3/connectionpool.py,sha256=2RPMZJU_PhkAbY1tvy3-W_9os4Kdk_XXu8Zi6YSCgSU,36488
+pipenv/patched/notpip/_vendor/urllib3/contrib/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+pipenv/patched/notpip/_vendor/urllib3/contrib/__pycache__/__init__.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/urllib3/contrib/__pycache__/_appengine_environ.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/urllib3/contrib/__pycache__/appengine.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/urllib3/contrib/__pycache__/ntlmpool.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/urllib3/contrib/__pycache__/pyopenssl.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/urllib3/contrib/__pycache__/securetransport.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/urllib3/contrib/__pycache__/socks.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/urllib3/contrib/_appengine_environ.py,sha256=PCxFG7RoB-AOkIWQWGBIg1yZnK0dwPxWcNx7BTpZFBI,909
+pipenv/patched/notpip/_vendor/urllib3/contrib/_securetransport/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+pipenv/patched/notpip/_vendor/urllib3/contrib/_securetransport/__pycache__/__init__.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/urllib3/contrib/_securetransport/__pycache__/bindings.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/urllib3/contrib/_securetransport/__pycache__/low_level.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/urllib3/contrib/_securetransport/bindings.py,sha256=mullWYFaghBdRWla6HYU-TBgFRTPLBEfxj3jplbeJmQ,16886
+pipenv/patched/notpip/_vendor/urllib3/contrib/_securetransport/low_level.py,sha256=V7GnujxnWZh2N2sMsV5N4d9Imymokkm3zBwgt77_bSE,11956
+pipenv/patched/notpip/_vendor/urllib3/contrib/appengine.py,sha256=tb6VKABm7kvlM0EwHhyRgm8Pc-Eem0LrdUYKA-7Bwds,11070
+pipenv/patched/notpip/_vendor/urllib3/contrib/ntlmpool.py,sha256=a402AwGN_Ll3N-4ur_AS6UrU-ycUtlnYqoBF76lORg8,4160
+pipenv/patched/notpip/_vendor/urllib3/contrib/pyopenssl.py,sha256=3PzldauwyhueC_Rr0Ajp0sagy9ojZIj67Bpuj8Xkgbk,16458
+pipenv/patched/notpip/_vendor/urllib3/contrib/securetransport.py,sha256=iKzVUAxKnChsADR5YMwc05oEixXDzAk0xPU0g-rc2z8,32275
+pipenv/patched/notpip/_vendor/urllib3/contrib/socks.py,sha256=nzDMgDIFJWVubKHqvIn2-SKCO91hhJInP92WgHChGzA,7036
+pipenv/patched/notpip/_vendor/urllib3/exceptions.py,sha256=P3e-p9_LScyIxX7FoR3wU0A6hZmDqFAVCz2wgI3D0lM,6607
+pipenv/patched/notpip/_vendor/urllib3/fields.py,sha256=kroD76QK-GdHHW7f_AUN4XxDC3OQPI2FFrS9eSL4BCs,8553
+pipenv/patched/notpip/_vendor/urllib3/filepost.py,sha256=vj0qbrpT1AFzvvW4SuC8M5kJiw7wftHcSr-7b8UpPpw,2440
+pipenv/patched/notpip/_vendor/urllib3/packages/__init__.py,sha256=h4BLhD4tLaBx1adaDtKXfupsgqY0wWLXb_f1_yVlV6A,108
+pipenv/patched/notpip/_vendor/urllib3/packages/__pycache__/__init__.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/urllib3/packages/__pycache__/six.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/urllib3/packages/backports/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+pipenv/patched/notpip/_vendor/urllib3/packages/backports/__pycache__/__init__.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/urllib3/packages/backports/__pycache__/makefile.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/urllib3/packages/backports/makefile.py,sha256=005wrvH-_pWSnTFqQ2sdzzh4zVCtQUUQ4mR2Yyxwc0A,1418
+pipenv/patched/notpip/_vendor/urllib3/packages/six.py,sha256=adx4z-eM_D0Vvu0IIqVzFACQ_ux9l64y7DkSEfbxCDs,32536
+pipenv/patched/notpip/_vendor/urllib3/packages/ssl_match_hostname/__init__.py,sha256=ywgKMtfHi1-DrXlzPfVAhzsLzzqcK7GT6eLgdode1Fg,688
+pipenv/patched/notpip/_vendor/urllib3/packages/ssl_match_hostname/__pycache__/__init__.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/urllib3/packages/ssl_match_hostname/__pycache__/_implementation.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/urllib3/packages/ssl_match_hostname/_implementation.py,sha256=ztZ6tNnSHhlkfX2pJXDMcTZxj3_I5AzVFnB2bRPgNmA,5714
+pipenv/patched/notpip/_vendor/urllib3/poolmanager.py,sha256=JYUyBUN3IiEknUdjZ7VJrpCQr6SP7vi0WwSndrn8XpE,17053
+pipenv/patched/notpip/_vendor/urllib3/request.py,sha256=hhoHvEEatyd9Tn5EbGjQ0emn-ENMCyY591yNWTneINA,6018
+pipenv/patched/notpip/_vendor/urllib3/response.py,sha256=O2DVzBeWOzyxZDZ8k0EDFU3GW1jWXk_b03mS0O1ybxs,27836
+pipenv/patched/notpip/_vendor/urllib3/util/__init__.py,sha256=bWNaav_OT-1L7-sxm59cGb59rDORlbhb_4noduM5m0U,1038
+pipenv/patched/notpip/_vendor/urllib3/util/__pycache__/__init__.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/urllib3/util/__pycache__/connection.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/urllib3/util/__pycache__/queue.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/urllib3/util/__pycache__/request.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/urllib3/util/__pycache__/response.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/urllib3/util/__pycache__/retry.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/urllib3/util/__pycache__/ssl_.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/urllib3/util/__pycache__/timeout.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/urllib3/util/__pycache__/url.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/urllib3/util/__pycache__/wait.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/urllib3/util/connection.py,sha256=NsxUAKQ98GKywta--zg57CdVpeTCI6N-GElCq78Dl8U,4637
+pipenv/patched/notpip/_vendor/urllib3/util/queue.py,sha256=myTX3JDHntglKQNBf3b6dasHH-uF-W59vzGSQiFdAfI,497
+pipenv/patched/notpip/_vendor/urllib3/util/request.py,sha256=C-6-AWffxZG03AdRGoY59uqsn4CVItKU6gjxz7Hc3Mc,3815
+pipenv/patched/notpip/_vendor/urllib3/util/response.py,sha256=_WbTQr8xRQuJuY2rTIZxVdJD6mnEOtQupjaK_bF_Vj8,2573
+pipenv/patched/notpip/_vendor/urllib3/util/retry.py,sha256=Ui74h44gLIIWkAxT9SK3A2mEvu55-odWgJMw3LiUNGk,15450
+pipenv/patched/notpip/_vendor/urllib3/util/ssl_.py,sha256=XdXQTZAzoXvMoypc2NLtr7iaextooWQEO5JwCMQsALU,14181
+pipenv/patched/notpip/_vendor/urllib3/util/timeout.py,sha256=bCtaS_xVKaTDJ5VMlroXBfCnPUDNVGZqik7-z83issg,9871
+pipenv/patched/notpip/_vendor/urllib3/util/url.py,sha256=3WbmMS2bvnIfZng0ohbfN6d6Vgu-LXKzsPar0Ja51Pw,14131
+pipenv/patched/notpip/_vendor/urllib3/util/wait.py,sha256=k46KzqIYu3Vnzla5YW3EvtInNlU_QycFqQAghIOxoAg,5406
+pipenv/patched/notpip/_vendor/vendor.txt,sha256=svVMQpSngTtwHn9X8cJPy3e5-4w6E-i46IawdPVZYvw,421
+pipenv/patched/notpip/_vendor/webencodings/LICENSE,sha256=8juuatp2CVYQp3E3-5KuxzQnI5ACEcWCbVS0xXkHylY,1490
+pipenv/patched/notpip/_vendor/webencodings/__init__.py,sha256=qOBJIuPy_4ByYH6W_bNgJF-qYQ2DoU-dKsDu5yRWCXg,10579
+pipenv/patched/notpip/_vendor/webencodings/__pycache__/__init__.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/webencodings/__pycache__/labels.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/webencodings/__pycache__/mklabels.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/webencodings/__pycache__/tests.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/webencodings/__pycache__/x_user_defined.cpython-37.pyc,,
+pipenv/patched/notpip/_vendor/webencodings/labels.py,sha256=4AO_KxTddqGtrL9ns7kAPjb0CcN6xsCIxbK37HY9r3E,8979
+pipenv/patched/notpip/_vendor/webencodings/mklabels.py,sha256=GYIeywnpaLnP0GSic8LFWgd0UVvO_l1Nc6YoF-87R_4,1305
+pipenv/patched/notpip/_vendor/webencodings/tests.py,sha256=OtGLyjhNY1fvkW1GvLJ_FV9ZoqC9Anyjr7q3kxTbzNs,6563
+pipenv/patched/notpip/_vendor/webencodings/x_user_defined.py,sha256=yOqWSdmpytGfUgh_Z6JYgDNhoc-BAHyyeeT15Fr42tM,4307
+pipenv/patched/patched.txt,sha256=3oqSKlcAgQe4NtN7OUwqK-cJHZRg8_DZJqiEURSAHVs,73
+pipenv/patched/pipfile/LICENSE,sha256=ytHvW9NA1z4HS6YU0m996spceUDD2MNIUuZcSQlobEg,197
+pipenv/patched/pipfile/LICENSE.APACHE,sha256=DOwG4OVfvD3FzuT8qbYH9my49OTbzzs8ATWU3RVnMuk,10173
+pipenv/patched/pipfile/LICENSE.BSD,sha256=YKka7CoWnamorF3G0Y170_XUJKUwPJQJnXNJkJUBRt4,1344
+pipenv/patched/pipfile/__about__.py,sha256=AckjwSoMHtVG2bKBozTe8w7JgUS-SBC1EXOfXS58UhM,681
+pipenv/patched/pipfile/__init__.py,sha256=ZpV2QSnVpmG9j9vQH3lSdcnA9PSjRZym_MomP5Lh7wY,409
+pipenv/patched/pipfile/__pycache__/__about__.cpython-37.pyc,,
+pipenv/patched/pipfile/__pycache__/__init__.cpython-37.pyc,,
+pipenv/patched/pipfile/__pycache__/api.cpython-37.pyc,,
+pipenv/patched/pipfile/api.py,sha256=9uQeU8cI2XKsmOPdGdrEPX47myrQ1GGj8cTG_PF0uHI,6685
+pipenv/patched/piptools/LICENSE,sha256=3a_52MBuKjuNIlTVi9c-oEzjQZfYDMMrCXlIXgZmX5o,1500
+pipenv/patched/piptools/__init__.py,sha256=8thn-dOvLOIMk8yl333hqovhg76G31sLazxfZ01E3NQ,379
+pipenv/patched/piptools/__main__.py,sha256=AyR6tAMb4vvaRLpmGIOAraTVt-XRdy3J3A2TcU_D_tM,267
+pipenv/patched/piptools/__pycache__/__init__.cpython-37.pyc,,
+pipenv/patched/piptools/__pycache__/__main__.cpython-37.pyc,,
+pipenv/patched/piptools/__pycache__/cache.cpython-37.pyc,,
+pipenv/patched/piptools/__pycache__/click.cpython-37.pyc,,
+pipenv/patched/piptools/__pycache__/exceptions.cpython-37.pyc,,
+pipenv/patched/piptools/__pycache__/locations.cpython-37.pyc,,
+pipenv/patched/piptools/__pycache__/logging.cpython-37.pyc,,
+pipenv/patched/piptools/__pycache__/resolver.cpython-37.pyc,,
+pipenv/patched/piptools/__pycache__/sync.cpython-37.pyc,,
+pipenv/patched/piptools/__pycache__/utils.cpython-37.pyc,,
+pipenv/patched/piptools/__pycache__/writer.cpython-37.pyc,,
+pipenv/patched/piptools/_compat/__init__.py,sha256=N-wJAfFszrrkP0ca7sysncuP8vMjpuhxWB3xq-e5MB8,824
+pipenv/patched/piptools/_compat/__pycache__/__init__.cpython-37.pyc,,
+pipenv/patched/piptools/_compat/__pycache__/contextlib.cpython-37.pyc,,
+pipenv/patched/piptools/_compat/__pycache__/pip_compat.cpython-37.pyc,,
+pipenv/patched/piptools/_compat/__pycache__/tempfile.cpython-37.pyc,,
+pipenv/patched/piptools/_compat/contextlib.py,sha256=4K3xvf7Ujd_KfUVkXRVLxvyQ2L36072t02Vifc7c6TU,602
+pipenv/patched/piptools/_compat/pip_compat.py,sha256=lXpFmEAIsvC6BCOm6UMqkCTtZWa6wWkTdKy1PFLsY7c,3144
+pipenv/patched/piptools/_compat/tempfile.py,sha256=m5d22eGPL2vFwUi0kp33_Tr9UQg1QBQnQ1LJ04HlAzI,2862
+pipenv/patched/piptools/cache.py,sha256=7EVbkSchs6ZzG12pFNT2xNYwxn96QMywbbA0OZgkMi4,5645
+pipenv/patched/piptools/click.py,sha256=6G25l-dJ7Bx7KqI9EOr86rHfN_r-1x_Ums1uMY7BM-8,128
+pipenv/patched/piptools/exceptions.py,sha256=ygS7CIMlMnKGwfPD_3-rB7zfmAdWIxQvJLnGFv83XzY,1907
+pipenv/patched/piptools/locations.py,sha256=Ymmzu-1aN5YoHMBrWwAlu18FVmF1EM3vSzMGUNPhNqI,867
+pipenv/patched/piptools/logging.py,sha256=rZH1GUxRfwfuQ-a78s07oZBzyuFH_3o_xUYWT_78CR0,919
+pipenv/patched/piptools/repositories/__init__.py,sha256=AuVddJd2QqAuTgmmF4JEm1JZ8O7BS9oFMnRmzVOSBxc,95
+pipenv/patched/piptools/repositories/__pycache__/__init__.cpython-37.pyc,,
+pipenv/patched/piptools/repositories/__pycache__/base.cpython-37.pyc,,
+pipenv/patched/piptools/repositories/__pycache__/local.cpython-37.pyc,,
+pipenv/patched/piptools/repositories/__pycache__/pypi.cpython-37.pyc,,
+pipenv/patched/piptools/repositories/base.py,sha256=_hZAJVM56o5eUEJ3z0gXNrzz8D-nRhNcIyi3-v0I640,1474
+pipenv/patched/piptools/repositories/local.py,sha256=tgBIRmiX15UoodyUZcSoql1HAAaVn-1axtL-7QfOCI4,3138
+pipenv/patched/piptools/repositories/pypi.py,sha256=yajt-Ra3f8Q0b8YsUxF2t5urUM_5WyJ6i3NY16U8FNk,17846
+pipenv/patched/piptools/resolver.py,sha256=wtHQoEWeeYkXSHV8angM-c5RP3uzoojr9ApFMuQ8hhg,15795
+pipenv/patched/piptools/scripts/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+pipenv/patched/piptools/scripts/__pycache__/__init__.cpython-37.pyc,,
+pipenv/patched/piptools/scripts/__pycache__/compile.cpython-37.pyc,,
+pipenv/patched/piptools/scripts/__pycache__/sync.cpython-37.pyc,,
+pipenv/patched/piptools/scripts/compile.py,sha256=BZbpWP_b9kV0nr9_FprlT0QSOUScZp9L559NnOpjfeE,13180
+pipenv/patched/piptools/scripts/sync.py,sha256=1prL-GWhlcbbtBxlrTWBOBnVxTh7QHsZBV-d55owKJ8,6267
+pipenv/patched/piptools/sync.py,sha256=PSzJHhw383y7jB_POxuOm6jDKuRF19AMwBYXICjhC7E,6920
+pipenv/patched/piptools/utils.py,sha256=ZxFvCkq_2yixxffQdPysbkn_x7rFDzkbIiQNSvUuoqY,16075
+pipenv/patched/piptools/writer.py,sha256=cBnCJTKkqm_5wyjJLN94exrzaQHNqmrbALJMH89vXE0,7936
+pipenv/patched/safety/LICENSE,sha256=R4aSZkplb_c618J0ccuHoheFFacWiA8V30CVWVBhCgI,1067
+pipenv/patched/safety/__init__.py,sha256=Bw7PhzUqi1tO8klCPliswqPvHYRN1jx-zn18akAyTbM,104
+pipenv/patched/safety/__main__.py,sha256=gN7as3klvgpnneCVglKIaeKWOC0YSi6ymr-KGTClwrw,1485
+pipenv/patched/safety/__pycache__/__init__.cpython-37.pyc,,
+pipenv/patched/safety/__pycache__/__main__.cpython-37.pyc,,
+pipenv/patched/safety/__pycache__/cli.cpython-37.pyc,,
+pipenv/patched/safety/__pycache__/constants.cpython-37.pyc,,
+pipenv/patched/safety/__pycache__/errors.cpython-37.pyc,,
+pipenv/patched/safety/__pycache__/formatter.cpython-37.pyc,,
+pipenv/patched/safety/__pycache__/safety.cpython-37.pyc,,
+pipenv/patched/safety/__pycache__/util.cpython-37.pyc,,
+pipenv/patched/safety/cli.py,sha256=S45OerT6DHsxntmY2A1cShYl3QwKUCuAkHq_G0m5jiI,5883
+pipenv/patched/safety/constants.py,sha256=fgQlrCvLNBHBUSQs7tRn7WZnSee9NYsporisk9eRUlM,339
+pipenv/patched/safety/errors.py,sha256=EOT38JeM2ug-T7aZMZbzc_d8ve0QncKh4V1ewTEp3ZQ,164
+pipenv/patched/safety/formatter.py,sha256=KwmRtPmkhn5SmN9RzkIWdEnsHpZOyl0hT9-MUdhOOS4,9036
+pipenv/patched/safety/safety.py,sha256=3liPFEUtbumHsnau3ZcbHsyKEbf9LWrkWONRhW6-tPk,5506
+pipenv/patched/safety/util.py,sha256=qRiRTrseONXZKRRw0UkUGJ8TWNdwS5cu8BI2InKYJrQ,3905
+pipenv/patched/yaml2/LICENSE,sha256=xAESRJ8lS5dTBFklJIMT6ScO-jbSJrItgtTMbEPFfyk,1101
+pipenv/patched/yaml2/__init__.py,sha256=P1q3hEAPpfgnSh9EvLYnVF6CyOFBL6DT_hnSqhjtnGU,13340
+pipenv/patched/yaml2/__pycache__/__init__.cpython-37.pyc,,
+pipenv/patched/yaml2/__pycache__/composer.cpython-37.pyc,,
+pipenv/patched/yaml2/__pycache__/cyaml.cpython-37.pyc,,
+pipenv/patched/yaml2/__pycache__/dumper.cpython-37.pyc,,
+pipenv/patched/yaml2/__pycache__/emitter.cpython-37.pyc,,
+pipenv/patched/yaml2/__pycache__/error.cpython-37.pyc,,
+pipenv/patched/yaml2/__pycache__/events.cpython-37.pyc,,
+pipenv/patched/yaml2/__pycache__/loader.cpython-37.pyc,,
+pipenv/patched/yaml2/__pycache__/nodes.cpython-37.pyc,,
+pipenv/patched/yaml2/__pycache__/parser.cpython-37.pyc,,
+pipenv/patched/yaml2/__pycache__/representer.cpython-37.pyc,,
+pipenv/patched/yaml2/__pycache__/serializer.cpython-37.pyc,,
+pipenv/patched/yaml2/__pycache__/tokens.cpython-37.pyc,,
+pipenv/patched/yaml2/composer.py,sha256=TtvWJCaffdVHhHx_muLguloDUwg1NUbo-GlJ0me6xuA,4923
+pipenv/patched/yaml2/constructor.py,sha256=N5GQ7pKrp3X5t19o7T3UuQ1ygpTSRZSH7GLc--gWmZE,28797
+pipenv/patched/yaml2/cyaml.py,sha256=6MZKSJHTWwoct5urK9qbGXAhM1xz_Boawlf5SVMC85o,3842
+pipenv/patched/yaml2/dumper.py,sha256=yMFwlojOY-M4EMUT8FiROY2QC2GAGQO7Iiky0xBlJFc,2833
+pipenv/patched/yaml2/emitter.py,sha256=B_uViWV5NzKMlh6NQe3zHnDYxCG77jNiyQXy2okKHkY,43407
+pipenv/patched/yaml2/error.py,sha256=7K-NdIv0qNKPKbnXxEg0L_b9K7nYDORr3rzm8_b-iBY,2559
+pipenv/patched/yaml2/events.py,sha256=50_TksgQiE4up-lKo_V-nBy-tAIxkIPQxY5qDhKCeHw,2445
+pipenv/patched/yaml2/loader.py,sha256=syIemRR13RodV1USH2kZhbHFAwmJgLoVJ9mG_FMJAaY,2055
+pipenv/patched/yaml2/nodes.py,sha256=gPKNj8pKCdh2d4gr3gIYINnPOaOxGhJAUiYhGRnPE84,1440
+pipenv/patched/yaml2/parser.py,sha256=sgXahZA3DkySYnaC4D_zcl3l2y4Y5R40icWtdwkF_NE,25542
+pipenv/patched/yaml2/reader.py,sha256=Rmr6bWrvoEpvQVZbEh6ZY0kxi98Oi7bNMtyz-mHu9xk,6913
+pipenv/patched/yaml2/representer.py,sha256=hES308Ty6i0AbFJS1t1z71j6Z9mODrjIEWr4kqS26fI,17787
+pipenv/patched/yaml2/resolver.py,sha256=5Z3boiMikL6Qt6fS5Mt8fHym0GxbW7CMT2f2fnD1ZPQ,9122
+pipenv/patched/yaml2/scanner.py,sha256=yuGHsVBr9J9zXjfBSfmEJxGm-bwB_km2T-ht9wWgtok,52027
+pipenv/patched/yaml2/serializer.py,sha256=tRsRwfu5E9fpLU7LY3vBQf2prt77hwnYlMt5dnBJLig,4171
+pipenv/patched/yaml2/tokens.py,sha256=lTQIzSVw8Mg9wv459-TjiOQe6wVziqaRlqX2_89rp54,2573
+pipenv/patched/yaml3/LICENSE,sha256=xAESRJ8lS5dTBFklJIMT6ScO-jbSJrItgtTMbEPFfyk,1101
+pipenv/patched/yaml3/__init__.py,sha256=XFUNbKTg4afAd0BETjGQ1mKQ97_g5jbE1C0WoKc74dc,13170
+pipenv/patched/yaml3/__pycache__/__init__.cpython-37.pyc,,
+pipenv/patched/yaml3/__pycache__/composer.cpython-37.pyc,,
+pipenv/patched/yaml3/__pycache__/constructor.cpython-37.pyc,,
+pipenv/patched/yaml3/__pycache__/cyaml.cpython-37.pyc,,
+pipenv/patched/yaml3/__pycache__/dumper.cpython-37.pyc,,
+pipenv/patched/yaml3/__pycache__/emitter.cpython-37.pyc,,
+pipenv/patched/yaml3/__pycache__/error.cpython-37.pyc,,
+pipenv/patched/yaml3/__pycache__/events.cpython-37.pyc,,
+pipenv/patched/yaml3/__pycache__/loader.cpython-37.pyc,,
+pipenv/patched/yaml3/__pycache__/nodes.cpython-37.pyc,,
+pipenv/patched/yaml3/__pycache__/parser.cpython-37.pyc,,
+pipenv/patched/yaml3/__pycache__/reader.cpython-37.pyc,,
+pipenv/patched/yaml3/__pycache__/representer.cpython-37.pyc,,
+pipenv/patched/yaml3/__pycache__/resolver.cpython-37.pyc,,
+pipenv/patched/yaml3/__pycache__/scanner.cpython-37.pyc,,
+pipenv/patched/yaml3/__pycache__/serializer.cpython-37.pyc,,
+pipenv/patched/yaml3/__pycache__/tokens.cpython-37.pyc,,
+pipenv/patched/yaml3/composer.py,sha256=_Ko30Wr6eDWUeUpauUGT3Lcg9QPBnOPVlTnIMRGJ9FM,4883
+pipenv/patched/yaml3/constructor.py,sha256=O3Uaf0_J_5GQBoeI9ZNhpJAhtdagr_X2HzDgGbZOMnw,28627
+pipenv/patched/yaml3/cyaml.py,sha256=LiMkvchNonfoy1F6ec9L2BiUz3r0bwF4hympASJX1Ic,3846
+pipenv/patched/yaml3/dumper.py,sha256=PLctZlYwZLp7XmeUdwRuv4nYOZ2UBnDIUy8-lKfLF-o,2837
+pipenv/patched/yaml3/emitter.py,sha256=jghtaU7eFwg31bG0B7RZea_29Adi9CKmXq_QjgQpCkQ,43006
+pipenv/patched/yaml3/error.py,sha256=Ah9z-toHJUbE9j-M8YpxgSRM5CgLCcwVzJgLLRF2Fxo,2533
+pipenv/patched/yaml3/events.py,sha256=50_TksgQiE4up-lKo_V-nBy-tAIxkIPQxY5qDhKCeHw,2445
+pipenv/patched/yaml3/loader.py,sha256=UVa-zIqmkFSCIYq_PgSGm4NSJttHY2Rf_zQ4_b1fHN0,2061
+pipenv/patched/yaml3/nodes.py,sha256=gPKNj8pKCdh2d4gr3gIYINnPOaOxGhJAUiYhGRnPE84,1440
+pipenv/patched/yaml3/parser.py,sha256=ilWp5vvgoHFGzvOZDItFoGjD6D42nhlZrZyjAwa0oJo,25495
+pipenv/patched/yaml3/reader.py,sha256=0dmzirOiDG4Xo41RnuQS7K9rkY3xjHiVasfDMNTqCNw,6794
+pipenv/patched/yaml3/representer.py,sha256=82UM3ZxUQKqsKAF4ltWOxCS6jGPIFtXpGs7mvqyv4Xs,14184
+pipenv/patched/yaml3/resolver.py,sha256=DJCjpQr8YQCEYYjKEYqTl0GrsZil2H4aFOI9b0Oe-U4,8970
+pipenv/patched/yaml3/scanner.py,sha256=KeQIKGNlSyPE8QDwionHxy9CgbqE5teJEz05FR9-nAg,51277
+pipenv/patched/yaml3/serializer.py,sha256=ChuFgmhU01hj4xgI8GaKv6vfM2Bujwa9i7d2FAHj7cA,4165
+pipenv/patched/yaml3/tokens.py,sha256=lTQIzSVw8Mg9wv459-TjiOQe6wVziqaRlqX2_89rp54,2573
+pipenv/pep508checker.py,sha256=OgS0wD7ZYCF9dVwqj0Hf9950IfLb4jmIOvX-2symzvc,1220
+pipenv/pipenv.1,sha256=qwyN_Q5cFKq_Oq5iQj58mo-kNUEwyxfBEbpuXM1Mxws,152458
+pipenv/progress.py,sha256=WA-81JamxUQFgLMNn2FyTwj2y3IXac54sfM6Xl_k7xA,6387
+pipenv/project.py,sha256=e_Jnod3bvuUUAbC1z1pNJBUagPAtl-G68RMf4VL1Dxs,41096
+pipenv/resolver.py,sha256=8PaI3tErW8zsfLfIZkzU-ivbxyhCfgcOj2KC0NPCeJU,32590
+pipenv/shells.py,sha256=8oEi3RRap8WZnSh234X8EsDOGT8jyR0zIMIi9BS4oTI,7618
+pipenv/utils.py,sha256=eo_8KibIyLR0vzk372SFIbqA37IL0L_s24nfj0jNa3M,85635
+pipenv/vendor/Makefile,sha256=3iJQYI8hLn1e0dGK0USh_w0TM7urGT_yc4Xx03USCDY,374
+pipenv/vendor/README.md,sha256=oPrt1DkxvTcMkFippK0lhh5x-xWOdFGRNEKfHI-kHBM,960
+pipenv/vendor/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+pipenv/vendor/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/__pycache__/appdirs.cpython-37.pyc,,
+pipenv/vendor/__pycache__/cached_property.cpython-37.pyc,,
+pipenv/vendor/__pycache__/contextlib2.cpython-37.pyc,,
+pipenv/vendor/__pycache__/delegator.cpython-37.pyc,,
+pipenv/vendor/__pycache__/docopt.cpython-37.pyc,,
+pipenv/vendor/__pycache__/first.cpython-37.pyc,,
+pipenv/vendor/__pycache__/parse.cpython-37.pyc,,
+pipenv/vendor/__pycache__/pipdeptree.cpython-37.pyc,,
+pipenv/vendor/__pycache__/pyparsing.cpython-37.pyc,,
+pipenv/vendor/__pycache__/scandir.cpython-37.pyc,,
+pipenv/vendor/__pycache__/semver.cpython-37.pyc,,
+pipenv/vendor/__pycache__/six.cpython-37.pyc,,
+pipenv/vendor/__pycache__/zipp.cpython-37.pyc,,
+pipenv/vendor/appdirs.LICENSE.txt,sha256=Nt200KdFqTqyAyA9cZCBSxuJcn0lTK_0jHp6-71HAAs,1097
+pipenv/vendor/appdirs.py,sha256=g99s2sXhnvTEm79oj4bWI0Toapc-_SmKKNXvOXHkVic,24720
+pipenv/vendor/attr/LICENSE,sha256=v2WaKLSSQGAvVrvfSQy-LsUJsVuY-Z17GaUsdA4yeGM,1082
+pipenv/vendor/attr/__init__.py,sha256=ONaI-ZEGOIC7IDqH2HANgesnOxPE1m0GIRRYPPsXEHk,1349
+pipenv/vendor/attr/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/attr/__pycache__/_compat.cpython-37.pyc,,
+pipenv/vendor/attr/__pycache__/_config.cpython-37.pyc,,
+pipenv/vendor/attr/__pycache__/_funcs.cpython-37.pyc,,
+pipenv/vendor/attr/__pycache__/_make.cpython-37.pyc,,
+pipenv/vendor/attr/__pycache__/_version_info.cpython-37.pyc,,
+pipenv/vendor/attr/__pycache__/converters.cpython-37.pyc,,
+pipenv/vendor/attr/__pycache__/exceptions.cpython-37.pyc,,
+pipenv/vendor/attr/__pycache__/filters.cpython-37.pyc,,
+pipenv/vendor/attr/__pycache__/validators.cpython-37.pyc,,
+pipenv/vendor/attr/_compat.py,sha256=-pJtdtqgCg0K6rH_BWf3wKuTum58GD-WWPclQQ2SUaU,7326
+pipenv/vendor/attr/_config.py,sha256=_KvW0mQdH2PYjHc0YfIUaV_o2pVfM7ziMEYTxwmEhOA,514
+pipenv/vendor/attr/_funcs.py,sha256=unAJfNGSTOzxyFzkj7Rs3O1bfsQodmXyir9uZKen-vY,9696
+pipenv/vendor/attr/_make.py,sha256=HhjGhFEbnxPKuUb9hFmAjXoQGpekniw1IEF3_Z-vwCc,70807
+pipenv/vendor/attr/_version_info.py,sha256=azMi1lNelb3cJvvYUMXsXVbUANkRzbD5IEiaXVpeVr4,2162
+pipenv/vendor/attr/converters.py,sha256=5QJRYSXE8G7PW0289y_SPwvvZIcw-nJIuBlfYVdB4BQ,2141
+pipenv/vendor/attr/exceptions.py,sha256=hbhOa3b4W8_mRrbj3FsMTR4Bt5xzbJs5xaFTWn8s6h4,1635
+pipenv/vendor/attr/filters.py,sha256=weDxwATsa69T_0bPVjiM1fGsciAMQmwhY5G8Jm5BxuI,1098
+pipenv/vendor/attr/validators.py,sha256=8AsxgdDgh3sGPseiUIMPGcTr6PvaDYfH3AK46tsvs8U,11460
+pipenv/vendor/backports/__init__.py,sha256=S-asIse2QAvH5SrRGEfcZEmwXulPNP80nwSES8GfYMQ,179
+pipenv/vendor/backports/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/backports/__pycache__/functools_lru_cache.cpython-37.pyc,,
+pipenv/vendor/backports/__pycache__/weakref.cpython-37.pyc,,
+pipenv/vendor/backports/enum/LICENSE,sha256=iOxqbI6vo7l1fnRXg5OL7z9eTV48drHbV2qjq1IOXh0,1508
+pipenv/vendor/backports/enum/README,sha256=fyStyG6c3wxR2bHyZhLPNtc_ASDxGw-l8G6LzVxmkig,157
+pipenv/vendor/backports/enum/__init__.py,sha256=G_as1_Koj30m2lgCpawYkEfM9gUxJHJ4gEdCT88INLo,31101
+pipenv/vendor/backports/enum/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/backports/functools_lru_cache.LICENSE,sha256=pV4v_ptEmY5iHVHYwJS-0JrMS1I27nPX3zlaM7o8GP0,1050
+pipenv/vendor/backports/functools_lru_cache.py,sha256=Vd8mKVtsiiCGrvSjNgYt7zySiuPRSl5cOHQuJ2qsAq4,7220
+pipenv/vendor/backports/shutil_get_terminal_size/LICENSE,sha256=nt2Z-MM5zdv-NqlwfmcfzPJFs-ULgO7Ah33M7Iei3-Q,1086
+pipenv/vendor/backports/shutil_get_terminal_size/__init__.py,sha256=sPUduFmFhru_q1gLcv5gMN3I3tUSSSU9YlvuVdhQjdo,338
+pipenv/vendor/backports/shutil_get_terminal_size/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/backports/shutil_get_terminal_size/__pycache__/get_terminal_size.cpython-37.pyc,,
+pipenv/vendor/backports/shutil_get_terminal_size/get_terminal_size.py,sha256=nany8-cgBwmqLe7giIJ0e7c2PV7dTp89Q7fGsxUrNQI,2913
+pipenv/vendor/backports/weakref.LICENSE,sha256=78DH8plPlb4l985jqGX4cOJ4_wqk9dUthNTW0qmBKL0,12773
+pipenv/vendor/backports/weakref.py,sha256=JDEevYXbZI3vihsJetC1jQATHJtpafJyilcbWg9hMaM,5238
+pipenv/vendor/cached-property.LICENSE,sha256=ukdWyAObJbZuPEVsxb9jWqUoz0Wbl-4UmdBmhMzYm5o,1479
+pipenv/vendor/cached_property.py,sha256=0Q4NaS2UyL1qsdSfwyQLY-ss-aeTImY3KFelWyDsbu4,4277
+pipenv/vendor/cerberus/LICENSE,sha256=OXJkvLKH9kPVx7jBhG566vGRH4I2svi9759-bxzy__k,751
+pipenv/vendor/cerberus/__init__.py,sha256=3HBrv1A3gb6m4c2W7pioIhmST98ab3MraYCcOpu-p2g,795
+pipenv/vendor/cerberus/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/cerberus/__pycache__/errors.cpython-37.pyc,,
+pipenv/vendor/cerberus/__pycache__/platform.cpython-37.pyc,,
+pipenv/vendor/cerberus/__pycache__/schema.cpython-37.pyc,,
+pipenv/vendor/cerberus/__pycache__/utils.cpython-37.pyc,,
+pipenv/vendor/cerberus/__pycache__/validator.cpython-37.pyc,,
+pipenv/vendor/cerberus/errors.py,sha256=uGwf5ay1Yv-F2Fit60EXoDAzrVDPvfio3OylVcfEdaY,21184
+pipenv/vendor/cerberus/platform.py,sha256=_hGYKaLTJCWrDcgEI2mLpSEDIyorgE40eWEpDxvCtAs,743
+pipenv/vendor/cerberus/schema.py,sha256=nKIPDGDn41SwPnQHuxv2MA_ScWd1gQLZn0SrnNkiukY,18116
+pipenv/vendor/cerberus/tests/__init__.py,sha256=60IWTU5LZQ0gYeBTmEXptblehM1IzZOsQLrYrn5kxmw,4707
+pipenv/vendor/cerberus/tests/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/cerberus/tests/__pycache__/conftest.cpython-37.pyc,,
+pipenv/vendor/cerberus/tests/__pycache__/test_assorted.cpython-37.pyc,,
+pipenv/vendor/cerberus/tests/__pycache__/test_customization.cpython-37.pyc,,
+pipenv/vendor/cerberus/tests/__pycache__/test_errors.cpython-37.pyc,,
+pipenv/vendor/cerberus/tests/__pycache__/test_legacy.cpython-37.pyc,,
+pipenv/vendor/cerberus/tests/__pycache__/test_normalization.cpython-37.pyc,,
+pipenv/vendor/cerberus/tests/__pycache__/test_registries.cpython-37.pyc,,
+pipenv/vendor/cerberus/tests/__pycache__/test_schema.cpython-37.pyc,,
+pipenv/vendor/cerberus/tests/__pycache__/test_utils.cpython-37.pyc,,
+pipenv/vendor/cerberus/tests/__pycache__/test_validation.cpython-37.pyc,,
+pipenv/vendor/cerberus/tests/conftest.py,sha256=CVw_J0T2rw89KTYL7OKQyKwv8yE0kCa18Vvv-NfP3ls,2517
+pipenv/vendor/cerberus/tests/test_assorted.py,sha256=DifsOU-Y16Zp4utQ4SyJtTGjgL4fPwkVWXiKQnCmbcM,3169
+pipenv/vendor/cerberus/tests/test_customization.py,sha256=kWecIGjUnpVz74ZMi3ozV6aTKOVqnjY9C57ZuElxQbI,3373
+pipenv/vendor/cerberus/tests/test_errors.py,sha256=BO-9Zdo4Bfm_WINzaVVkDf5obBesmADjsHPKVcP5zAg,11018
+pipenv/vendor/cerberus/tests/test_legacy.py,sha256=37wjVkGfwPX9kZE_TDds3Q9R5b-CQzlvQiOJVG9Y9NI,30
+pipenv/vendor/cerberus/tests/test_normalization.py,sha256=zcsNVbEF4SNQj0UI1O1bBwbvIn5QFWEYStxalS0P5KU,17212
+pipenv/vendor/cerberus/tests/test_registries.py,sha256=dD2BGXcG2f-Z0qBAYqNgfCKJK7ve-pdK93LaNrJrML0,2841
+pipenv/vendor/cerberus/tests/test_schema.py,sha256=tVckri9pmBPdmMjIpYkKvN48MvY1plK3avvUjhw7r7Y,4954
+pipenv/vendor/cerberus/tests/test_utils.py,sha256=YhkRkqKmeARPXJIfG6o9TvgXpk45gucN5LToZgnDLvw,290
+pipenv/vendor/cerberus/tests/test_validation.py,sha256=VThWbOndoHBIJmg0eGEAUu0rFbvY9qPJaliUx2AbDws,58500
+pipenv/vendor/cerberus/utils.py,sha256=0tCmurjS9ewxy3PmyTMI_WrJVEV_hoB-efldwGhjS6o,3887
+pipenv/vendor/cerberus/validator.py,sha256=uGkAuXGBVyLxiBFyULON0UWUUYN6CD2OT_Mg6gzkRoQ,64775
+pipenv/vendor/certifi/LICENSE,sha256=anCkv2sBABbVmmS4rkrY3H9e8W8ftFPMLs13HFo0ETE,1048
+pipenv/vendor/certifi/__init__.py,sha256=AOqspvggP_F62Q_4UmJAhx5rZkoRHoRYBE3SCnSJzAk,64
+pipenv/vendor/certifi/__main__.py,sha256=xBBoj905TUWBLRGANOcf7oi6e-3dMP4cEoG9OyMs11g,243
+pipenv/vendor/certifi/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/certifi/__pycache__/__main__.cpython-37.pyc,,
+pipenv/vendor/certifi/__pycache__/core.cpython-37.pyc,,
+pipenv/vendor/certifi/cacert.pem,sha256=hwBo73gFnF0BKiP3FQKfG32xkGDhxl4SwCQiH2rDKr0,284099
+pipenv/vendor/certifi/core.py,sha256=c8hoNcYWz6rQo2VAM5d0mcEWiewCvQuOUbCwJz49vhQ,792
+pipenv/vendor/chardet/LICENSE,sha256=YJXp_6d33SKDn3gBqoRbMcntB_PWv4om3F0t7IzMDvM,26432
+pipenv/vendor/chardet/__init__.py,sha256=YsP5wQlsHJ2auF1RZJfypiSrCA7_bQiRm3ES_NI76-Y,1559
+pipenv/vendor/chardet/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/chardet/__pycache__/big5freq.cpython-37.pyc,,
+pipenv/vendor/chardet/__pycache__/big5prober.cpython-37.pyc,,
+pipenv/vendor/chardet/__pycache__/chardistribution.cpython-37.pyc,,
+pipenv/vendor/chardet/__pycache__/charsetgroupprober.cpython-37.pyc,,
+pipenv/vendor/chardet/__pycache__/charsetprober.cpython-37.pyc,,
+pipenv/vendor/chardet/__pycache__/codingstatemachine.cpython-37.pyc,,
+pipenv/vendor/chardet/__pycache__/compat.cpython-37.pyc,,
+pipenv/vendor/chardet/__pycache__/cp949prober.cpython-37.pyc,,
+pipenv/vendor/chardet/__pycache__/enums.cpython-37.pyc,,
+pipenv/vendor/chardet/__pycache__/escprober.cpython-37.pyc,,
+pipenv/vendor/chardet/__pycache__/escsm.cpython-37.pyc,,
+pipenv/vendor/chardet/__pycache__/eucjpprober.cpython-37.pyc,,
+pipenv/vendor/chardet/__pycache__/euckrfreq.cpython-37.pyc,,
+pipenv/vendor/chardet/__pycache__/euckrprober.cpython-37.pyc,,
+pipenv/vendor/chardet/__pycache__/euctwfreq.cpython-37.pyc,,
+pipenv/vendor/chardet/__pycache__/euctwprober.cpython-37.pyc,,
+pipenv/vendor/chardet/__pycache__/gb2312freq.cpython-37.pyc,,
+pipenv/vendor/chardet/__pycache__/gb2312prober.cpython-37.pyc,,
+pipenv/vendor/chardet/__pycache__/hebrewprober.cpython-37.pyc,,
+pipenv/vendor/chardet/__pycache__/jisfreq.cpython-37.pyc,,
+pipenv/vendor/chardet/__pycache__/jpcntx.cpython-37.pyc,,
+pipenv/vendor/chardet/__pycache__/langbulgarianmodel.cpython-37.pyc,,
+pipenv/vendor/chardet/__pycache__/langcyrillicmodel.cpython-37.pyc,,
+pipenv/vendor/chardet/__pycache__/langgreekmodel.cpython-37.pyc,,
+pipenv/vendor/chardet/__pycache__/langhebrewmodel.cpython-37.pyc,,
+pipenv/vendor/chardet/__pycache__/langhungarianmodel.cpython-37.pyc,,
+pipenv/vendor/chardet/__pycache__/langthaimodel.cpython-37.pyc,,
+pipenv/vendor/chardet/__pycache__/langturkishmodel.cpython-37.pyc,,
+pipenv/vendor/chardet/__pycache__/latin1prober.cpython-37.pyc,,
+pipenv/vendor/chardet/__pycache__/mbcharsetprober.cpython-37.pyc,,
+pipenv/vendor/chardet/__pycache__/mbcsgroupprober.cpython-37.pyc,,
+pipenv/vendor/chardet/__pycache__/mbcssm.cpython-37.pyc,,
+pipenv/vendor/chardet/__pycache__/sbcharsetprober.cpython-37.pyc,,
+pipenv/vendor/chardet/__pycache__/sbcsgroupprober.cpython-37.pyc,,
+pipenv/vendor/chardet/__pycache__/sjisprober.cpython-37.pyc,,
+pipenv/vendor/chardet/__pycache__/universaldetector.cpython-37.pyc,,
+pipenv/vendor/chardet/__pycache__/utf8prober.cpython-37.pyc,,
+pipenv/vendor/chardet/__pycache__/version.cpython-37.pyc,,
+pipenv/vendor/chardet/big5freq.py,sha256=D_zK5GyzoVsRes0HkLJziltFQX0bKCLOrFe9_xDvO_8,31254
+pipenv/vendor/chardet/big5prober.py,sha256=kBxHbdetBpPe7xrlb-e990iot64g_eGSLd32lB7_h3M,1757
+pipenv/vendor/chardet/chardistribution.py,sha256=3woWS62KrGooKyqz4zQSnjFbJpa6V7g02daAibTwcl8,9411
+pipenv/vendor/chardet/charsetgroupprober.py,sha256=6bDu8YIiRuScX4ca9Igb0U69TA2PGXXDej6Cc4_9kO4,3787
+pipenv/vendor/chardet/charsetprober.py,sha256=KSmwJErjypyj0bRZmC5F5eM7c8YQgLYIjZXintZNstg,5110
+pipenv/vendor/chardet/cli/__init__.py,sha256=AbpHGcgLb-kRsJGnwFEktk7uzpZOCcBY74-YBdrKVGs,1
+pipenv/vendor/chardet/cli/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/chardet/cli/__pycache__/chardetect.cpython-37.pyc,,
+pipenv/vendor/chardet/cli/chardetect.py,sha256=YBO8L4mXo0WR6_-Fjh_8QxPBoEBNqB9oNxNrdc54AQs,2738
+pipenv/vendor/chardet/codingstatemachine.py,sha256=VYp_6cyyki5sHgXDSZnXW4q1oelHc3cu9AyQTX7uug8,3590
+pipenv/vendor/chardet/compat.py,sha256=PKTzHkSbtbHDqS9PyujMbX74q1a8mMpeQTDVsQhZMRw,1134
+pipenv/vendor/chardet/cp949prober.py,sha256=TZ434QX8zzBsnUvL_8wm4AQVTZ2ZkqEEQL_lNw9f9ow,1855
+pipenv/vendor/chardet/enums.py,sha256=Aimwdb9as1dJKZaFNUH2OhWIVBVd6ZkJJ_WK5sNY8cU,1661
+pipenv/vendor/chardet/escprober.py,sha256=kkyqVg1Yw3DIOAMJ2bdlyQgUFQhuHAW8dUGskToNWSc,3950
+pipenv/vendor/chardet/escsm.py,sha256=RuXlgNvTIDarndvllNCk5WZBIpdCxQ0kcd9EAuxUh84,10510
+pipenv/vendor/chardet/eucjpprober.py,sha256=iD8Jdp0ISRjgjiVN7f0e8xGeQJ5GM2oeZ1dA8nbSeUw,3749
+pipenv/vendor/chardet/euckrfreq.py,sha256=-7GdmvgWez4-eO4SuXpa7tBiDi5vRXQ8WvdFAzVaSfo,13546
+pipenv/vendor/chardet/euckrprober.py,sha256=MqFMTQXxW4HbzIpZ9lKDHB3GN8SP4yiHenTmf8g_PxY,1748
+pipenv/vendor/chardet/euctwfreq.py,sha256=No1WyduFOgB5VITUA7PLyC5oJRNzRyMbBxaKI1l16MA,31621
+pipenv/vendor/chardet/euctwprober.py,sha256=13p6EP4yRaxqnP4iHtxHOJ6R2zxHq1_m8hTRjzVZ95c,1747
+pipenv/vendor/chardet/gb2312freq.py,sha256=JX8lsweKLmnCwmk8UHEQsLgkr_rP_kEbvivC4qPOrlc,20715
+pipenv/vendor/chardet/gb2312prober.py,sha256=gGvIWi9WhDjE-xQXHvNIyrnLvEbMAYgyUSZ65HUfylw,1754
+pipenv/vendor/chardet/hebrewprober.py,sha256=c3SZ-K7hvyzGY6JRAZxJgwJ_sUS9k0WYkvMY00YBYFo,13838
+pipenv/vendor/chardet/jisfreq.py,sha256=vpmJv2Bu0J8gnMVRPHMFefTRvo_ha1mryLig8CBwgOg,25777
+pipenv/vendor/chardet/jpcntx.py,sha256=PYlNqRUQT8LM3cT5FmHGP0iiscFlTWED92MALvBungo,19643
+pipenv/vendor/chardet/langbulgarianmodel.py,sha256=1HqQS9Pbtnj1xQgxitJMvw8X6kKr5OockNCZWfEQrPE,12839
+pipenv/vendor/chardet/langcyrillicmodel.py,sha256=LODajvsetH87yYDDQKA2CULXUH87tI223dhfjh9Zx9c,17948
+pipenv/vendor/chardet/langgreekmodel.py,sha256=8YAW7bU8YwSJap0kIJSbPMw1BEqzGjWzqcqf0WgUKAA,12688
+pipenv/vendor/chardet/langhebrewmodel.py,sha256=JSnqmE5E62tDLTPTvLpQsg5gOMO4PbdWRvV7Avkc0HA,11345
+pipenv/vendor/chardet/langhungarianmodel.py,sha256=RhapYSG5l0ZaO-VV4Fan5sW0WRGQqhwBM61yx3yxyOA,12592
+pipenv/vendor/chardet/langthaimodel.py,sha256=8l0173Gu_W6G8mxmQOTEF4ls2YdE7FxWf3QkSxEGXJQ,11290
+pipenv/vendor/chardet/langturkishmodel.py,sha256=W22eRNJsqI6uWAfwXSKVWWnCerYqrI8dZQTm_M0lRFk,11102
+pipenv/vendor/chardet/latin1prober.py,sha256=S2IoORhFk39FEFOlSFWtgVybRiP6h7BlLldHVclNkU8,5370
+pipenv/vendor/chardet/mbcharsetprober.py,sha256=AR95eFH9vuqSfvLQZN-L5ijea25NOBCoXqw8s5O9xLQ,3413
+pipenv/vendor/chardet/mbcsgroupprober.py,sha256=h6TRnnYq2OxG1WdD5JOyxcdVpn7dG0q-vB8nWr5mbh4,2012
+pipenv/vendor/chardet/mbcssm.py,sha256=SY32wVIF3HzcjY3BaEspy9metbNSKxIIB0RKPn7tjpI,25481
+pipenv/vendor/chardet/sbcharsetprober.py,sha256=LDSpCldDCFlYwUkGkwD2oFxLlPWIWXT09akH_2PiY74,5657
+pipenv/vendor/chardet/sbcsgroupprober.py,sha256=1IprcCB_k1qfmnxGC6MBbxELlKqD3scW6S8YIwdeyXA,3546
+pipenv/vendor/chardet/sjisprober.py,sha256=IIt-lZj0WJqK4rmUZzKZP4GJlE8KUEtFYVuY96ek5MQ,3774
+pipenv/vendor/chardet/universaldetector.py,sha256=qL0174lSZE442eB21nnktT9_VcAye07laFWUeUrjttY,12485
+pipenv/vendor/chardet/utf8prober.py,sha256=IdD8v3zWOsB8OLiyPi-y_fqwipRFxV9Nc1eKBLSuIEw,2766
+pipenv/vendor/chardet/version.py,sha256=sp3B08mrDXB-pf3K9fqJ_zeDHOCLC8RrngQyDFap_7g,242
+pipenv/vendor/click/LICENSE.rst,sha256=morRBqOU6FO_4h9C9OctWSgZoigF2ZG18ydQKSkrZY0,1475
+pipenv/vendor/click/__init__.py,sha256=FkyGDQ-cbiQxP_lxgUspyFYS48f2S_pTcfKPz-d_RMo,2463
+pipenv/vendor/click/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/click/__pycache__/_bashcomplete.cpython-37.pyc,,
+pipenv/vendor/click/__pycache__/_compat.cpython-37.pyc,,
+pipenv/vendor/click/__pycache__/_termui_impl.cpython-37.pyc,,
+pipenv/vendor/click/__pycache__/_textwrap.cpython-37.pyc,,
+pipenv/vendor/click/__pycache__/_unicodefun.cpython-37.pyc,,
+pipenv/vendor/click/__pycache__/_winconsole.cpython-37.pyc,,
+pipenv/vendor/click/__pycache__/core.cpython-37.pyc,,
+pipenv/vendor/click/__pycache__/decorators.cpython-37.pyc,,
+pipenv/vendor/click/__pycache__/exceptions.cpython-37.pyc,,
+pipenv/vendor/click/__pycache__/formatting.cpython-37.pyc,,
+pipenv/vendor/click/__pycache__/globals.cpython-37.pyc,,
+pipenv/vendor/click/__pycache__/parser.cpython-37.pyc,,
+pipenv/vendor/click/__pycache__/termui.cpython-37.pyc,,
+pipenv/vendor/click/__pycache__/testing.cpython-37.pyc,,
+pipenv/vendor/click/__pycache__/types.cpython-37.pyc,,
+pipenv/vendor/click/__pycache__/utils.cpython-37.pyc,,
+pipenv/vendor/click/_bashcomplete.py,sha256=9J98IHQYmCAr2Jup6TDshUr5FJEen-AoQCZR0K5nKxQ,12309
+pipenv/vendor/click/_compat.py,sha256=AoMaYnZ-3pwtNXuHtlb6_UXsayoG0QZiHKIRy2VFezc,24169
+pipenv/vendor/click/_termui_impl.py,sha256=yNktUMAdjYOU1HMkq915jR3zgAzUNtGSQqSTSSMn3eQ,20702
+pipenv/vendor/click/_textwrap.py,sha256=ajCzkzFly5tjm9foQ5N9_MOeaYJMBjAltuFa69n4iXY,1197
+pipenv/vendor/click/_unicodefun.py,sha256=apLSNEBZgUsQNPMUv072zJ1swqnm0dYVT5TqcIWTt6w,4201
+pipenv/vendor/click/_winconsole.py,sha256=6YDu6Rq1Wxx4w9uinBMK2LHvP83aerZM9GQurlk3QDo,10010
+pipenv/vendor/click/core.py,sha256=V6DJzastGhrC6WTDwV9MSLwcJUdX2Uf1ypmgkjBdn_Y,77650
+pipenv/vendor/click/decorators.py,sha256=3TvEO_BkaHl7k6Eh1G5eC7JK4LKPdpFqH9JP0QDyTlM,11215
+pipenv/vendor/click/exceptions.py,sha256=3pQAyyMFzx5A3eV0Y27WtDTyGogZRbrC6_o5DjjKBbw,8118
+pipenv/vendor/click/formatting.py,sha256=Wb4gqFEpWaKPgAbOvnkCl8p-bEZx5KpM5ZSByhlnJNk,9281
+pipenv/vendor/click/globals.py,sha256=ht7u2kUGI08pAarB4e4yC8Lkkxy6gJfRZyzxEj8EbWQ,1501
+pipenv/vendor/click/parser.py,sha256=mFK-k58JtPpqO0AC36WAr0t5UfzEw1mvgVSyn7WCe9M,15691
+pipenv/vendor/click/termui.py,sha256=G7QBEKIepRIGLvNdGwBTYiEtSImRxvTO_AglVpyHH2s,23998
+pipenv/vendor/click/testing.py,sha256=EUEsDUqNXFgCLhZ0ZFOROpaVDA5I_rijwnNPE6qICgA,12854
+pipenv/vendor/click/types.py,sha256=wuubik4VqgqAw5dvbYFkDt-zSAx97y9TQXuXcVaRyQA,25045
+pipenv/vendor/click/utils.py,sha256=4VEcJ7iEHwjnFuzEuRtkT99o5VG3zqSD7Q2CVzv13WU,15940
+pipenv/vendor/click_completion/LICENSE,sha256=8MfbN52orMmmZ4eve6qDoamLiER3GXz2q6FsLqNDfdM,1082
+pipenv/vendor/click_completion/__init__.py,sha256=HuegtTgqIhMLhRFY5EXtB0VYAJZeGWlLhWZjty_JbjI,3173
+pipenv/vendor/click_completion/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/click_completion/__pycache__/core.cpython-37.pyc,,
+pipenv/vendor/click_completion/__pycache__/lib.cpython-37.pyc,,
+pipenv/vendor/click_completion/__pycache__/patch.cpython-37.pyc,,
+pipenv/vendor/click_completion/bash.j2,sha256=mp_5itIF9EvYIbUafpyywTgZrUZWUFwPWzfk1O0l35g,369
+pipenv/vendor/click_completion/core.py,sha256=CUsVgiTHZbgL5X_K7jaEn1XVn9-_j1mFY4BezIIJhwk,12261
+pipenv/vendor/click_completion/fish.j2,sha256=AQsYOQ27r8yMjw2HMV2V8zjjonVLeJgpD5CgcQojo1o,190
+pipenv/vendor/click_completion/lib.py,sha256=dH2j9_wLD7t6RMij4hLzhHarF7innQ4I8CLoufeyesc,3035
+pipenv/vendor/click_completion/patch.py,sha256=oj8Fe1Ig5-snfKXJ7qLP5h2MSSg2hU9nHBFeB2Na33I,5457
+pipenv/vendor/click_completion/powershell.j2,sha256=BYQuHipSUREz7wj5VU8WxWF48_IPdZqleORjlRf3ANI,1051
+pipenv/vendor/click_completion/zsh.j2,sha256=k3LzKP7aCQG7_4qL3RZ_1z3qTFOouc7aUVitnstbYro,302
+pipenv/vendor/click_didyoumean/LICENSE,sha256=78dPJV3W_UKJNjsb_nHNDtcLKSbIJY1hUiBOaokEHAo,1056
+pipenv/vendor/click_didyoumean/__init__.py,sha256=oGFpacrXwznWDox92qB0-5NTprn2_1SKm8pzwHgAwCc,1960
+pipenv/vendor/click_didyoumean/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/colorama/LICENSE.txt,sha256=ysNcAmhuXQSlpxQL-zs25zrtSWZW6JEQLkKIhteTAxg,1491
+pipenv/vendor/colorama/__init__.py,sha256=DqjXH9URVP3IJwmMt7peYw50ns1RNAymIB9-XdPEFV8,239
+pipenv/vendor/colorama/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/colorama/__pycache__/ansi.cpython-37.pyc,,
+pipenv/vendor/colorama/__pycache__/ansitowin32.cpython-37.pyc,,
+pipenv/vendor/colorama/__pycache__/initialise.cpython-37.pyc,,
+pipenv/vendor/colorama/__pycache__/win32.cpython-37.pyc,,
+pipenv/vendor/colorama/__pycache__/winterm.cpython-37.pyc,,
+pipenv/vendor/colorama/ansi.py,sha256=Fi0un-QLqRm-v7o_nKiOqyC8PapBJK7DLV_q9LKtTO0,2524
+pipenv/vendor/colorama/ansitowin32.py,sha256=u8QaqdqS_xYSfNkPM1eRJLHz6JMWPodaJaP0mxgHCDc,10462
+pipenv/vendor/colorama/initialise.py,sha256=PprovDNxMTrvoNHFcL2NZjpH2XzDc8BLxLxiErfUl4k,1915
+pipenv/vendor/colorama/win32.py,sha256=bJ8Il9jwaBN5BJ8bmN6FoYZ1QYuMKv2j8fGrXh7TJjw,5404
+pipenv/vendor/colorama/winterm.py,sha256=2y_2b7Zsv34feAsP67mLOVc-Bgq51mdYGo571VprlrM,6438
+pipenv/vendor/contextlib2.LICENSE.txt,sha256=xqev-sas2tLS3YfS12hDhiSraSYY2x8CvqOxHT85ePA,6054
+pipenv/vendor/contextlib2.py,sha256=5HjGflUzwWAUfcILhSmC2GqvoYdZZzFzVfIDztHigUs,16915
+pipenv/vendor/dateutil/LICENSE,sha256=ugD1Gg2SgjtaHN4n2LW50jIeZ-2NqbwWPv-W1eF-V34,2889
+pipenv/vendor/dateutil/__init__.py,sha256=lXElASqwYGwqlrSWSeX19JwF5Be9tNecDa9ebk-0gmk,222
+pipenv/vendor/dateutil/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/dateutil/__pycache__/_common.cpython-37.pyc,,
+pipenv/vendor/dateutil/__pycache__/_version.cpython-37.pyc,,
+pipenv/vendor/dateutil/__pycache__/easter.cpython-37.pyc,,
+pipenv/vendor/dateutil/__pycache__/relativedelta.cpython-37.pyc,,
+pipenv/vendor/dateutil/__pycache__/rrule.cpython-37.pyc,,
+pipenv/vendor/dateutil/__pycache__/tzwin.cpython-37.pyc,,
+pipenv/vendor/dateutil/__pycache__/utils.cpython-37.pyc,,
+pipenv/vendor/dateutil/_common.py,sha256=77w0yytkrxlYbSn--lDVPUMabUXRR9I3lBv_vQRUqUY,932
+pipenv/vendor/dateutil/_version.py,sha256=U1JNX8P5pUNBtcStwfGyAUIMMHGZXhiTDTVXgAUWxs4,116
+pipenv/vendor/dateutil/easter.py,sha256=0liVsgqSx-NPhaFevOJaYgEbrSu2oQQ2o9m_OEBdc-s,2684
+pipenv/vendor/dateutil/parser/__init__.py,sha256=wWk6GFuxTpjoggCGtgkceJoti4pVjl4_fHQXpNOaSYg,1766
+pipenv/vendor/dateutil/parser/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/dateutil/parser/__pycache__/_parser.cpython-37.pyc,,
+pipenv/vendor/dateutil/parser/__pycache__/isoparser.cpython-37.pyc,,
+pipenv/vendor/dateutil/parser/_parser.py,sha256=F0w8h9txvatnYAmeJ1MMbIAvZHRzy3iFjv-AZqRovNs,58804
+pipenv/vendor/dateutil/parser/isoparser.py,sha256=BeEEqIeqhcgik5Cp1_G5Aztsqayp-MAr3aVqAKo1XRc,13098
+pipenv/vendor/dateutil/relativedelta.py,sha256=GjVxqpAVWnG67rdbf7pkoIlJvQqmju9NSfGCcqblc7U,24904
+pipenv/vendor/dateutil/rrule.py,sha256=dStRcOIj8jul-BurMKguc_IBckY-Qci1K6EYqNW8eUg,66514
+pipenv/vendor/dateutil/tz/__init__.py,sha256=F-Mz13v6jYseklQf9Te9J6nzcLDmq47gORa61K35_FA,444
+pipenv/vendor/dateutil/tz/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/dateutil/tz/__pycache__/_common.cpython-37.pyc,,
+pipenv/vendor/dateutil/tz/__pycache__/_factories.cpython-37.pyc,,
+pipenv/vendor/dateutil/tz/__pycache__/tz.cpython-37.pyc,,
+pipenv/vendor/dateutil/tz/__pycache__/win.cpython-37.pyc,,
+pipenv/vendor/dateutil/tz/_common.py,sha256=cgzDTANsOXvEc86cYF77EsliuSab8Puwpsl5-bX3_S4,12977
+pipenv/vendor/dateutil/tz/_factories.py,sha256=unb6XQNXrPMveksTCU-Ag8jmVZs4SojoPUcAHpWnrvU,2569
+pipenv/vendor/dateutil/tz/tz.py,sha256=npaGnA2M2LGUUerXzAml9rMM-BE771igYFcFETeC3JE,62851
+pipenv/vendor/dateutil/tz/win.py,sha256=xJszWgSwE1xPx_HJj4ZkepyukC_hNy016WMcXhbRaB8,12935
+pipenv/vendor/dateutil/tzwin.py,sha256=7Ar4vdQCnnM0mKR3MUjbIKsZrBVfHgdwsJZc_mGYRew,59
+pipenv/vendor/dateutil/utils.py,sha256=Agvhi7i3HuJdwHYCe9lDS63l_LNFUUlB2hmR3ZKNYwE,1959
+pipenv/vendor/dateutil/zoneinfo/__init__.py,sha256=KYg0pthCMjcp5MXSEiBJn3nMjZeNZav7rlJw5-tz1S4,5889
+pipenv/vendor/dateutil/zoneinfo/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/dateutil/zoneinfo/__pycache__/rebuild.cpython-37.pyc,,
+pipenv/vendor/dateutil/zoneinfo/rebuild.py,sha256=2uFJQiW3Fl8fVogrSXisJMpLeHI1zGwpvBFF43QdeF0,1719
+pipenv/vendor/delegator.py,sha256=-JNaGsUVOljiOOW1UTwy35Ol8qeAVNo2TAFZG0rN6Vc,9630
+pipenv/vendor/delegator.py.LICENSE,sha256=auEF5pj7X6bfqRx5qJGpBcCJsl77mhYsoJ5vMx2Cr-Q,1076
+pipenv/vendor/distlib/LICENSE.txt,sha256=gI4QyKarjesUn_mz-xn0R6gICUYG1xKpylf-rTVSWZ0,14531
+pipenv/vendor/distlib/__init__.py,sha256=gzl1hjUXmDGrqRyU7ZLjBwJGAcMimQbrZ22XPVaKaRE,581
+pipenv/vendor/distlib/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/distlib/__pycache__/compat.cpython-37.pyc,,
+pipenv/vendor/distlib/__pycache__/database.cpython-37.pyc,,
+pipenv/vendor/distlib/__pycache__/index.cpython-37.pyc,,
+pipenv/vendor/distlib/__pycache__/locators.cpython-37.pyc,,
+pipenv/vendor/distlib/__pycache__/manifest.cpython-37.pyc,,
+pipenv/vendor/distlib/__pycache__/markers.cpython-37.pyc,,
+pipenv/vendor/distlib/__pycache__/metadata.cpython-37.pyc,,
+pipenv/vendor/distlib/__pycache__/resources.cpython-37.pyc,,
+pipenv/vendor/distlib/__pycache__/scripts.cpython-37.pyc,,
+pipenv/vendor/distlib/__pycache__/util.cpython-37.pyc,,
+pipenv/vendor/distlib/__pycache__/version.cpython-37.pyc,,
+pipenv/vendor/distlib/__pycache__/wheel.cpython-37.pyc,,
+pipenv/vendor/distlib/_backport/__init__.py,sha256=bqS_dTOH6uW9iGgd0uzfpPjo6vZ4xpPZ7kyfZJ2vNaw,274
+pipenv/vendor/distlib/_backport/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/distlib/_backport/__pycache__/misc.cpython-37.pyc,,
+pipenv/vendor/distlib/_backport/__pycache__/shutil.cpython-37.pyc,,
+pipenv/vendor/distlib/_backport/__pycache__/sysconfig.cpython-37.pyc,,
+pipenv/vendor/distlib/_backport/__pycache__/tarfile.cpython-37.pyc,,
+pipenv/vendor/distlib/_backport/misc.py,sha256=KWecINdbFNOxSOP1fGF680CJnaC6S4fBRgEtaYTw0ig,971
+pipenv/vendor/distlib/_backport/shutil.py,sha256=VW1t3uYqUjWZH7jV-6QiimLhnldoV5uIpH4EuiT1jfw,25647
+pipenv/vendor/distlib/_backport/sysconfig.cfg,sha256=swZKxq9RY5e9r3PXCrlvQPMsvOdiWZBTHLEbqS8LJLU,2617
+pipenv/vendor/distlib/_backport/sysconfig.py,sha256=BQHFlb6pubCl_dvT1NjtzIthylofjKisox239stDg0U,26854
+pipenv/vendor/distlib/_backport/tarfile.py,sha256=Ihp7rXRcjbIKw8COm9wSePV9ARGXbSF9gGXAMn2Q-KU,92628
+pipenv/vendor/distlib/compat.py,sha256=xdNZmqFN5HwF30HjRn5M415pcC2kgXRBXn767xS8v-M,41404
+pipenv/vendor/distlib/database.py,sha256=fhNzEDtb4HXrpxKyQvhVzDXcOiJlzrOM--UYnvCeZrI,51045
+pipenv/vendor/distlib/index.py,sha256=SXKzpQCERctxYDMp_OLee2f0J0e19ZhGdCIoMlUfUQM,21066
+pipenv/vendor/distlib/locators.py,sha256=c9E4cDEacJ_uKbuE5BqAVocoWp6rsuBGTkiNDQq3zV4,52100
+pipenv/vendor/distlib/manifest.py,sha256=nQEhYmgoreaBZzyFzwYsXxJARu3fo4EkunU163U16iE,14811
+pipenv/vendor/distlib/markers.py,sha256=6Ac3cCfFBERexiESWIOXmg-apIP8l2esafNSX3KMy-8,4387
+pipenv/vendor/distlib/metadata.py,sha256=OhbCKmf5lswE8unWBopI1hj7tRpHp4ZbFvU4d6aAEMM,40234
+pipenv/vendor/distlib/resources.py,sha256=2FGv0ZHF14KXjLIlL0R991lyQQGcewOS4mJ-5n-JVnc,10766
+pipenv/vendor/distlib/scripts.py,sha256=OAkEwxRvIzX-VSfhEttQEKJFVLA47gbW0OgQXJRs7OQ,16998
+pipenv/vendor/distlib/t32.exe,sha256=NS3xBCVAld35JVFNmb-1QRyVtThukMrwZVeXn4LhaEQ,96768
+pipenv/vendor/distlib/t64.exe,sha256=oAqHes78rUWVM0OtVqIhUvequl_PKhAhXYQWnUf7zR0,105984
+pipenv/vendor/distlib/util.py,sha256=f2jZCPrcLCt6LcnC0gUy-Fur60tXD8reA7k4rDpHMDw,59845
+pipenv/vendor/distlib/version.py,sha256=_n7F6juvQGAcn769E_SHa7fOcf5ERlEVymJ_EjPRwGw,23391
+pipenv/vendor/distlib/w32.exe,sha256=lJtnZdeUxTZWya_EW5DZos_K5rswRECGspIl8ZJCIXs,90112
+pipenv/vendor/distlib/w64.exe,sha256=0aRzoN2BO9NWW4ENy4_4vHkHR4qZTFZNVSAJJYlODTI,99840
+pipenv/vendor/distlib/wheel.py,sha256=bRtR5bNR_u_DwkwktN1bgZuwLVOJT1p_vNIUPyN8kJc,40452
+pipenv/vendor/docopt.LICENSE-MIT,sha256=PV33j1kv8kM8PGzkmECRt_SXBZ3bjGsIoGG6SON7Z_I,1097
+pipenv/vendor/docopt.py,sha256=RMZQ69gz2FLIcx-j8MV1lQYwliIwDkwZVKVA14VyzFQ,19946
+pipenv/vendor/dotenv/LICENSE,sha256=0nIJqz0WJ4Ko-OOHK5s1PEngksmqRnpkUiiDQH2NEDA,4600
+pipenv/vendor/dotenv/__init__.py,sha256=7Do7SaK79Arfb8Wkyfrn-7wCj2k8VkE6quTyz88a0xc,1339
+pipenv/vendor/dotenv/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/dotenv/__pycache__/cli.cpython-37.pyc,,
+pipenv/vendor/dotenv/__pycache__/compat.cpython-37.pyc,,
+pipenv/vendor/dotenv/__pycache__/ipython.cpython-37.pyc,,
+pipenv/vendor/dotenv/__pycache__/main.cpython-37.pyc,,
+pipenv/vendor/dotenv/__pycache__/parser.cpython-37.pyc,,
+pipenv/vendor/dotenv/__pycache__/version.cpython-37.pyc,,
+pipenv/vendor/dotenv/cli.py,sha256=Gxdqs9MajEi_3iMQfR-AqOOoPpgSecNlLZSXzIxfB1o,3971
+pipenv/vendor/dotenv/compat.py,sha256=9Qagb8xJeYEhgAs9lEVUkQ2FiSwzgC4jEtuRnR5CkE4,984
+pipenv/vendor/dotenv/ipython.py,sha256=Olsq1Q8qwEW1xwfTwlqaJ6tjXM7fIgexXltmAsoaTq4,1342
+pipenv/vendor/dotenv/main.py,sha256=dtMIU902ix1X8r7jHfwLgQwxSQONDja6dSymCH0icjA,9698
+pipenv/vendor/dotenv/parser.py,sha256=CpN4SPQfBKFB7-0ucbJ7HMyWa90spwnxz_ediogBZyQ,4994
+pipenv/vendor/dotenv/version.py,sha256=0C8KcY1dzs3hdkAre06v0NCQ0Uxcqv6g9a93bRcVLW0,23
+pipenv/vendor/dparse/LICENSE,sha256=ar0PbA_0X4CQeStmtJmu5WMr9t8_geMafO3DNpZatu4,1074
+pipenv/vendor/dparse/__init__.py,sha256=dZR0kQbTBcL7nqgLWHzVh40O-Wmf4s_eIDLmJBPSGxk,238
+pipenv/vendor/dparse/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/dparse/__pycache__/dependencies.cpython-37.pyc,,
+pipenv/vendor/dparse/__pycache__/errors.cpython-37.pyc,,
+pipenv/vendor/dparse/__pycache__/filetypes.cpython-37.pyc,,
+pipenv/vendor/dparse/__pycache__/parser.cpython-37.pyc,,
+pipenv/vendor/dparse/__pycache__/regex.cpython-37.pyc,,
+pipenv/vendor/dparse/__pycache__/updater.cpython-37.pyc,,
+pipenv/vendor/dparse/dependencies.py,sha256=M1epFONv2BLp0xTMNP-CTzW_YFTO1czlCss2YZCNViI,5393
+pipenv/vendor/dparse/errors.py,sha256=vcBrQrW2u28-EONL3Mzp28xdD3QMy7g-kLNvwTh52Dc,153
+pipenv/vendor/dparse/filetypes.py,sha256=QD0Hvj48A4CRHOxxXRxBLypU0vwzwEX8kFujuFVj6zI,238
+pipenv/vendor/dparse/parser.py,sha256=6ATTfgXD8e9rppyz6aj4JU_oqlQwyGNSjSeH43BW9W0,13931
+pipenv/vendor/dparse/regex.py,sha256=ZGpKdl1PeKJSfQeLJkooCICIkl4APVeJQCXCdezMOWE,1208
+pipenv/vendor/dparse/updater.py,sha256=AWkC9OjtpPyWyopi_G9CG1CMAWH9Oc_CBziCBlgXShk,4566
+pipenv/vendor/first.LICENSE,sha256=208CPZ5xeRSA0epEc2H9hyY-yqxdQgvjtbs2xy4HxcU,1059
+pipenv/vendor/first.py,sha256=ksF_-FyLX2MDIu4JLKv4X4zoQVwixNcyLNEQ8g29A4Q,1733
+pipenv/vendor/funcsigs/LICENSE,sha256=VZIptLaT2A_gh9UX98edSFfJZa3RgDFRLQmB78KHVfA,549
+pipenv/vendor/funcsigs/__init__.py,sha256=GV4YulgeGW1IDS3l4__glZnbTJolLD_UGAFAhSGWOC8,30390
+pipenv/vendor/funcsigs/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/funcsigs/__pycache__/version.cpython-37.pyc,,
+pipenv/vendor/funcsigs/version.py,sha256=Y3LSfRioSl2xch70pq_ULlvyECXyEtN3krVaWeGyaxk,22
+pipenv/vendor/idna/LICENSE.rst,sha256=QSAUQg0kc9ugYRfD1Nng7sqm3eDKMM2VH07CvjlCbzI,1565
+pipenv/vendor/idna/__init__.py,sha256=9Nt7xpyet3DmOrPUGooDdAwmHZZu1qUAy2EaJ93kGiQ,58
+pipenv/vendor/idna/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/idna/__pycache__/codec.cpython-37.pyc,,
+pipenv/vendor/idna/__pycache__/compat.cpython-37.pyc,,
+pipenv/vendor/idna/__pycache__/core.cpython-37.pyc,,
+pipenv/vendor/idna/__pycache__/idnadata.cpython-37.pyc,,
+pipenv/vendor/idna/__pycache__/intranges.cpython-37.pyc,,
+pipenv/vendor/idna/__pycache__/package_data.cpython-37.pyc,,
+pipenv/vendor/idna/__pycache__/uts46data.cpython-37.pyc,,
+pipenv/vendor/idna/codec.py,sha256=lvYb7yu7PhAqFaAIAdWcwgaWI2UmgseUua-1c0AsG0A,3299
+pipenv/vendor/idna/compat.py,sha256=R-h29D-6mrnJzbXxymrWUW7iZUvy-26TQwZ0ij57i4U,232
+pipenv/vendor/idna/core.py,sha256=Hy1RkJrrIQWW8kicqZ8vQT_GreYlAhkfopjESSzL3wk,11844
+pipenv/vendor/idna/idnadata.py,sha256=p1_KeD9BqT-sDGqMcGxhBWAOrYNrPxj5YvHya0ImFbU,41201
+pipenv/vendor/idna/intranges.py,sha256=TY1lpxZIQWEP6tNqjZkFA5hgoMWOj1OBmnUG8ihT87E,1749
+pipenv/vendor/idna/package_data.py,sha256=IjspS_rQQ_0HCGc0CaNhn3NXl3ohvRg7-_P0gAaSc-o,21
+pipenv/vendor/idna/uts46data.py,sha256=w9d1B5OESLSgr2tMx0svwoPBi0Qj0_7HRyL1Vq5axwg,201192
+pipenv/vendor/importlib_metadata/LICENSE,sha256=wNe6dAchmJ1VvVB8D9oTc-gHHadCuaSBAev36sYEM6U,571
+pipenv/vendor/importlib_metadata/__init__.py,sha256=DT7s8DxB5Audu6XruZByvEf43TwHt2pfFMz3J2jMjEA,18396
+pipenv/vendor/importlib_metadata/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/importlib_metadata/__pycache__/_compat.cpython-37.pyc,,
+pipenv/vendor/importlib_metadata/_compat.py,sha256=0ZGxEAdoFDtR7KX7lAHI1cmtuA6OliQv_anOgCX_JLI,4383
+pipenv/vendor/importlib_metadata/docs/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+pipenv/vendor/importlib_metadata/docs/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/importlib_metadata/docs/__pycache__/conf.cpython-37.pyc,,
+pipenv/vendor/importlib_metadata/docs/changelog.rst,sha256=QlRU7vNmoWyirjqKaE0HP99e3hYhvML2HQbQF2RP6tw,8062
+pipenv/vendor/importlib_metadata/docs/conf.py,sha256=m-b6Mju5gFkpSHh-lyJ4iwqf_8t4LjYYFRumtutQSZc,5578
+pipenv/vendor/importlib_metadata/docs/index.rst,sha256=rbXrDkLAKLIDccqME5u9CCMEfMKprqzQOkIOuwOnfz4,1907
+pipenv/vendor/importlib_metadata/docs/using.rst,sha256=uGcninlnvZWpCbeb-bEe8yyZX2VxrWxsgunJ6K4oC7w,9504
+pipenv/vendor/importlib_metadata/tests/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+pipenv/vendor/importlib_metadata/tests/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/importlib_metadata/tests/__pycache__/fixtures.cpython-37.pyc,,
+pipenv/vendor/importlib_metadata/tests/__pycache__/test_api.cpython-37.pyc,,
+pipenv/vendor/importlib_metadata/tests/__pycache__/test_integration.cpython-37.pyc,,
+pipenv/vendor/importlib_metadata/tests/__pycache__/test_main.cpython-37.pyc,,
+pipenv/vendor/importlib_metadata/tests/__pycache__/test_zip.cpython-37.pyc,,
+pipenv/vendor/importlib_metadata/tests/data/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+pipenv/vendor/importlib_metadata/tests/data/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/importlib_metadata/tests/fixtures.py,sha256=sRB-Eavik2ebEGAtXlyTJ98cFodj_tQh6xg0AfI2grs,5188
+pipenv/vendor/importlib_metadata/tests/test_api.py,sha256=YMAGTsRENrtvpw2CSLmRndJMBeT4q_M0GSe-QsnnMZ4,5544
+pipenv/vendor/importlib_metadata/tests/test_integration.py,sha256=vhbAi9zmaOa8b0OWSZGETWpn5542wXabfDVPd2lcIaY,1275
+pipenv/vendor/importlib_metadata/tests/test_main.py,sha256=RTd2cuCayAsYANDRPmddDa6zv8s-9X8FICNvvg_A9_s,8114
+pipenv/vendor/importlib_metadata/tests/test_zip.py,sha256=act09AAISahc6b4nFWmelCB8XUapCzSjDUWTkfGogzI,2528
+pipenv/vendor/importlib_resources/LICENSE,sha256=uWRjFdYGataJX2ziXk048ItUglQmjng3GWBALaWA36U,568
+pipenv/vendor/importlib_resources/__init__.py,sha256=ynIjcZEryrUKC-9ca5OQJsn6O4mkptpQwFqlnV2OOfk,1016
+pipenv/vendor/importlib_resources/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/importlib_resources/__pycache__/_common.cpython-37.pyc,,
+pipenv/vendor/importlib_resources/__pycache__/_compat.cpython-37.pyc,,
+pipenv/vendor/importlib_resources/__pycache__/_py2.cpython-37.pyc,,
+pipenv/vendor/importlib_resources/__pycache__/_py3.cpython-37.pyc,,
+pipenv/vendor/importlib_resources/__pycache__/abc.cpython-37.pyc,,
+pipenv/vendor/importlib_resources/__pycache__/trees.cpython-37.pyc,,
+pipenv/vendor/importlib_resources/_common.py,sha256=ahLUVuyDtkLeCLYc_AjmiLzrXhxRvk1MUKwVrQz1wyQ,1865
+pipenv/vendor/importlib_resources/_compat.py,sha256=sneIO3N5I5sSJE2zV8Jk8LHhjdTsoruS0ex8qk1JuSc,1691
+pipenv/vendor/importlib_resources/_py2.py,sha256=76vlllAhJL4xwI9PHGTXwqhwisUDEY_Dwk3uOIYVTqQ,5077
+pipenv/vendor/importlib_resources/_py3.py,sha256=c3uQ8D8-RBQB_QBNWJdshrN4Usi_aHAyVjIngTT20ck,7179
+pipenv/vendor/importlib_resources/abc.py,sha256=hQKduyJ1MpQuVdv_xMhG8rxFhx5Lkxnsvoyz-p5Ix8s,3893
+pipenv/vendor/importlib_resources/tests/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+pipenv/vendor/importlib_resources/tests/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/importlib_resources/tests/__pycache__/test_files.cpython-37.pyc,,
+pipenv/vendor/importlib_resources/tests/__pycache__/test_open.cpython-37.pyc,,
+pipenv/vendor/importlib_resources/tests/__pycache__/test_path.cpython-37.pyc,,
+pipenv/vendor/importlib_resources/tests/__pycache__/test_read.cpython-37.pyc,,
+pipenv/vendor/importlib_resources/tests/__pycache__/test_resource.cpython-37.pyc,,
+pipenv/vendor/importlib_resources/tests/__pycache__/util.cpython-37.pyc,,
+pipenv/vendor/importlib_resources/tests/data01/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+pipenv/vendor/importlib_resources/tests/data01/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/importlib_resources/tests/data01/subdirectory/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+pipenv/vendor/importlib_resources/tests/data01/subdirectory/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/importlib_resources/tests/data02/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+pipenv/vendor/importlib_resources/tests/data02/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/importlib_resources/tests/data02/one/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+pipenv/vendor/importlib_resources/tests/data02/one/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/importlib_resources/tests/data02/two/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+pipenv/vendor/importlib_resources/tests/data02/two/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/importlib_resources/tests/data03/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+pipenv/vendor/importlib_resources/tests/data03/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/importlib_resources/tests/test_files.py,sha256=91rf4C74_aJsKNSt-a-03slVpY9QSAuCbogFWnsaPjE,1017
+pipenv/vendor/importlib_resources/tests/test_open.py,sha256=yDXmTGXQspByj6WU0prnoVwab1yWWEA3fwz_XIx7TQU,2288
+pipenv/vendor/importlib_resources/tests/test_path.py,sha256=NOK3NSr2avsj4WkvGB3ufqQKRjw6Zyror51agygq7Y4,1252
+pipenv/vendor/importlib_resources/tests/test_read.py,sha256=DpA7tzxSQlU0_YQuWibB3E5PDL9fQUdzeKoEUGnAx78,2046
+pipenv/vendor/importlib_resources/tests/test_resource.py,sha256=X77DzU2BRoM6d59iEh74zDHHw3pKOBGLCg3lP3dH4BI,6467
+pipenv/vendor/importlib_resources/tests/util.py,sha256=f0RZU-RkEkybJjXRd7C5HcWMsoLFRWJL4FIUF1CJ2wo,6980
+pipenv/vendor/importlib_resources/tests/zipdata01/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+pipenv/vendor/importlib_resources/tests/zipdata01/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/importlib_resources/tests/zipdata02/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+pipenv/vendor/importlib_resources/tests/zipdata02/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/importlib_resources/trees.py,sha256=U3FlQSI5--eF4AdzOjBvW4xnjL21OFX8ivk82Quwv_M,117
+pipenv/vendor/iso8601/LICENSE,sha256=EW02jRSozwBhAnyUTGDuILR2zkKBSBin1ic5aQZ2HxY,1065
+pipenv/vendor/iso8601/__init__.py,sha256=2fxA8Xny1V5PTJR49nA43wY6rHrMKswvqblfGyngt2k,23
+pipenv/vendor/iso8601/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/iso8601/__pycache__/iso8601.cpython-37.pyc,,
+pipenv/vendor/iso8601/__pycache__/test_iso8601.cpython-37.pyc,,
+pipenv/vendor/iso8601/iso8601.py,sha256=_Gua5DZ0c6kdpiRUrdrpB6-yAO6LltpcGIVzy7u8yi8,6670
+pipenv/vendor/iso8601/test_iso8601.py,sha256=SKjKlgkKJ6Dej0hhcWOIYskzDM3cAFztyka-AoJZ1iw,7802
+pipenv/vendor/jinja2/LICENSE.rst,sha256=O0nc7kEF6ze6wQ-vG-JgQI_oXSUrjp3y4JefweCUQ3s,1475
+pipenv/vendor/jinja2/__init__.py,sha256=0QCM_jKKDM10yzSdHRVV4mQbCbDqf0GN0GirAqibn9Y,1549
+pipenv/vendor/jinja2/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/jinja2/__pycache__/_compat.cpython-37.pyc,,
+pipenv/vendor/jinja2/__pycache__/_identifier.cpython-37.pyc,,
+pipenv/vendor/jinja2/__pycache__/asyncfilters.cpython-37.pyc,,
+pipenv/vendor/jinja2/__pycache__/asyncsupport.cpython-37.pyc,,
+pipenv/vendor/jinja2/__pycache__/bccache.cpython-37.pyc,,
+pipenv/vendor/jinja2/__pycache__/compiler.cpython-37.pyc,,
+pipenv/vendor/jinja2/__pycache__/constants.cpython-37.pyc,,
+pipenv/vendor/jinja2/__pycache__/debug.cpython-37.pyc,,
+pipenv/vendor/jinja2/__pycache__/defaults.cpython-37.pyc,,
+pipenv/vendor/jinja2/__pycache__/environment.cpython-37.pyc,,
+pipenv/vendor/jinja2/__pycache__/exceptions.cpython-37.pyc,,
+pipenv/vendor/jinja2/__pycache__/ext.cpython-37.pyc,,
+pipenv/vendor/jinja2/__pycache__/filters.cpython-37.pyc,,
+pipenv/vendor/jinja2/__pycache__/idtracking.cpython-37.pyc,,
+pipenv/vendor/jinja2/__pycache__/lexer.cpython-37.pyc,,
+pipenv/vendor/jinja2/__pycache__/loaders.cpython-37.pyc,,
+pipenv/vendor/jinja2/__pycache__/meta.cpython-37.pyc,,
+pipenv/vendor/jinja2/__pycache__/nativetypes.cpython-37.pyc,,
+pipenv/vendor/jinja2/__pycache__/nodes.cpython-37.pyc,,
+pipenv/vendor/jinja2/__pycache__/optimizer.cpython-37.pyc,,
+pipenv/vendor/jinja2/__pycache__/parser.cpython-37.pyc,,
+pipenv/vendor/jinja2/__pycache__/runtime.cpython-37.pyc,,
+pipenv/vendor/jinja2/__pycache__/sandbox.cpython-37.pyc,,
+pipenv/vendor/jinja2/__pycache__/tests.cpython-37.pyc,,
+pipenv/vendor/jinja2/__pycache__/utils.cpython-37.pyc,,
+pipenv/vendor/jinja2/__pycache__/visitor.cpython-37.pyc,,
+pipenv/vendor/jinja2/_compat.py,sha256=B6Se8HjnXVpzz9-vfHejn-DV2NjaVK-Iewupc5kKlu8,3191
+pipenv/vendor/jinja2/_identifier.py,sha256=EdgGJKi7O1yvr4yFlvqPNEqV6M1qHyQr8Gt8GmVTKVM,1775
+pipenv/vendor/jinja2/asyncfilters.py,sha256=XJtYXTxFvcJ5xwk6SaDL4S0oNnT0wPYvXBCSzc482fI,4250
+pipenv/vendor/jinja2/asyncsupport.py,sha256=ZBFsDLuq3Gtji3Ia87lcyuDbqaHZJRdtShZcqwpFnSQ,7209
+pipenv/vendor/jinja2/bccache.py,sha256=3Pmp4jo65M9FQuIxdxoDBbEDFwe4acDMQf77nEJfrHA,12139
+pipenv/vendor/jinja2/compiler.py,sha256=Ta9W1Lit542wItAHXlDcg0sEOsFDMirCdlFPHAurg4o,66284
+pipenv/vendor/jinja2/constants.py,sha256=RR1sTzNzUmKco6aZicw4JpQpJGCuPuqm1h1YmCNUEFY,1458
+pipenv/vendor/jinja2/debug.py,sha256=neR7GIGGjZH3_ILJGVUYy3eLQCCaWJMXOb7o0kGInWc,8529
+pipenv/vendor/jinja2/defaults.py,sha256=85B6YUUCyWPSdrSeVhcqFVuu_bHUAQXeey--FIwSeVQ,1126
+pipenv/vendor/jinja2/environment.py,sha256=XDSLKc4SqNLMOwTSq3TbWEyA5WyXfuLuVD0wAVjEFwM,50629
+pipenv/vendor/jinja2/exceptions.py,sha256=VjNLawcmf2ODffqVMCQK1cRmvFaUfQWF4u8ouP3QPcE,5425
+pipenv/vendor/jinja2/ext.py,sha256=AtwL5O5enT_L3HR9-oBvhGyUTdGoyaqG_ICtnR_EVd4,26441
+pipenv/vendor/jinja2/filters.py,sha256=_RpPgAlgIj7ExvyDzcHAC3B36cocfWK-1TEketbNeM0,41415
+pipenv/vendor/jinja2/idtracking.py,sha256=J3O4VHsrbf3wzwiBc7Cro26kHb6_5kbULeIOzocchIU,9211
+pipenv/vendor/jinja2/lexer.py,sha256=nUFLRKhhKmmEWkLI65nQePgcQs7qsRdjVYZETMt_v0g,30331
+pipenv/vendor/jinja2/loaders.py,sha256=C-fST_dmFjgWkp0ZuCkrgICAoOsoSIF28wfAFink0oU,17666
+pipenv/vendor/jinja2/meta.py,sha256=QjyYhfNRD3QCXjBJpiPl9KgkEkGXJbAkCUq4-Ur10EQ,4131
+pipenv/vendor/jinja2/nativetypes.py,sha256=Ul__gtVw4xH-0qvUvnCNHedQeNDwmEuyLJztzzSPeRg,2753
+pipenv/vendor/jinja2/nodes.py,sha256=Mk1oJPVgIjnQw9WOqILvcu3rLepcFZ0ahxQm2mbwDwc,31095
+pipenv/vendor/jinja2/optimizer.py,sha256=gQLlMYzvQhluhzmAIFA1tXS0cwgWYOjprN-gTRcHVsc,1457
+pipenv/vendor/jinja2/parser.py,sha256=fcfdqePNTNyvosIvczbytVA332qpsURvYnCGcjDHSkA,35660
+pipenv/vendor/jinja2/runtime.py,sha256=0y-BRyIEZ9ltByL2Id6GpHe1oDRQAwNeQvI0SKobNMw,30618
+pipenv/vendor/jinja2/sandbox.py,sha256=knayyUvXsZ-F0mk15mO2-ehK9gsw04UhB8td-iUOtLc,17127
+pipenv/vendor/jinja2/tests.py,sha256=iO_Y-9Vo60zrVe1lMpSl5sKHqAxe2leZHC08OoZ8K24,4799
+pipenv/vendor/jinja2/utils.py,sha256=OoVMlQe9S2-lWT6jJbTu9tDuDvGNyWUhHDcE51i5_Do,22522
+pipenv/vendor/jinja2/visitor.py,sha256=DUHupl0a4PGp7nxRtZFttUzAi1ccxzqc2hzetPYUz8U,3240
+pipenv/vendor/markupsafe/LICENSE.rst,sha256=SJqOEQhQntmKN7uYPhHg9-HTHwvY-Zp5yESOf_N9B-o,1475
+pipenv/vendor/markupsafe/__init__.py,sha256=oTblO5f9KFM-pvnq9bB0HgElnqkJyqHnFN1Nx2NIvnY,10126
+pipenv/vendor/markupsafe/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/markupsafe/__pycache__/_compat.cpython-37.pyc,,
+pipenv/vendor/markupsafe/__pycache__/_constants.cpython-37.pyc,,
+pipenv/vendor/markupsafe/__pycache__/_native.cpython-37.pyc,,
+pipenv/vendor/markupsafe/_compat.py,sha256=uEW1ybxEjfxIiuTbRRaJpHsPFf4yQUMMKaPgYEC5XbU,558
+pipenv/vendor/markupsafe/_constants.py,sha256=zo2ajfScG-l1Sb_52EP3MlDCqO7Y1BVHUXXKRsVDRNk,4690
+pipenv/vendor/markupsafe/_native.py,sha256=d-8S_zzYt2y512xYcuSxq0NeG2DUUvG80wVdTn-4KI8,1873
+pipenv/vendor/markupsafe/_speedups.c,sha256=k0fzEIK3CP6MmMqeY0ob43TP90mVN0DTyn7BAl3RqSg,9884
+pipenv/vendor/more_itertools/LICENSE,sha256=CfHIyelBrz5YTVlkHqm4fYPAyw_QB-te85Gn4mQ8GkY,1053
+pipenv/vendor/more_itertools/__init__.py,sha256=S-n6S9N3UplqU3p-7AV-1Znl6yJwuXsJtqrlEq9tOUw,87
+pipenv/vendor/more_itertools/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/more_itertools/__pycache__/more.cpython-37.pyc,,
+pipenv/vendor/more_itertools/__pycache__/recipes.cpython-37.pyc,,
+pipenv/vendor/more_itertools/more.py,sha256=0jauZmIafxcPyqi2nE9Es5SWxuOtQgGi81ZxDdAkxJc,74126
+pipenv/vendor/more_itertools/recipes.py,sha256=fRtikenQ80JePTOwaagYJUdOsOOKMKIqv62b0-gDM4c,15474
+pipenv/vendor/more_itertools/tests/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+pipenv/vendor/more_itertools/tests/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/more_itertools/tests/__pycache__/test_more.cpython-37.pyc,,
+pipenv/vendor/more_itertools/tests/__pycache__/test_recipes.cpython-37.pyc,,
+pipenv/vendor/more_itertools/tests/test_more.py,sha256=Me7hn-TtltxRSPc3kyd3bRTS3sUV4yABk5fGUUlwWTQ,79615
+pipenv/vendor/more_itertools/tests/test_recipes.py,sha256=0BR8K3DCvutX0uJ40EQx8E53mUnhfXnGG4OnN_6Z2Qo,19830
+pipenv/vendor/orderedmultidict/LICENSE.md,sha256=MSukfviVZV_I8EazvtQHasyCIv8_F5MrMviKvXb5Hes,1271
+pipenv/vendor/orderedmultidict/__init__.py,sha256=wbvDIOFXcLVB_MhQUju7aNFYKq6YJqiON3TelJAv87o,499
+pipenv/vendor/orderedmultidict/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/orderedmultidict/__pycache__/__version__.cpython-37.pyc,,
+pipenv/vendor/orderedmultidict/__pycache__/itemlist.cpython-37.pyc,,
+pipenv/vendor/orderedmultidict/__pycache__/orderedmultidict.cpython-37.pyc,,
+pipenv/vendor/orderedmultidict/__version__.py,sha256=ErkVZf91C7Rmk3Zo92D8acFHqGXMbI80DuKgC8f_w_w,423
+pipenv/vendor/orderedmultidict/itemlist.py,sha256=MpadCr2DpFfkgTcNCrdm-YOBmDxgT_ZGNSKKZl1H9Zk,4483
+pipenv/vendor/orderedmultidict/orderedmultidict.py,sha256=ve1tVNGEYyJGnqN5xVRSGiO1AUAohHZsB76ZK4vCJuA,29568
+pipenv/vendor/packaging/LICENSE,sha256=ytHvW9NA1z4HS6YU0m996spceUDD2MNIUuZcSQlobEg,197
+pipenv/vendor/packaging/LICENSE.APACHE,sha256=DVQuDIgE45qn836wDaWnYhSdxoLXgpRRKH4RuTjpRZQ,10174
+pipenv/vendor/packaging/LICENSE.BSD,sha256=tw5-m3QvHMb5SLNMFqo5_-zpQZY2S8iP8NIYDwAo-sU,1344
+pipenv/vendor/packaging/__about__.py,sha256=y-K51xPSysxvOfTjAb074yqOZfDeX5qSID0ZEbEb9cE,744
+pipenv/vendor/packaging/__init__.py,sha256=6enbp5XgRfjBjsI9-bn00HjHf5TH21PDMOKkJW8xw-w,562
+pipenv/vendor/packaging/__pycache__/__about__.cpython-37.pyc,,
+pipenv/vendor/packaging/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/packaging/__pycache__/_compat.cpython-37.pyc,,
+pipenv/vendor/packaging/__pycache__/_structures.cpython-37.pyc,,
+pipenv/vendor/packaging/__pycache__/_typing.cpython-37.pyc,,
+pipenv/vendor/packaging/__pycache__/markers.cpython-37.pyc,,
+pipenv/vendor/packaging/__pycache__/requirements.cpython-37.pyc,,
+pipenv/vendor/packaging/__pycache__/specifiers.cpython-37.pyc,,
+pipenv/vendor/packaging/__pycache__/tags.cpython-37.pyc,,
+pipenv/vendor/packaging/__pycache__/utils.cpython-37.pyc,,
+pipenv/vendor/packaging/__pycache__/version.cpython-37.pyc,,
+pipenv/vendor/packaging/_compat.py,sha256=Z-PwchK0cREbaRGF5MZP8LEv8JkC-qydn2FRrtjeixk,1138
+pipenv/vendor/packaging/_structures.py,sha256=ozkCX8Q8f2qE1Eic3YiQ4buDVfgz2iYevY9e7R2y3iY,2022
+pipenv/vendor/packaging/_typing.py,sha256=bmvfRSqh5zzL6KjhW57nQIqG6YGJZk6XXZovGG4U4J4,1437
+pipenv/vendor/packaging/markers.py,sha256=CkMzNWbaDNPxMsWK-JtwBkDFmBfp5gmfxtWN16yZgB8,9465
+pipenv/vendor/packaging/requirements.py,sha256=9ZvGd-VcgPPoewo821s7UmtmlBMRX3v4irHJDhOESBw,4865
+pipenv/vendor/packaging/specifiers.py,sha256=Nz8bnFp53cQInmRGZy50QXlIi2tkDXMfRuGyGps2IRE,31314
+pipenv/vendor/packaging/tags.py,sha256=SCrw-jC3h0ymam6QXDX5ZqgvRcMNq_cQD55gFnT56Xg,23704
+pipenv/vendor/packaging/utils.py,sha256=v5Wk8B7gUL13Rzed6NNhCZlutPQT7jNV-7hr-WOtacU,1700
+pipenv/vendor/packaging/version.py,sha256=qRdNN0_XuPFOJ3fut8ehzxJrNYtBzqF8ZtagEvgNUUM,15480
+pipenv/vendor/parse.LICENSE,sha256=LMmUL-P1KmacH7tOC66aJzANVlZKOC6VSEXDJWxMq-I,1085
+pipenv/vendor/parse.py,sha256=hG3CFZAFK7wno9f-FlEcwOrEZvznEeRtVDryNwm3u44,49564
+pipenv/vendor/passa/LICENSE,sha256=a0jIGs4i1teROIrGozAPvfoeDlTfuzUEKIBvQqZLC_o,781
+pipenv/vendor/passa/__init__.py,sha256=R6Os_bAdhx8CQoVopTFS76pQ76ousPQEy53zgZlR868,84
+pipenv/vendor/passa/__main__.py,sha256=lFB1EIRtM22JUQ9aSDoNXO2Y84qNCSTb4VYZiO1__yc,85
+pipenv/vendor/passa/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/passa/__pycache__/__main__.cpython-37.pyc,,
+pipenv/vendor/passa/actions/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+pipenv/vendor/passa/actions/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/passa/actions/__pycache__/add.cpython-37.pyc,,
+pipenv/vendor/passa/actions/__pycache__/clean.cpython-37.pyc,,
+pipenv/vendor/passa/actions/__pycache__/freeze.cpython-37.pyc,,
+pipenv/vendor/passa/actions/__pycache__/init.cpython-37.pyc,,
+pipenv/vendor/passa/actions/__pycache__/install.cpython-37.pyc,,
+pipenv/vendor/passa/actions/__pycache__/lock.cpython-37.pyc,,
+pipenv/vendor/passa/actions/__pycache__/remove.cpython-37.pyc,,
+pipenv/vendor/passa/actions/__pycache__/sync.cpython-37.pyc,,
+pipenv/vendor/passa/actions/__pycache__/upgrade.cpython-37.pyc,,
+pipenv/vendor/passa/actions/add.py,sha256=P4FiqWfs3uX3ni_dCxnPXm9clhJvSG0ydrwMX8HGpUs,1497
+pipenv/vendor/passa/actions/clean.py,sha256=zOwIaeTJMsz6-a-rH1XVxBSD_A67-LPN-TIYQ-bstD8,415
+pipenv/vendor/passa/actions/freeze.py,sha256=ogIh001dQIBpU279-Y-oHZXTXbfmScFZsa-LA-BsGsE,2465
+pipenv/vendor/passa/actions/init.py,sha256=g4IzKgJsqs3AALPys1dxG9TPQ2ThswgiMNuosPDKPrQ,1948
+pipenv/vendor/passa/actions/install.py,sha256=ucpyluDNJjtPIkig9fPjPvzJVUpgchdnd_OLzfl9NWI,841
+pipenv/vendor/passa/actions/lock.py,sha256=Cxw6HZV6ucnLejmzAIrATQsxCz1WgroHIYuBsD3_2zQ,407
+pipenv/vendor/passa/actions/remove.py,sha256=iIRYYFFNX4m5_AEtXmUvHXdiwQ-2dhY8yEE5aaZfTbA,946
+pipenv/vendor/passa/actions/sync.py,sha256=SzsDV2fuHgQcTJIFC90Un6w3soksH3fHPOev2JaUQgw,492
+pipenv/vendor/passa/actions/upgrade.py,sha256=gK1UWl17eH-7qsnYaBkdr2CRo-LzfsfeU8yNoyrP4XA,1419
+pipenv/vendor/passa/cli/__init__.py,sha256=wh3CkpEiyzSMz2Mt8yGbpysUMRUCttEwcM8PtLVOGFs,1238
+pipenv/vendor/passa/cli/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/passa/cli/__pycache__/_base.cpython-37.pyc,,
+pipenv/vendor/passa/cli/__pycache__/add.cpython-37.pyc,,
+pipenv/vendor/passa/cli/__pycache__/clean.cpython-37.pyc,,
+pipenv/vendor/passa/cli/__pycache__/freeze.cpython-37.pyc,,
+pipenv/vendor/passa/cli/__pycache__/init.cpython-37.pyc,,
+pipenv/vendor/passa/cli/__pycache__/install.cpython-37.pyc,,
+pipenv/vendor/passa/cli/__pycache__/lock.cpython-37.pyc,,
+pipenv/vendor/passa/cli/__pycache__/options.cpython-37.pyc,,
+pipenv/vendor/passa/cli/__pycache__/remove.cpython-37.pyc,,
+pipenv/vendor/passa/cli/__pycache__/sync.cpython-37.pyc,,
+pipenv/vendor/passa/cli/__pycache__/upgrade.cpython-37.pyc,,
+pipenv/vendor/passa/cli/_base.py,sha256=nE9PrvwR_JWBo3NgvinsFfVSNsxlwuF0qg1eo_2jCfQ,1473
+pipenv/vendor/passa/cli/add.py,sha256=uOYBu3BqvMKq50MyMnwBE-S4CQzaK5_fp1VdrgqhkuM,765
+pipenv/vendor/passa/cli/clean.py,sha256=jfMQle7sZkj-drrxx8FXdCOkmyvTL1L-8uZ98oNZhH0,525
+pipenv/vendor/passa/cli/freeze.py,sha256=G7RF-IzhaBmufVJk9VJgqDEwas-CbpHJCM7ggIeJjNA,660
+pipenv/vendor/passa/cli/init.py,sha256=TPsJB6hjkRZjfb_MBEqjlUzi5FfU9JrA3tYjCfr4iEg,822
+pipenv/vendor/passa/cli/install.py,sha256=OcHTZVqUSGNMm7SerX3EbwcEpilqH4mD_uLc9TSlaZE,598
+pipenv/vendor/passa/cli/lock.py,sha256=VqXdqAEvuehO2byR5om6seEmZVMweYeCboT46c8IHbU,380
+pipenv/vendor/passa/cli/options.py,sha256=3oVuERisq0931PBZcO46N7P16KjPOmUCM9tCQbTSMMA,4878
+pipenv/vendor/passa/cli/remove.py,sha256=jv-M7kqF2t9am1PKYPy7CwxN-9tvyaMFPB_x7W2NfPw,586
+pipenv/vendor/passa/cli/sync.py,sha256=34kqPEOG1L5PpnPrJVYxxRfGSWlp04NYGcbv2WhZgHc,506
+pipenv/vendor/passa/cli/upgrade.py,sha256=QDhr_lgWIFxrTg8j9YdH96DMY8_l8fwmJ3qwq9f6z6s,614
+pipenv/vendor/passa/internals/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+pipenv/vendor/passa/internals/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/passa/internals/__pycache__/_pip.cpython-37.pyc,,
+pipenv/vendor/passa/internals/__pycache__/_pip_shims.cpython-37.pyc,,
+pipenv/vendor/passa/internals/__pycache__/candidates.cpython-37.pyc,,
+pipenv/vendor/passa/internals/__pycache__/dependencies.cpython-37.pyc,,
+pipenv/vendor/passa/internals/__pycache__/hashes.cpython-37.pyc,,
+pipenv/vendor/passa/internals/__pycache__/markers.cpython-37.pyc,,
+pipenv/vendor/passa/internals/__pycache__/reporters.cpython-37.pyc,,
+pipenv/vendor/passa/internals/__pycache__/specifiers.cpython-37.pyc,,
+pipenv/vendor/passa/internals/__pycache__/traces.cpython-37.pyc,,
+pipenv/vendor/passa/internals/__pycache__/utils.cpython-37.pyc,,
+pipenv/vendor/passa/internals/_pip.py,sha256=9uUnDcUPS9Cl7pzkeuUCnMOCEIGOfs3K5572VvgsSdg,12764
+pipenv/vendor/passa/internals/_pip_shims.py,sha256=ueFq112HNmCfQHsKv5r4DlE8p04sRX9o2zNuj070-h4,2025
+pipenv/vendor/passa/internals/candidates.py,sha256=700aMd8KwWpH7wjXkCexWatnPrOVa9o4_k0aBsS8wtg,3130
+pipenv/vendor/passa/internals/dependencies.py,sha256=6vk9A4wwk_12pw6PJdtSH1agkB1r0SYbcDI8e5xvSoQ,9096
+pipenv/vendor/passa/internals/hashes.py,sha256=5yChxvQGlXLtC5jenjrYwwPzrO7tSauSk-qS-RpZqwI,1516
+pipenv/vendor/passa/internals/markers.py,sha256=crCh_6cXnhvhKyAo9ButF_h5jd4uyEGggkkc5dzQyG0,3426
+pipenv/vendor/passa/internals/reporters.py,sha256=UnTHQB0KX0y_YxVOjyhfLp6lNPpML0JYR0c54aVVYoM,2682
+pipenv/vendor/passa/internals/specifiers.py,sha256=-FyOFKfAMRJnV-mKDP7utOS9qyqH7NrXgKrnGqL8c9U,4669
+pipenv/vendor/passa/internals/traces.py,sha256=na0IPt2pwPxNNSdzzXEU1ECkZygcoYsuxYrk7bKVeNI,1261
+pipenv/vendor/passa/internals/utils.py,sha256=sozc5yaLpEKCbwIrNHojBoUFHzS-Zpu-FwaEz437Ik0,3469
+pipenv/vendor/passa/models/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+pipenv/vendor/passa/models/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/passa/models/__pycache__/caches.cpython-37.pyc,,
+pipenv/vendor/passa/models/__pycache__/lockers.cpython-37.pyc,,
+pipenv/vendor/passa/models/__pycache__/metadata.cpython-37.pyc,,
+pipenv/vendor/passa/models/__pycache__/projects.cpython-37.pyc,,
+pipenv/vendor/passa/models/__pycache__/providers.cpython-37.pyc,,
+pipenv/vendor/passa/models/__pycache__/synchronizers.cpython-37.pyc,,
+pipenv/vendor/passa/models/caches.py,sha256=-WsUKhj_I2HHh44jegkeMxFvqMuEn2mvAPbZ4jX62D0,6819
+pipenv/vendor/passa/models/lockers.py,sha256=GsPQxhpnZa2buILZ4O5E3aoZxlBRII6DPEIka9rjBDg,7211
+pipenv/vendor/passa/models/metadata.py,sha256=PiPmoVgoy8o8xZaYlpuwyxq__4-xfaaGOIwTJj3TIss,5680
+pipenv/vendor/passa/models/projects.py,sha256=Pfam9cjeXttZw-ADnbmoaC5HQ56cQYmq3hYEMxB1HhE,7773
+pipenv/vendor/passa/models/providers.py,sha256=Cby393yLHJUIP_O_kkgaUZue0b8LevfA11fZHF5hmZ4,8586
+pipenv/vendor/passa/models/synchronizers.py,sha256=egm9QZWX7s0WnLWtINb_yi4HhcYrX4L2PxJbuL4VQzg,6885
+pipenv/vendor/passa/operations/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+pipenv/vendor/passa/operations/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/passa/operations/__pycache__/lock.cpython-37.pyc,,
+pipenv/vendor/passa/operations/__pycache__/sync.cpython-37.pyc,,
+pipenv/vendor/passa/operations/lock.py,sha256=-8tDjCIY-vUzL-TQyyBcfZCDWejSiVQzN8P43Ok0IV8,879
+pipenv/vendor/passa/operations/sync.py,sha256=FvgX64JkesU-pSSSIL6FokiTdJRo3DA5HomYK9m2e2w,643
+pipenv/vendor/pathlib2/LICENSE.rst,sha256=-OAvGgfkxvxZpL7oMd3eJrlwZBBcQjueJDQPNaqoAmI,1152
+pipenv/vendor/pathlib2/__init__.py,sha256=NBfu5wacps1y1YtlXVSPJ8FbE4WtIXucrp5uOYNOO-U,59133
+pipenv/vendor/pathlib2/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/pep517/LICENSE,sha256=GyKwSbUmfW38I6Z79KhNjsBLn9-xpR02DkK0NCyLQVQ,1081
+pipenv/vendor/pep517/__init__.py,sha256=r5uA106NGJa3slspaD2m32aFpFUiZX-mZ9vIlzAEOp4,84
+pipenv/vendor/pep517/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/pep517/__pycache__/_in_process.cpython-37.pyc,,
+pipenv/vendor/pep517/__pycache__/build.cpython-37.pyc,,
+pipenv/vendor/pep517/__pycache__/check.cpython-37.pyc,,
+pipenv/vendor/pep517/__pycache__/colorlog.cpython-37.pyc,,
+pipenv/vendor/pep517/__pycache__/compat.cpython-37.pyc,,
+pipenv/vendor/pep517/__pycache__/dirtools.cpython-37.pyc,,
+pipenv/vendor/pep517/__pycache__/envbuild.cpython-37.pyc,,
+pipenv/vendor/pep517/__pycache__/meta.cpython-37.pyc,,
+pipenv/vendor/pep517/__pycache__/wrappers.cpython-37.pyc,,
+pipenv/vendor/pep517/_in_process.py,sha256=XrKOTURJdia5R7i3i_OQmS89LASFXE3HQXfX63qZBIE,8438
+pipenv/vendor/pep517/build.py,sha256=WqM0-X4KyzY566qxGf3FeaYc1hw95H7YP0ElZ1zuTb0,3318
+pipenv/vendor/pep517/check.py,sha256=ST02kRWBrRMOxgnRm9clw18Q2X7sJGaD4j3h6GmBhJ8,5949
+pipenv/vendor/pep517/colorlog.py,sha256=Tk9AuYm_cLF3BKTBoSTJt9bRryn0aFojIQOwbfVUTxQ,4098
+pipenv/vendor/pep517/compat.py,sha256=M-5s4VNp8rjyT76ZZ_ibnPD44DYVzSQlyCEHayjtDPw,780
+pipenv/vendor/pep517/dirtools.py,sha256=2mkAkAL0mRz_elYFjRKuekTJVipH1zTn4tbf1EDev84,1129
+pipenv/vendor/pep517/envbuild.py,sha256=K4dIGAbkXf3RoQX_9RFpZvMvPrVSHtcbH7o9VSrNnlM,6024
+pipenv/vendor/pep517/meta.py,sha256=8mnM5lDnT4zXQpBTliJbRGfesH7iioHwozbDxALPS9Y,2463
+pipenv/vendor/pep517/wrappers.py,sha256=yFU4Lp7TIYbmuVOTY-pXnlyGZ3F_grIi-JlLkpGN8Gk,10783
+pipenv/vendor/pexpect/ANSI.py,sha256=aA-3tdXz_FZ4G7PAqFZi5g1KBGQ6PzJzS0gm3ALZKZw,12177
+pipenv/vendor/pexpect/FSM.py,sha256=tluiyUGMyIH3q_wLG6Ak1NZVuXUAGNDjq6k6BK1q8RY,13419
+pipenv/vendor/pexpect/LICENSE,sha256=Skg64cTcc4psi3P-tJB04YNdoCq1qmhvJnUCmQb6Nk0,987
+pipenv/vendor/pexpect/__init__.py,sha256=xF4qylJdK-FRy40tmhAXu99fV9ewFasxTH3DSgoZjzQ,3902
+pipenv/vendor/pexpect/__pycache__/ANSI.cpython-37.pyc,,
+pipenv/vendor/pexpect/__pycache__/FSM.cpython-37.pyc,,
+pipenv/vendor/pexpect/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/pexpect/__pycache__/_async.cpython-37.pyc,,
+pipenv/vendor/pexpect/__pycache__/exceptions.cpython-37.pyc,,
+pipenv/vendor/pexpect/__pycache__/expect.cpython-37.pyc,,
+pipenv/vendor/pexpect/__pycache__/fdpexpect.cpython-37.pyc,,
+pipenv/vendor/pexpect/__pycache__/popen_spawn.cpython-37.pyc,,
+pipenv/vendor/pexpect/__pycache__/pty_spawn.cpython-37.pyc,,
+pipenv/vendor/pexpect/__pycache__/pxssh.cpython-37.pyc,,
+pipenv/vendor/pexpect/__pycache__/replwrap.cpython-37.pyc,,
+pipenv/vendor/pexpect/__pycache__/run.cpython-37.pyc,,
+pipenv/vendor/pexpect/__pycache__/screen.cpython-37.pyc,,
+pipenv/vendor/pexpect/__pycache__/spawnbase.cpython-37.pyc,,
+pipenv/vendor/pexpect/__pycache__/utils.cpython-37.pyc,,
+pipenv/vendor/pexpect/_async.py,sha256=UCUC9kbBZGjzG12YcR_M5yBjB4Dwc8nJOYNPklL-OdU,3304
+pipenv/vendor/pexpect/bashrc.sh,sha256=CHK8qDg_HtDVdfyDULOV8MZDRDr4pOaIbo31XV58nQs,380
+pipenv/vendor/pexpect/exceptions.py,sha256=A9C1PWbBc2j9AKvnv7UkPCawhFTEGYmeULW0vwbMvXQ,1068
+pipenv/vendor/pexpect/expect.py,sha256=KKtBmx2MYa-yDE715XlHUcloKe5ndBD359a4OYVXD84,13827
+pipenv/vendor/pexpect/fdpexpect.py,sha256=ugTrwveFi-zfl_nOPjbRyLUER1Wmhu8YxczCWtZgZWc,5828
+pipenv/vendor/pexpect/popen_spawn.py,sha256=hVHOqr22jD2Pr-yVgsfwgqGAtULLi6kJLKQRrTBPvEg,6161
+pipenv/vendor/pexpect/pty_spawn.py,sha256=ZygSYsdnVJ5acxiNM9gLvLrT2AVqgwJvbDcPaTxxv9E,37382
+pipenv/vendor/pexpect/pxssh.py,sha256=bZHwFDOn1gC8U_Sl07eFFRlYfCjGCwEoC9WaZCHQo5Y,24279
+pipenv/vendor/pexpect/replwrap.py,sha256=Raq9XgYfIlF-rH_CALgFbzK1H_A4o0NqmK9q45anmVA,5633
+pipenv/vendor/pexpect/run.py,sha256=XK2GwW6_wbUZ6buIDbhouaOySVPnc5IahbgSjieks50,6628
+pipenv/vendor/pexpect/screen.py,sha256=-twD4sIEp83nzuYH9lRDzwHfesoTgVGWglsBYWOK7Ks,13704
+pipenv/vendor/pexpect/spawnbase.py,sha256=FoaNvkGYIXrD6xmBedrJmm_oVLMatqbGCXc027CugkQ,21247
+pipenv/vendor/pexpect/utils.py,sha256=1jIhzU7eBvY3pbW3LZoJhCOU2KWqgty5HgQ6VBYIp5U,6019
+pipenv/vendor/pip_shims/LICENSE,sha256=sYefctrm1S2jeiWBkmV65l5hFHUXJ5YVO9mojrv3WuM,741
+pipenv/vendor/pip_shims/__init__.py,sha256=7GlFkkvKM_EGe0sAbZ68glsMISxK2Gd072BSV6qBnuo,1305
+pipenv/vendor/pip_shims/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/pip_shims/__pycache__/compat.cpython-37.pyc,,
+pipenv/vendor/pip_shims/__pycache__/environment.cpython-37.pyc,,
+pipenv/vendor/pip_shims/__pycache__/models.cpython-37.pyc,,
+pipenv/vendor/pip_shims/__pycache__/shims.cpython-37.pyc,,
+pipenv/vendor/pip_shims/__pycache__/utils.cpython-37.pyc,,
+pipenv/vendor/pip_shims/compat.py,sha256=9hv5zHRyNRQGIHPKlu6oCuolOkspgr28Ln93MxkkiLk,72028
+pipenv/vendor/pip_shims/environment.py,sha256=KjUMlCJhD32jHRoD8-qiOxR_aQcsFKY34gnhs5t9rYU,1089
+pipenv/vendor/pip_shims/models.py,sha256=CLeCE0Uf9dZQzwpv6D_uLQRxMSZKmhYv4DNXI3TJrAA,45229
+pipenv/vendor/pip_shims/shims.py,sha256=9So7TMKeoe-REVnN6AOpP0DMefKN8sbxL2UaqRD5w8Q,1980
+pipenv/vendor/pip_shims/utils.py,sha256=gRGYNCkdthyg5Ek1BL_yMsqcu_5aYCXfyllH4I3TcRc,14948
+pipenv/vendor/pipdeptree.LICENSE,sha256=T8xOqotJ1aT3_uks6fiCqnMRZIMHWCHz4r-laNy2kYc,1075
+pipenv/vendor/pipdeptree.py,sha256=EczrErMfp2f1pxRkUpnAWmMk0qpFLfgw6mO5wGIOiiM,21944
+pipenv/vendor/pipreqs/LICENSE,sha256=xllut76FgcGL5zbIRvuRc7aezPbvlMUTWJPsVr2Sugg,11358
+pipenv/vendor/pipreqs/__init__.py,sha256=hfUJjojEC6oas8B9hWmItEjy2SHMokNBaE_46uSTpU4,119
+pipenv/vendor/pipreqs/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/pipreqs/__pycache__/pipreqs.cpython-37.pyc,,
+pipenv/vendor/pipreqs/mapping,sha256=xyOH_Ptz4PKX50ucz_5jeBmPWBSJ_j4GgqhLiHu9SMI,26633
+pipenv/vendor/pipreqs/pipreqs.py,sha256=aXOXoPQh16Iwj-r_losqS17N5Xi-iagysoz2ZK3BA9o,15922
+pipenv/vendor/pipreqs/stdlib,sha256=tbIQ5KHXxZlCkq2tuYFQJjOX0Uvb7q-Q14yfj0pJ4kA,5550
+pipenv/vendor/plette/LICENSE,sha256=84j9OMrRMRLB3A9mm76A5_hFQe26-3LzAw0sp2QsPJ0,751
+pipenv/vendor/plette/__init__.py,sha256=2JUP4IiCRT-nku9oqodYMVJIzRvDUQDveKgn24J_kgA,151
+pipenv/vendor/plette/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/plette/__pycache__/lockfiles.cpython-37.pyc,,
+pipenv/vendor/plette/__pycache__/pipfiles.cpython-37.pyc,,
+pipenv/vendor/plette/lockfiles.py,sha256=ULTjTK4qLkHiILnIk0z3W4VXXf6cS2RD5nAwReveKmE,4628
+pipenv/vendor/plette/models/__init__.py,sha256=BG_fLD2tF5h4y23gn_nqYvKEwpzYIWonNGhDhaXPxe8,591
+pipenv/vendor/plette/models/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/plette/models/__pycache__/base.cpython-37.pyc,,
+pipenv/vendor/plette/models/__pycache__/hashes.cpython-37.pyc,,
+pipenv/vendor/plette/models/__pycache__/packages.cpython-37.pyc,,
+pipenv/vendor/plette/models/__pycache__/scripts.cpython-37.pyc,,
+pipenv/vendor/plette/models/__pycache__/sections.cpython-37.pyc,,
+pipenv/vendor/plette/models/__pycache__/sources.cpython-37.pyc,,
+pipenv/vendor/plette/models/base.py,sha256=Xi3vzwHllYEGehlWyqdHpk8M0StygkNc6jYJuj0YdOI,4091
+pipenv/vendor/plette/models/hashes.py,sha256=xMZ1yvypxq1tUA4NNWryWFQfZuX9oOIoJbR9jxZDzBQ,1308
+pipenv/vendor/plette/models/packages.py,sha256=HsnVrEH1hLBd-nYQ5_iDMKZTQTKlhdaYea3SsKovQCk,1428
+pipenv/vendor/plette/models/scripts.py,sha256=WLi76sOTHJJVaol-AzEo9fxcJWW4qJnlgYO2PyKshrc,2624
+pipenv/vendor/plette/models/sections.py,sha256=6vCDxdwJ_ShuGjQE2xuEv24DbnJ1vbpPPX7x53tWruE,2874
+pipenv/vendor/plette/models/sources.py,sha256=IWLlvoMkufLKWCCVMoU84EuHhUqfDEED8abCbBscFiA,1050
+pipenv/vendor/plette/pipfiles.py,sha256=jzHiroZdSPZKMF5pnPOHTmUP4YslhQmwBYbr8g9ei4o,4383
+pipenv/vendor/ptyprocess/LICENSE,sha256=yCLThbGnMymEYkF5m-zxhpC11Edkwb7WkwC1NqQFAwo,905
+pipenv/vendor/ptyprocess/__init__.py,sha256=Q7Cd31VTCkFWg4KPHqZ75ykOQ7kj5kuo-tzkqOz8suo,138
+pipenv/vendor/ptyprocess/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/ptyprocess/__pycache__/_fork_pty.cpython-37.pyc,,
+pipenv/vendor/ptyprocess/__pycache__/ptyprocess.cpython-37.pyc,,
+pipenv/vendor/ptyprocess/__pycache__/util.cpython-37.pyc,,
+pipenv/vendor/ptyprocess/_fork_pty.py,sha256=VVvMy8c4ZpjDMiIMSg8T1BQ1g3SBexDpey_cxi0n5aw,2362
+pipenv/vendor/ptyprocess/ptyprocess.py,sha256=rD_1VuW02HxwB4hPIm6cah5XGx7pHj8QaYz5OhCXwf4,31355
+pipenv/vendor/ptyprocess/util.py,sha256=rQAdDRZfoOiOn6vykWth0wI6FFKAp7aJtBSdt-KBWdU,2785
+pipenv/vendor/pyparsing.LICENSE,sha256=ENUSChaAWAT_2otojCIL-06POXQbVzIGBNRVowngGXI,1023
+pipenv/vendor/pyparsing.py,sha256=oxX_ZOz8t-eros-UWY7nJgcdUgD-rQ53Ck0qp7_v3Ig,273365
+pipenv/vendor/pythonfinder/LICENSE.txt,sha256=ChfnPFrOlTWFl14yfjdjH6iBs9cp2IUAnkE-kXO-lmA,1052
+pipenv/vendor/pythonfinder/__init__.py,sha256=wFtpxl-0jwq99W5pRNEFEEAIcGpHWu3n5vmrP3Esu2U,589
+pipenv/vendor/pythonfinder/__main__.py,sha256=qTY9bHd0Xmv3Ubw_o5DPhVnffbclOIhOHaln-jBuCLE,304
+pipenv/vendor/pythonfinder/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/pythonfinder/__pycache__/__main__.cpython-37.pyc,,
+pipenv/vendor/pythonfinder/__pycache__/cli.cpython-37.pyc,,
+pipenv/vendor/pythonfinder/__pycache__/compat.cpython-37.pyc,,
+pipenv/vendor/pythonfinder/__pycache__/environment.cpython-37.pyc,,
+pipenv/vendor/pythonfinder/__pycache__/exceptions.cpython-37.pyc,,
+pipenv/vendor/pythonfinder/__pycache__/pythonfinder.cpython-37.pyc,,
+pipenv/vendor/pythonfinder/__pycache__/utils.cpython-37.pyc,,
+pipenv/vendor/pythonfinder/_vendor/Makefile,sha256=3iJQYI8hLn1e0dGK0USh_w0TM7urGT_yc4Xx03USCDY,374
+pipenv/vendor/pythonfinder/_vendor/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+pipenv/vendor/pythonfinder/_vendor/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/pythonfinder/_vendor/pep514tools/LICENSE,sha256=qqEATMknJlv29o6Yz2Rr1g3n9CgX_wYC0bK4TaKzbp8,1068
+pipenv/vendor/pythonfinder/_vendor/pep514tools/__init__.py,sha256=b7lTwQO_-stN3-VLzlsq1ad6V-qkNmR9PPLg8pqNe1Q,408
+pipenv/vendor/pythonfinder/_vendor/pep514tools/__main__.py,sha256=j5Ao7GQ2EpBEhglnJ5OPcHBWukDoSikvEidKKZsW_tI,253
+pipenv/vendor/pythonfinder/_vendor/pep514tools/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/pythonfinder/_vendor/pep514tools/__pycache__/__main__.cpython-37.pyc,,
+pipenv/vendor/pythonfinder/_vendor/pep514tools/__pycache__/_registry.cpython-37.pyc,,
+pipenv/vendor/pythonfinder/_vendor/pep514tools/__pycache__/environment.cpython-37.pyc,,
+pipenv/vendor/pythonfinder/_vendor/pep514tools/_registry.py,sha256=Rbp0vUNYzRT-6OXN6iJcsEt15JVQnHeUybvPSQ_xXTc,6411
+pipenv/vendor/pythonfinder/_vendor/pep514tools/environment.py,sha256=RSjf_qjh6HnigxsSp4t8BySOtCUNZxqb-dksEFaJqz8,4569
+pipenv/vendor/pythonfinder/_vendor/vendor.txt,sha256=4X3KL8pOTO35YBNZnNsdPr1khzWkFh8-E4dg7pEx5pc,68
+pipenv/vendor/pythonfinder/cli.py,sha256=huXQuBJFtqjD_Pn-lEgJ-fwQQrDlPtbI3Qhq-smiNpU,3563
+pipenv/vendor/pythonfinder/compat.py,sha256=0GcVLfP6Sr6zx4VBu-CPxaUT__099tpEM52-Bvflg4o,1092
+pipenv/vendor/pythonfinder/environment.py,sha256=ru0dt-AenYUSCMmoXaszVoJC44UPO0sT7g11NxTnWVQ,1423
+pipenv/vendor/pythonfinder/exceptions.py,sha256=DEd7HNRzw28kCKgoOJVzfVB7iSIYsgu-FsO7zv-WWDs,185
+pipenv/vendor/pythonfinder/models/__init__.py,sha256=RZ-m2WDHLx2ZqfryOQlwIY3bnS0t9s4IuOgXgbzV0PA,285
+pipenv/vendor/pythonfinder/models/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/pythonfinder/models/__pycache__/mixins.cpython-37.pyc,,
+pipenv/vendor/pythonfinder/models/__pycache__/path.cpython-37.pyc,,
+pipenv/vendor/pythonfinder/models/__pycache__/python.cpython-37.pyc,,
+pipenv/vendor/pythonfinder/models/__pycache__/windows.cpython-37.pyc,,
+pipenv/vendor/pythonfinder/models/mixins.py,sha256=8ij_yUQ2TcODrBhHvBsWz6gtDOpEGz8JBXoC0VsPJG4,13480
+pipenv/vendor/pythonfinder/models/path.py,sha256=o_IMv0CFHNoG0U1SvWpZmHvMYGLTW6VJ1lYKZKaGpiI,32843
+pipenv/vendor/pythonfinder/models/python.py,sha256=OPxhj77fSYzXiidbm7T7cYGd7ZWfXn4fwGmAkWYigow,26764
+pipenv/vendor/pythonfinder/models/windows.py,sha256=JZ6Wr9QDsTC9zKmvqEULbDFNxBQhY6u88WH2XFnJ-2Y,4998
+pipenv/vendor/pythonfinder/pep514tools.LICENSE,sha256=qqEATMknJlv29o6Yz2Rr1g3n9CgX_wYC0bK4TaKzbp8,1068
+pipenv/vendor/pythonfinder/pythonfinder.py,sha256=qaeQ4tVTW871Pm5pED1BnO13nYCJ7nz1wUEdxmVyCSg,12964
+pipenv/vendor/pythonfinder/utils.py,sha256=Ac4hbu6IFpvHcBTMWrIkTvwaYY0fH9mPdO8ThG4IbKk,14502
+pipenv/vendor/requests/LICENSE,sha256=iDei8zphvO4XXAKP8W0cFgq6SKOuvhSVrOcJvk5iY2s,582
+pipenv/vendor/requests/__init__.py,sha256=D1me6xXfLQd-oHHmJf_ssyqRE5YKM87Fou2hnbwN7hQ,3927
+pipenv/vendor/requests/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/requests/__pycache__/__version__.cpython-37.pyc,,
+pipenv/vendor/requests/__pycache__/_internal_utils.cpython-37.pyc,,
+pipenv/vendor/requests/__pycache__/adapters.cpython-37.pyc,,
+pipenv/vendor/requests/__pycache__/api.cpython-37.pyc,,
+pipenv/vendor/requests/__pycache__/auth.cpython-37.pyc,,
+pipenv/vendor/requests/__pycache__/certs.cpython-37.pyc,,
+pipenv/vendor/requests/__pycache__/compat.cpython-37.pyc,,
+pipenv/vendor/requests/__pycache__/cookies.cpython-37.pyc,,
+pipenv/vendor/requests/__pycache__/exceptions.cpython-37.pyc,,
+pipenv/vendor/requests/__pycache__/help.cpython-37.pyc,,
+pipenv/vendor/requests/__pycache__/hooks.cpython-37.pyc,,
+pipenv/vendor/requests/__pycache__/models.cpython-37.pyc,,
+pipenv/vendor/requests/__pycache__/packages.cpython-37.pyc,,
+pipenv/vendor/requests/__pycache__/sessions.cpython-37.pyc,,
+pipenv/vendor/requests/__pycache__/status_codes.cpython-37.pyc,,
+pipenv/vendor/requests/__pycache__/structures.cpython-37.pyc,,
+pipenv/vendor/requests/__pycache__/utils.cpython-37.pyc,,
+pipenv/vendor/requests/__version__.py,sha256=dpcXABdGo9y3UFFKFU_Wu_YHSa7TBXxCghOju7S8IYs,441
+pipenv/vendor/requests/_internal_utils.py,sha256=Zx3PnEUccyfsB-ie11nZVAW8qClJy0gx1qNME7rgT18,1096
+pipenv/vendor/requests/adapters.py,sha256=WelSM1BCQXdbjEuDsBxqKDADeY8BHmxlrwbNnLN2rr4,21344
+pipenv/vendor/requests/api.py,sha256=PlHM-HT3PQ5lyufoeGmV-nJxRi7UnUyGVh7OV7B9XV4,6496
+pipenv/vendor/requests/auth.py,sha256=OMoJIVKyRLy9THr91y8rxysZuclwPB-K1Xg1zBomUhQ,10207
+pipenv/vendor/requests/certs.py,sha256=dOB5rV2DZ13dEhq9BUa_4hd5kAqg59e_zUZB00faYz8,453
+pipenv/vendor/requests/compat.py,sha256=iBRvu-X540CH4PJsuxr0vcGTnl_TZhq_75SwmeckQ7w,1782
+pipenv/vendor/requests/cookies.py,sha256=Y-bKX6TvW3FnYlE6Au0SXtVVWcaNdFvuAwQxw-G0iTI,18430
+pipenv/vendor/requests/exceptions.py,sha256=Q8YeWWxiHHXhkEynLpMgC_6_r_ZTYw2aITs9wCSAZNY,3185
+pipenv/vendor/requests/help.py,sha256=lLcBtKAar8T6T78e9Tc4Zfd_EEJFhntxgib1JHNctEI,3515
+pipenv/vendor/requests/hooks.py,sha256=QReGyy0bRcr5rkwCuObNakbYsc7EkiKeBwG4qHekr2Q,757
+pipenv/vendor/requests/models.py,sha256=lcB8ieQePk31Se-dQQlEi7r8UQ0W1KmhS1D--0DrdFQ,34213
+pipenv/vendor/requests/packages.py,sha256=Q2rF0L5mc3wQAvc6q_lAVtPTDOaOeFgD-7kWSQLkjEQ,542
+pipenv/vendor/requests/sessions.py,sha256=Ju8VnlWZPU_Xr-cMjKXNbs_l2cyanr3Dm9c7fLxprQI,29265
+pipenv/vendor/requests/status_codes.py,sha256=gT79Pbs_cQjBgp-fvrUgg1dn2DQO32bDj4TInjnMPSc,4188
+pipenv/vendor/requests/structures.py,sha256=msAtr9mq1JxHd-JRyiILfdFlpbJwvvFuP3rfUQT_QxE,3005
+pipenv/vendor/requests/utils.py,sha256=VBs99cvV8Z29WGXeWZqHzZ80_nu1AwwjYzJfe0wQIvs,30176
+pipenv/vendor/requirementslib/LICENSE,sha256=-R7DVBemv_w_Ne7M942r0fnIk2A5PX5EOXzf4lG6S-Y,1072
+pipenv/vendor/requirementslib/__init__.py,sha256=hOR924EO3D_Fp7RIf90NzkoKcq5WlqZWqCKIcSX-AJ8,488
+pipenv/vendor/requirementslib/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/requirementslib/__pycache__/environment.cpython-37.pyc,,
+pipenv/vendor/requirementslib/__pycache__/exceptions.cpython-37.pyc,,
+pipenv/vendor/requirementslib/__pycache__/utils.cpython-37.pyc,,
+pipenv/vendor/requirementslib/environment.py,sha256=BODXyKY_abzVQt7PGJlfl4UztywAzzpRaX_wW8PRbco,431
+pipenv/vendor/requirementslib/exceptions.py,sha256=q9n7sPQIKdNH7f38sAtODpux1yBZuySbDPovJIQEwN8,3699
+pipenv/vendor/requirementslib/models/__init__.py,sha256=iwhKnzeBJLKxpRVjvzwiRE63_zNpIBfaKLITauVph-0,24
+pipenv/vendor/requirementslib/models/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/requirementslib/models/__pycache__/cache.cpython-37.pyc,,
+pipenv/vendor/requirementslib/models/__pycache__/dependencies.cpython-37.pyc,,
+pipenv/vendor/requirementslib/models/__pycache__/lockfile.cpython-37.pyc,,
+pipenv/vendor/requirementslib/models/__pycache__/markers.cpython-37.pyc,,
+pipenv/vendor/requirementslib/models/__pycache__/metadata.cpython-37.pyc,,
+pipenv/vendor/requirementslib/models/__pycache__/pipfile.cpython-37.pyc,,
+pipenv/vendor/requirementslib/models/__pycache__/project.cpython-37.pyc,,
+pipenv/vendor/requirementslib/models/__pycache__/requirements.cpython-37.pyc,,
+pipenv/vendor/requirementslib/models/__pycache__/resolvers.cpython-37.pyc,,
+pipenv/vendor/requirementslib/models/__pycache__/setup_info.cpython-37.pyc,,
+pipenv/vendor/requirementslib/models/__pycache__/url.cpython-37.pyc,,
+pipenv/vendor/requirementslib/models/__pycache__/utils.cpython-37.pyc,,
+pipenv/vendor/requirementslib/models/__pycache__/vcs.cpython-37.pyc,,
+pipenv/vendor/requirementslib/models/cache.py,sha256=VsWpAhr2prZcJ16daM7Us7gnRPgtML2mXeNl9vS8Ubo,11542
+pipenv/vendor/requirementslib/models/dependencies.py,sha256=0IkM-kbusINE8fRRIm9i4jRwexhRCfVJCso0ln0KlEw,25380
+pipenv/vendor/requirementslib/models/lockfile.py,sha256=lkGiTPRgW8IesyShO4pWVPxI2kcEVxSuOAqPhPW5540,11205
+pipenv/vendor/requirementslib/models/markers.py,sha256=t9d0J615vEtJPJZzJHKY4nARBFeaKSWtnX-jWAaZOTQ,26213
+pipenv/vendor/requirementslib/models/metadata.py,sha256=6wAFqwJhKzU5sAjzCh0DxJMq4wF6wnd0vO88pNrzPjY,44138
+pipenv/vendor/requirementslib/models/pipfile.py,sha256=tCiUMRD5JCXkXcH6FpIN5z-hOnIEAhPSDsrERD6hKBc,14238
+pipenv/vendor/requirementslib/models/project.py,sha256=rtoXCcfqpJIGTgpNMl8ithOTKjKkcFu1dcfR-RPuY3o,7837
+pipenv/vendor/requirementslib/models/requirements.py,sha256=8WaU_kumr2VTtvdq4EN7BQn2OW65aVKu2UMIvSDcE2s,119953
+pipenv/vendor/requirementslib/models/resolvers.py,sha256=izJDSOmiFer5bcd767tVwaEA-YsWWLba6imEJgr7_ag,9565
+pipenv/vendor/requirementslib/models/setup_info.py,sha256=UAyruqOxSGJwmc0axsIiCQ9ZZLDVq5HmU4FrsPlpwBA,70616
+pipenv/vendor/requirementslib/models/url.py,sha256=yElGxukhyIYBtFQV3bqqWa2jnCEwGw6TRkW4CU3DcKY,18656
+pipenv/vendor/requirementslib/models/utils.py,sha256=dn2AxeRrYCEaAPpTFHWMopG3YtyIMf9fAbgv_LlcIpQ,35053
+pipenv/vendor/requirementslib/models/vcs.py,sha256=XrSBeOgxwp_rN5iJT7HaR7BrNnkLJUCBVORCBawYM_A,4625
+pipenv/vendor/requirementslib/utils.py,sha256=IMhK-oWw1nVv2iqJQ2a3uX0CY7BqZlL6-9_KqPaaPqo,25549
+pipenv/vendor/resolvelib/LICENSE,sha256=84j9OMrRMRLB3A9mm76A5_hFQe26-3LzAw0sp2QsPJ0,751
+pipenv/vendor/resolvelib/__init__.py,sha256=aBndiGQ3I68Ezdv0fMPQ9ek6ScvwpuQRimxn6wp7pJ4,537
+pipenv/vendor/resolvelib/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/resolvelib/__pycache__/providers.cpython-37.pyc,,
+pipenv/vendor/resolvelib/__pycache__/reporters.cpython-37.pyc,,
+pipenv/vendor/resolvelib/__pycache__/resolvers.cpython-37.pyc,,
+pipenv/vendor/resolvelib/__pycache__/structs.cpython-37.pyc,,
+pipenv/vendor/resolvelib/providers.py,sha256=1JCBbBV0E_Q1o0XOAeAdr2YaKU_zHxO7i_BBLqCLhUc,4913
+pipenv/vendor/resolvelib/reporters.py,sha256=5gXUn3hRjA4UomD3HHZGreBp23aSjMHgBrC3OgYSpTY,1094
+pipenv/vendor/resolvelib/resolvers.py,sha256=nTTfBBIMsoxGhqUAyh8GbmR-si_TijpY67wD7aUS264,14481
+pipenv/vendor/resolvelib/structs.py,sha256=yrdhd-n7DercimPGclXe20rgqhlxw8PnxC0wmcXO19Y,2016
+pipenv/vendor/scandir.LICENSE.txt,sha256=peL73COXREGdKUB828knk8TZwdlWwXT3y3-W-m0FjIY,1464
+pipenv/vendor/scandir.py,sha256=lNHF8GJKugLuthHYx0SIFleDWwNaURD0gIxBNy-ZNnQ,24778
+pipenv/vendor/semver.LICENSE.txt,sha256=zaSQwy5h04hNwXeR_IB48qPlZPupjdGLTcZOsnILK28,1496
+pipenv/vendor/semver.py,sha256=T59DFTd333IV9FSkyD3_c8WfSGNFb6GWtxdXX3GGEig,21696
+pipenv/vendor/shellingham/LICENSE,sha256=84j9OMrRMRLB3A9mm76A5_hFQe26-3LzAw0sp2QsPJ0,751
+pipenv/vendor/shellingham/__init__.py,sha256=X2qEstZbnIM4vZtK8sYSWr6unUqPKljB952IiSO_-xY,624
+pipenv/vendor/shellingham/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/shellingham/__pycache__/_consts.cpython-37.pyc,,
+pipenv/vendor/shellingham/__pycache__/_core.cpython-37.pyc,,
+pipenv/vendor/shellingham/__pycache__/nt.cpython-37.pyc,,
+pipenv/vendor/shellingham/__pycache__/posix.cpython-37.pyc,,
+pipenv/vendor/shellingham/_consts.py,sha256=skJMj5v8q0ZD-OOCXQKHb-v2-Ue9eGZkg-XfDCDpa4E,264
+pipenv/vendor/shellingham/_core.py,sha256=xHTekKkjprtJY0caOH1DwyPBh8KX1wLm5GVY7yM0rOs,322
+pipenv/vendor/shellingham/nt.py,sha256=1oa_JEnrYmKn1hoXiqtIVXQ5iJmGlPd3G8mYkmJNYIw,4426
+pipenv/vendor/shellingham/posix.py,sha256=1cUryTK2peU5fEjCqm89OSA6YQelbrR18ZyDtYezMRs,1673
+pipenv/vendor/shellingham/posix/__init__.py,sha256=vhlGMEYoATTl8NtD0ENC8lDN-7dGxoFqNQ6pgpSsII8,2843
+pipenv/vendor/shellingham/posix/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/shellingham/posix/__pycache__/_core.cpython-37.pyc,,
+pipenv/vendor/shellingham/posix/__pycache__/_proc.cpython-37.pyc,,
+pipenv/vendor/shellingham/posix/__pycache__/_ps.cpython-37.pyc,,
+pipenv/vendor/shellingham/posix/__pycache__/proc.cpython-37.pyc,,
+pipenv/vendor/shellingham/posix/__pycache__/ps.cpython-37.pyc,,
+pipenv/vendor/shellingham/posix/_core.py,sha256=6AmQ7lbeYTCQERZrgFBSpEMqR5cladBxFARt1-9UDGg,81
+pipenv/vendor/shellingham/posix/_proc.py,sha256=RgzclHM_jMF6w8QgfKCSpDSsl_6T6LNAeyZJ8-tPSXA,1030
+pipenv/vendor/shellingham/posix/_ps.py,sha256=buNCWUusL1kbdXI7moENZ3GC-9i-aPFQC6RV1lvdPpY,725
+pipenv/vendor/shellingham/posix/proc.py,sha256=co3pcaLWs7jGZvHUevjuVKl90YELIejI2EfL3oumJjQ,2114
+pipenv/vendor/shellingham/posix/ps.py,sha256=iGfRdla46oYK5DybbmLEXCsR9L3c0r_qUNBKJInkEZ4,1585
+pipenv/vendor/six.LICENSE,sha256=i7hQxWWqOJ_cFvOkaWWtI9gq3_YPI5P8J2K2MYXo5sk,1066
+pipenv/vendor/six.py,sha256=Q6WvEXZ1DGEASAo3CGNCJkKv2tPy8xkSmK-VHE9PYIA,34074
+pipenv/vendor/toml/LICENSE,sha256=LZKUgj32yJNXyL5JJ_znk2HWVh5e51MtWSbmOTmqpTY,1252
+pipenv/vendor/toml/__init__.py,sha256=CtuG5aQNk6m6Mmxotrt6F52x9dRd53oyTiMYii97hn0,723
+pipenv/vendor/toml/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/toml/__pycache__/common.cpython-37.pyc,,
+pipenv/vendor/toml/__pycache__/decoder.cpython-37.pyc,,
+pipenv/vendor/toml/__pycache__/encoder.cpython-37.pyc,,
+pipenv/vendor/toml/__pycache__/ordered.cpython-37.pyc,,
+pipenv/vendor/toml/__pycache__/tz.cpython-37.pyc,,
+pipenv/vendor/toml/common.py,sha256=ViBccAduP6eZNJAb1POhRhjOAi56TDsNgWJ1TjgXAug,242
+pipenv/vendor/toml/decoder.py,sha256=gRgnNQ73I3Zw8Ys0ArBkbec9h317zeFjmRu4TMoXumw,38684
+pipenv/vendor/toml/encoder.py,sha256=9HpekPtXkAdfhPpZqfHUxxfW82fMxJ9aybiLUzcbR30,9931
+pipenv/vendor/toml/ordered.py,sha256=mz03lZmV0bmc9lsYRIUOuj7Dsu5Ptwq-UtGVq5FdVZ4,354
+pipenv/vendor/toml/tz.py,sha256=DrAgI3wZxZiGcLuV_l8ueA_nPrYoxQ3hZA9tJSjWRsQ,618
+pipenv/vendor/tomlkit/LICENSE,sha256=8vm0YLpxnaZiat0mTTeC8nWk_3qrZ3vtoIszCRHiOts,1062
+pipenv/vendor/tomlkit/__init__.py,sha256=0bOM-AjUVQvHV5OJsKQrS9ctZgTYiOjLrftA6dAlS3Y,543
+pipenv/vendor/tomlkit/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/tomlkit/__pycache__/_compat.cpython-37.pyc,,
+pipenv/vendor/tomlkit/__pycache__/_utils.cpython-37.pyc,,
+pipenv/vendor/tomlkit/__pycache__/api.cpython-37.pyc,,
+pipenv/vendor/tomlkit/__pycache__/container.cpython-37.pyc,,
+pipenv/vendor/tomlkit/__pycache__/exceptions.cpython-37.pyc,,
+pipenv/vendor/tomlkit/__pycache__/items.cpython-37.pyc,,
+pipenv/vendor/tomlkit/__pycache__/parser.cpython-37.pyc,,
+pipenv/vendor/tomlkit/__pycache__/source.cpython-37.pyc,,
+pipenv/vendor/tomlkit/__pycache__/toml_char.cpython-37.pyc,,
+pipenv/vendor/tomlkit/__pycache__/toml_document.cpython-37.pyc,,
+pipenv/vendor/tomlkit/__pycache__/toml_file.cpython-37.pyc,,
+pipenv/vendor/tomlkit/_compat.py,sha256=fWVbxfpMgN198uGSphclakN959g7XgF76Iwp8mVegug,5357
+pipenv/vendor/tomlkit/_utils.py,sha256=r3_KD46n9XrJEUTzzUbGWAaRi_32nBau0Oxvc-WHxMM,3372
+pipenv/vendor/tomlkit/api.py,sha256=Er9xb_dR5D2ZUgVLQwFN1alUAO1S-YxDMA-S-bxN3_0,3051
+pipenv/vendor/tomlkit/container.py,sha256=045LZh69L5r3_VG0A7neCNi4jEeFpujrfDwH_y-Q0TU,22835
+pipenv/vendor/tomlkit/exceptions.py,sha256=dKlOcJmzGQfJ4td43bohm208oLwoyZdtYQd1SJMALuk,5190
+pipenv/vendor/tomlkit/items.py,sha256=6lPrtgdMLgThdmTi95gJsD_cT6Fra6Qd3zMO7jKn_fY,33588
+pipenv/vendor/tomlkit/parser.py,sha256=lUN_jbUWEgZFsIVlSvld3TyjFyq5GtJxS-zkW92SrP8,38510
+pipenv/vendor/tomlkit/source.py,sha256=UnRPsHPf6opTujFYc5oBYW3lVkq4EjPflg-OUYv2oeU,5353
+pipenv/vendor/tomlkit/toml_char.py,sha256=Tvlqp-SBYglSW9ISVqBUvjDGmFpGIN5uUQYUAH5HhpY,1731
+pipenv/vendor/tomlkit/toml_document.py,sha256=B2A2p9Cr8W9otF4clE6KxlGdcxCCnJLlZ0MgUHBieOI,103
+pipenv/vendor/tomlkit/toml_file.py,sha256=djdabN9Q_LwxhO3UZzy5bedWqA6Iv29gD1uQaDpVFQY,525
+pipenv/vendor/urllib3/LICENSE.txt,sha256=fA0TbuBYU4mt8tJWcbuZaHofdZKfRlt_Fu4_Ado3JV4,1115
+pipenv/vendor/urllib3/__init__.py,sha256=rdFZCO1L7e8861ZTvo8AiSKwxCe9SnWQUQwJ599YV9c,2683
+pipenv/vendor/urllib3/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/urllib3/__pycache__/_collections.cpython-37.pyc,,
+pipenv/vendor/urllib3/__pycache__/connection.cpython-37.pyc,,
+pipenv/vendor/urllib3/__pycache__/connectionpool.cpython-37.pyc,,
+pipenv/vendor/urllib3/__pycache__/exceptions.cpython-37.pyc,,
+pipenv/vendor/urllib3/__pycache__/fields.cpython-37.pyc,,
+pipenv/vendor/urllib3/__pycache__/filepost.cpython-37.pyc,,
+pipenv/vendor/urllib3/__pycache__/poolmanager.cpython-37.pyc,,
+pipenv/vendor/urllib3/__pycache__/request.cpython-37.pyc,,
+pipenv/vendor/urllib3/__pycache__/response.cpython-37.pyc,,
+pipenv/vendor/urllib3/_collections.py,sha256=GouVsNzwg6jADZTmimMI6oqmwKSswnMo9dh5tGNVWO4,10792
+pipenv/vendor/urllib3/connection.py,sha256=Fln8a_bkegdNMkFoSOwyI0PJvL1OqzVUO6ifihKOTpc,14461
+pipenv/vendor/urllib3/connectionpool.py,sha256=egdaX-Db_LVXifDxv3JY0dHIpQqDv0wC0_9Eeh8FkPM,35725
+pipenv/vendor/urllib3/contrib/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+pipenv/vendor/urllib3/contrib/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/urllib3/contrib/__pycache__/_appengine_environ.cpython-37.pyc,,
+pipenv/vendor/urllib3/contrib/__pycache__/appengine.cpython-37.pyc,,
+pipenv/vendor/urllib3/contrib/__pycache__/ntlmpool.cpython-37.pyc,,
+pipenv/vendor/urllib3/contrib/__pycache__/pyopenssl.cpython-37.pyc,,
+pipenv/vendor/urllib3/contrib/__pycache__/securetransport.cpython-37.pyc,,
+pipenv/vendor/urllib3/contrib/__pycache__/socks.cpython-37.pyc,,
+pipenv/vendor/urllib3/contrib/_appengine_environ.py,sha256=bDbyOEhW2CKLJcQqAKAyrEHN-aklsyHFKq6vF8ZFsmk,957
+pipenv/vendor/urllib3/contrib/_securetransport/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+pipenv/vendor/urllib3/contrib/_securetransport/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/urllib3/contrib/_securetransport/__pycache__/bindings.cpython-37.pyc,,
+pipenv/vendor/urllib3/contrib/_securetransport/__pycache__/low_level.cpython-37.pyc,,
+pipenv/vendor/urllib3/contrib/_securetransport/bindings.py,sha256=mullWYFaghBdRWla6HYU-TBgFRTPLBEfxj3jplbeJmQ,16886
+pipenv/vendor/urllib3/contrib/_securetransport/low_level.py,sha256=V7GnujxnWZh2N2sMsV5N4d9Imymokkm3zBwgt77_bSE,11956
+pipenv/vendor/urllib3/contrib/appengine.py,sha256=9RyUW5vKy4VPa2imtwBNWYKILrypr-K6UXEHUYsf0JY,11010
+pipenv/vendor/urllib3/contrib/ntlmpool.py,sha256=a402AwGN_Ll3N-4ur_AS6UrU-ycUtlnYqoBF76lORg8,4160
+pipenv/vendor/urllib3/contrib/pyopenssl.py,sha256=qQKqQXvlSvpCa2yEPxpdv18lS71SMESr9XzH9K9x3KI,16565
+pipenv/vendor/urllib3/contrib/securetransport.py,sha256=vBDFjSnH2gWa-ztMKVaiwW46K1mlDZKqvo_VAonfdcY,32401
+pipenv/vendor/urllib3/contrib/socks.py,sha256=nzDMgDIFJWVubKHqvIn2-SKCO91hhJInP92WgHChGzA,7036
+pipenv/vendor/urllib3/exceptions.py,sha256=D2Jvab7M7m_n0rnmBmq481paoVT32VvVeB6VeQM0y-w,7172
+pipenv/vendor/urllib3/fields.py,sha256=kroD76QK-GdHHW7f_AUN4XxDC3OQPI2FFrS9eSL4BCs,8553
+pipenv/vendor/urllib3/filepost.py,sha256=vj0qbrpT1AFzvvW4SuC8M5kJiw7wftHcSr-7b8UpPpw,2440
+pipenv/vendor/urllib3/packages/__init__.py,sha256=h4BLhD4tLaBx1adaDtKXfupsgqY0wWLXb_f1_yVlV6A,108
+pipenv/vendor/urllib3/packages/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/urllib3/packages/__pycache__/six.cpython-37.pyc,,
+pipenv/vendor/urllib3/packages/backports/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+pipenv/vendor/urllib3/packages/backports/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/urllib3/packages/backports/__pycache__/makefile.cpython-37.pyc,,
+pipenv/vendor/urllib3/packages/backports/makefile.py,sha256=005wrvH-_pWSnTFqQ2sdzzh4zVCtQUUQ4mR2Yyxwc0A,1418
+pipenv/vendor/urllib3/packages/six.py,sha256=adx4z-eM_D0Vvu0IIqVzFACQ_ux9l64y7DkSEfbxCDs,32536
+pipenv/vendor/urllib3/packages/ssl_match_hostname/__init__.py,sha256=ywgKMtfHi1-DrXlzPfVAhzsLzzqcK7GT6eLgdode1Fg,688
+pipenv/vendor/urllib3/packages/ssl_match_hostname/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/urllib3/packages/ssl_match_hostname/__pycache__/_implementation.cpython-37.pyc,,
+pipenv/vendor/urllib3/packages/ssl_match_hostname/_implementation.py,sha256=6dZ-q074g7XhsJ27MFCgkct8iVNZB3sMZvKhf-KUVy0,5679
+pipenv/vendor/urllib3/poolmanager.py,sha256=iWEAIGrVNGoOmQyfiFwCqG-IyYy6GIQ-jJ9QCsX9li4,17861
+pipenv/vendor/urllib3/request.py,sha256=hhoHvEEatyd9Tn5EbGjQ0emn-ENMCyY591yNWTneINA,6018
+pipenv/vendor/urllib3/response.py,sha256=eo1Sfkn2x44FtjgP3qwwDsG9ak84spQAxEGy7Ovd4Pc,28221
+pipenv/vendor/urllib3/util/__init__.py,sha256=bWNaav_OT-1L7-sxm59cGb59rDORlbhb_4noduM5m0U,1038
+pipenv/vendor/urllib3/util/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/urllib3/util/__pycache__/connection.cpython-37.pyc,,
+pipenv/vendor/urllib3/util/__pycache__/queue.cpython-37.pyc,,
+pipenv/vendor/urllib3/util/__pycache__/request.cpython-37.pyc,,
+pipenv/vendor/urllib3/util/__pycache__/response.cpython-37.pyc,,
+pipenv/vendor/urllib3/util/__pycache__/retry.cpython-37.pyc,,
+pipenv/vendor/urllib3/util/__pycache__/ssl_.cpython-37.pyc,,
+pipenv/vendor/urllib3/util/__pycache__/timeout.cpython-37.pyc,,
+pipenv/vendor/urllib3/util/__pycache__/url.cpython-37.pyc,,
+pipenv/vendor/urllib3/util/__pycache__/wait.cpython-37.pyc,,
+pipenv/vendor/urllib3/util/connection.py,sha256=NsxUAKQ98GKywta--zg57CdVpeTCI6N-GElCq78Dl8U,4637
+pipenv/vendor/urllib3/util/queue.py,sha256=myTX3JDHntglKQNBf3b6dasHH-uF-W59vzGSQiFdAfI,497
+pipenv/vendor/urllib3/util/request.py,sha256=C-6-AWffxZG03AdRGoY59uqsn4CVItKU6gjxz7Hc3Mc,3815
+pipenv/vendor/urllib3/util/response.py,sha256=_WbTQr8xRQuJuY2rTIZxVdJD6mnEOtQupjaK_bF_Vj8,2573
+pipenv/vendor/urllib3/util/retry.py,sha256=3wbv7SdzYNOxPcBiFkPCubTbK1_6vWSepznOXirhUfA,15543
+pipenv/vendor/urllib3/util/ssl_.py,sha256=R64MEN6Bh-YJq8b14kCb6hbV8L1p8oq4rcZiBow3tTQ,14511
+pipenv/vendor/urllib3/util/timeout.py,sha256=3qawUo-TZq4q7tyeRToMIOdNGEOBjOOQVq7nHnLryP4,9947
+pipenv/vendor/urllib3/util/url.py,sha256=jvkBGN64wo_Mx6Q6JYpFCGxamxbI2NdFoNQVTr7PUOM,13964
+pipenv/vendor/urllib3/util/wait.py,sha256=k46KzqIYu3Vnzla5YW3EvtInNlU_QycFqQAghIOxoAg,5406
+pipenv/vendor/vendor.txt,sha256=J83m8P54MR2N8scL4BBqqNNryMkimqr-bUlkgEi-CX0,1203
+pipenv/vendor/vendor_pip.txt,sha256=svVMQpSngTtwHn9X8cJPy3e5-4w6E-i46IawdPVZYvw,421
+pipenv/vendor/vistir/LICENSE,sha256=sYefctrm1S2jeiWBkmV65l5hFHUXJ5YVO9mojrv3WuM,741
+pipenv/vendor/vistir/__init__.py,sha256=DrY_rAoeRTIqa3W4Mv4or1H9IXEwGQrPrhJ0q4hSgps,1420
+pipenv/vendor/vistir/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/vistir/__pycache__/_winconsole.cpython-37.pyc,,
+pipenv/vendor/vistir/__pycache__/cmdparse.cpython-37.pyc,,
+pipenv/vendor/vistir/__pycache__/compat.cpython-37.pyc,,
+pipenv/vendor/vistir/__pycache__/contextmanagers.cpython-37.pyc,,
+pipenv/vendor/vistir/__pycache__/cursor.cpython-37.pyc,,
+pipenv/vendor/vistir/__pycache__/environment.cpython-37.pyc,,
+pipenv/vendor/vistir/__pycache__/misc.cpython-37.pyc,,
+pipenv/vendor/vistir/__pycache__/path.cpython-37.pyc,,
+pipenv/vendor/vistir/__pycache__/spin.cpython-37.pyc,,
+pipenv/vendor/vistir/__pycache__/termcolors.cpython-37.pyc,,
+pipenv/vendor/vistir/_winconsole.py,sha256=XSE5GWFl7Qyz1X-LAD63tH7ipFX7c12LwFf8Re_o-Pk,15863
+pipenv/vendor/vistir/backports/__init__.py,sha256=xI9tU9cDAVAmON3Q5U96R08l88NodQDxtfowxySzywM,292
+pipenv/vendor/vistir/backports/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/vistir/backports/__pycache__/functools.cpython-37.pyc,,
+pipenv/vendor/vistir/backports/__pycache__/surrogateescape.cpython-37.pyc,,
+pipenv/vendor/vistir/backports/__pycache__/tempfile.cpython-37.pyc,,
+pipenv/vendor/vistir/backports/functools.py,sha256=qjkbZf60L_1GRNw1MD_Nz7BrcIkPqS2VZJ0Sqy8m8as,3165
+pipenv/vendor/vistir/backports/surrogateescape.py,sha256=TObXfHM6TMQuT8Vc_Jc7MVfX8UQPrlTBGdOeB-6VnYg,5872
+pipenv/vendor/vistir/backports/tempfile.py,sha256=HBZyYTajBf7BsxpzRinjAudyOhcveJZrt36z_f7KPdo,7331
+pipenv/vendor/vistir/cmdparse.py,sha256=9nqfiGb8TTS033eBbZ591h3Khbfq8jLPWUh9Yf7SDgA,2493
+pipenv/vendor/vistir/compat.py,sha256=O3tf4AUPz0EPueD7a9uWAz8KBt0Es2xlKjajL2vg7Ts,12742
+pipenv/vendor/vistir/contextmanagers.py,sha256=4cTOGwibaDwOdAck6lBpf8meDG7HMgSeTuoahetb118,12808
+pipenv/vendor/vistir/cursor.py,sha256=j6AatXWgXA1MGA0RGT9RblqP2_CL3WU_SSQl32i6pUU,1477
+pipenv/vendor/vistir/environment.py,sha256=Iwg8ZVoFu0gbExrwlXabX4BiIWuDCXZYU_CDDqljFS8,150
+pipenv/vendor/vistir/misc.py,sha256=0ZxRuw02xblLGX9K35WmdjXQ24oDC0hJr4j3khP5z6E,41920
+pipenv/vendor/vistir/path.py,sha256=SPSdzrkj3JbOpPFsara3jmleLyZPVVmKrmD29YmDkrk,20138
+pipenv/vendor/vistir/spin.py,sha256=V5iZBlI0dOwKAAeVkbOVnjnEnmF7rib9p7GGFGhx_IQ,16442
+pipenv/vendor/vistir/termcolors.py,sha256=BrYOx6zTs6f6aP78z9ldHXcKdd7exhMmkHxo6-Lw6AQ,3746
+pipenv/vendor/yarg/LICENSE,sha256=yb7qd8-CyS_EsyKkiJwH82lfGLAfy6RBth1exU2s8_Y,1070
+pipenv/vendor/yarg/LICENSE-REQUESTS,sha256=iUePGRX7trZYWmhdBxvwBrpWSdJhX6t4f2bpaTxiKuQ,581
+pipenv/vendor/yarg/__about__.py,sha256=S9R0oCMo4TRjYQCxqWqtOBoUAFm8ZV9C4IWmvujg0xc,188
+pipenv/vendor/yarg/__init__.py,sha256=XmzF4sV5X6CZNh4GnbBfj1CyN039Vq-maSpCtWew-o4,1959
+pipenv/vendor/yarg/__pycache__/__about__.cpython-37.pyc,,
+pipenv/vendor/yarg/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/yarg/__pycache__/client.cpython-37.pyc,,
+pipenv/vendor/yarg/__pycache__/exceptions.cpython-37.pyc,,
+pipenv/vendor/yarg/__pycache__/package.cpython-37.pyc,,
+pipenv/vendor/yarg/__pycache__/parse.cpython-37.pyc,,
+pipenv/vendor/yarg/__pycache__/release.cpython-37.pyc,,
+pipenv/vendor/yarg/client.py,sha256=mVMCX8CdYg2Md4BoTIyhPinLIu8S-M5PIBtc66v7Xwk,2122
+pipenv/vendor/yarg/exceptions.py,sha256=ndSYQITlX2LpXvCFAXGyMOQoaDmbFP251w7uheF9eus,2050
+pipenv/vendor/yarg/package.py,sha256=NyiYdc7pKvfLZcArMdlRlZy_hd9-3_khn5nfnWB2LHk,9990
+pipenv/vendor/yarg/parse.py,sha256=fNIypJWMk1u_t7GfQFi2RmxN2qfXAmOiKIFhLdCGB-Y,5406
+pipenv/vendor/yarg/release.py,sha256=eFT1gtMTOSBp5YwwCFKDAK6BUCVF4qXUHgLNDy8rAmo,4298
+pipenv/vendor/yaspin/LICENSE,sha256=59gtkn-eqXsi_t6Z6zAgGkU_dAk6yMlek3uLlW3Ub1k,1072
+pipenv/vendor/yaspin/__init__.py,sha256=MehjhKCeW0lQyxpliMq91hclm4uciOj1EPzmCzbi38I,238
+pipenv/vendor/yaspin/__pycache__/__init__.cpython-37.pyc,,
+pipenv/vendor/yaspin/__pycache__/__version__.cpython-37.pyc,,
+pipenv/vendor/yaspin/__pycache__/api.cpython-37.pyc,,
+pipenv/vendor/yaspin/__pycache__/base_spinner.cpython-37.pyc,,
+pipenv/vendor/yaspin/__pycache__/compat.cpython-37.pyc,,
+pipenv/vendor/yaspin/__pycache__/constants.cpython-37.pyc,,
+pipenv/vendor/yaspin/__pycache__/core.cpython-37.pyc,,
+pipenv/vendor/yaspin/__pycache__/helpers.cpython-37.pyc,,
+pipenv/vendor/yaspin/__pycache__/signal_handlers.cpython-37.pyc,,
+pipenv/vendor/yaspin/__pycache__/spinners.cpython-37.pyc,,
+pipenv/vendor/yaspin/__pycache__/termcolor.cpython-37.pyc,,
+pipenv/vendor/yaspin/__version__.py,sha256=EmjQZZiU5tIcoRQexzHL_v2ve9LTA9gkL4YDPO6J0I0,23
+pipenv/vendor/yaspin/api.py,sha256=r4_S5rYYOAdBeTFOgpkGnCYKHfAIPYUAfsasRAX-aQY,2528
+pipenv/vendor/yaspin/base_spinner.py,sha256=FI_aNxk0RR1iHSteqCK_XM_2btNEBR-9NKRhI0V9Sb4,316
+pipenv/vendor/yaspin/compat.py,sha256=39Lla8yBuaE__XnezzTIn0KUpTX6XVudQcdMtO4fOmk,438
+pipenv/vendor/yaspin/constants.py,sha256=yNFJ-_7_RB1HdifydyTT5ivKjG9_73tErebDT0GaiwE,1800
+pipenv/vendor/yaspin/core.py,sha256=ZYNJQwOFs7oudpbUvn-7qqlO-1yW9GIeSNLNgvbbYx4,16656
+pipenv/vendor/yaspin/data/spinners.json,sha256=o66DflXauzsU0-wcHJMRQTYObN7uoZV3z9h4K1Gw1yo,10683
+pipenv/vendor/yaspin/helpers.py,sha256=rLLJ3VGlfBnRw1spRwdWEjGqSKlkfk6fqyLgbRUYdyY,329
+pipenv/vendor/yaspin/signal_handlers.py,sha256=PgcJDfCT8YROojLXuIg-vCb4LGcIfiIN2ARyBnptyPc,929
+pipenv/vendor/yaspin/spinners.py,sha256=vTTPMQU100ZCzOt0cFRdHVsJ09grVH7dqOsu458qow0,470
+pipenv/vendor/yaspin/termcolor.py,sha256=OQYlYGVAKxWOtv7JxIiSEv-vJv5FCEa633FTzMerY7I,5044
+pipenv/vendor/zipp.LICENSE,sha256=pV4v_ptEmY5iHVHYwJS-0JrMS1I27nPX3zlaM7o8GP0,1050
+pipenv/vendor/zipp.py,sha256=at2n-fuj-jXv7XytlGT0wNMpVEyILk-O15wXSarOQww,5011
Index: env/Lib/site-packages/pipenv/project.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># -*- coding: utf-8 -*-\r\nimport base64\r\nimport fnmatch\r\nimport glob\r\nimport hashlib\r\nimport io\r\nimport json\r\nimport operator\r\nimport os\r\nimport re\r\nimport sys\r\n\r\nimport six\r\nimport toml\r\nimport tomlkit\r\nimport vistir\r\n\r\nimport pipfile\r\nimport pipfile.api\r\n\r\nfrom .vendor.cached_property import cached_property\r\n\r\nfrom .cmdparse import Script\r\nfrom .environment import Environment\r\nfrom .environments import (\r\n    PIPENV_DEFAULT_PYTHON_VERSION, PIPENV_IGNORE_VIRTUALENVS, PIPENV_MAX_DEPTH,\r\n    PIPENV_PIPFILE, PIPENV_PYTHON, PIPENV_TEST_INDEX, PIPENV_VENV_IN_PROJECT,\r\n    PIPENV_USE_SYSTEM, is_in_virtualenv, is_type_checking\r\n)\r\nfrom .vendor.requirementslib.models.utils import get_default_pyproject_backend\r\nfrom .utils import (\r\n    cleanup_toml, convert_toml_outline_tables, find_requirements,\r\n    get_canonical_names, get_url_name, get_workon_home, is_editable,\r\n    is_installable_file, is_star, is_valid_url, is_virtual_environment,\r\n    looks_like_dir, normalize_drive, pep423_name, proper_case, python_version,\r\n    safe_expandvars, get_pipenv_dist\r\n)\r\n\r\nif is_type_checking():\r\n    from typing import Dict, Text, Union\r\n    TSource = Dict[Text, Union[Text, bool]]\r\n\r\n\r\ndef _normalized(p):\r\n    if p is None:\r\n        return None\r\n    loc = vistir.compat.Path(p)\r\n    try:\r\n        loc = loc.resolve()\r\n    except OSError:\r\n        loc = loc.absolute()\r\n    # Recase the path properly on Windows. From https://stackoverflow.com/a/35229734/5043728\r\n    if os.name == 'nt':\r\n        matches = glob.glob(re.sub(r'([^:/\\\\])(?=[/\\\\]|$)', r'[\\1]', str(loc)))\r\n        path_str = matches and matches[0] or str(loc)\r\n    else:\r\n        path_str = str(loc)\r\n    return normalize_drive(os.path.abspath(path_str))\r\n\r\n\r\nDEFAULT_NEWLINES = u\"\\n\"\r\n\r\n\r\nclass _LockFileEncoder(json.JSONEncoder):\r\n    \"\"\"A specilized JSON encoder to convert loaded TOML data into a lock file.\r\n\r\n    This adds a few characteristics to the encoder:\r\n\r\n    * The JSON is always prettified with indents and spaces.\r\n    * TOMLKit's container elements are seamlessly encodable.\r\n    * The output is always UTF-8-encoded text, never binary, even on Python 2.\r\n    \"\"\"\r\n\r\n    def __init__(self):\r\n        super(_LockFileEncoder, self).__init__(\r\n            indent=4, separators=(\",\", \": \"), sort_keys=True\r\n        )\r\n\r\n    def default(self, obj):\r\n        if isinstance(obj, vistir.compat.Path):\r\n            obj = obj.as_posix()\r\n        return super(_LockFileEncoder, self).default(obj)\r\n\r\n    def encode(self, obj):\r\n        content = super(_LockFileEncoder, self).encode(obj)\r\n        if not isinstance(content, six.text_type):\r\n            content = content.decode(\"utf-8\")\r\n        return content\r\n\r\n\r\ndef preferred_newlines(f):\r\n    if isinstance(f.newlines, six.text_type):\r\n        return f.newlines\r\n    return DEFAULT_NEWLINES\r\n\r\n\r\nif PIPENV_PIPFILE:\r\n    if not os.path.isfile(PIPENV_PIPFILE):\r\n        raise RuntimeError(\"Given PIPENV_PIPFILE is not found!\")\r\n\r\n    else:\r\n        PIPENV_PIPFILE = _normalized(PIPENV_PIPFILE)\r\n        # Overwrite environment variable so that subprocesses can get the correct path.\r\n        # See https://github.com/pypa/pipenv/issues/3584\r\n        os.environ['PIPENV_PIPFILE'] = PIPENV_PIPFILE\r\n# (path, file contents) => TOMLFile\r\n# keeps track of pipfiles that we've seen so we do not need to re-parse 'em\r\n_pipfile_cache = {}\r\n\r\n\r\nif PIPENV_TEST_INDEX:\r\n    DEFAULT_SOURCE = {\r\n        u\"url\": PIPENV_TEST_INDEX,\r\n        u\"verify_ssl\": True,\r\n        u\"name\": u\"custom\",\r\n    }\r\nelse:\r\n    DEFAULT_SOURCE = {\r\n        u\"url\": u\"https://pypi.org/simple\",\r\n        u\"verify_ssl\": True,\r\n        u\"name\": u\"pypi\",\r\n    }\r\n\r\npipfile.api.DEFAULT_SOURCE = DEFAULT_SOURCE\r\n\r\n\r\nclass SourceNotFound(KeyError):\r\n    pass\r\n\r\n\r\nclass Project(object):\r\n    \"\"\"docstring for Project\"\"\"\r\n\r\n    _lockfile_encoder = _LockFileEncoder()\r\n\r\n    def __init__(self, which=None, python_version=None, chdir=True):\r\n        super(Project, self).__init__()\r\n        self._name = None\r\n        self._virtualenv_location = None\r\n        self._download_location = None\r\n        self._proper_names_db_path = None\r\n        self._pipfile_location = None\r\n        self._pipfile_newlines = DEFAULT_NEWLINES\r\n        self._lockfile_newlines = DEFAULT_NEWLINES\r\n        self._requirements_location = None\r\n        self._original_dir = os.path.abspath(os.curdir)\r\n        self._environment = None\r\n        self._which = which\r\n        self._build_system = {\r\n            \"requires\": [\"setuptools\", \"wheel\"]\r\n        }\r\n        self.python_version = python_version\r\n        # Hack to skip this during pipenv run, or -r.\r\n        if (\"run\" not in sys.argv) and chdir:\r\n            try:\r\n                os.chdir(self.project_directory)\r\n            except (TypeError, AttributeError):\r\n                pass\r\n\r\n    def path_to(self, p):\r\n        \"\"\"Returns the absolute path to a given relative path.\"\"\"\r\n        if os.path.isabs(p):\r\n            return p\r\n\r\n        return os.sep.join([self._original_dir, p])\r\n\r\n    def _build_package_list(self, package_section):\r\n        \"\"\"Returns a list of packages for pip-tools to consume.\"\"\"\r\n        from pipenv.vendor.requirementslib.utils import is_vcs\r\n        ps = {}\r\n        # TODO: Separate the logic for showing packages from the filters for supplying pip-tools\r\n        for k, v in self.parsed_pipfile.get(package_section, {}).items():\r\n            # Skip editable VCS deps.\r\n            if hasattr(v, \"keys\"):\r\n                # When a vcs url is gven without editable it only appears as a key\r\n                # Eliminate any vcs, path, or url entries which are not editable\r\n                # Since pip-tools can't do deep resolution on them, even setuptools-installable ones\r\n                if (\r\n                    is_vcs(v)\r\n                    or is_vcs(k)\r\n                    or (is_installable_file(k) or is_installable_file(v))\r\n                    or any(\r\n                        (\r\n                            prefix in v\r\n                            and (os.path.isfile(v[prefix]) or is_valid_url(v[prefix]))\r\n                        )\r\n                        for prefix in [\"path\", \"file\"]\r\n                    )\r\n                ):\r\n                    # If they are editable, do resolve them\r\n                    if \"editable\" not in v:\r\n                        # allow wheels to be passed through\r\n                        if not (\r\n                            hasattr(v, \"keys\")\r\n                            and v.get(\"path\", v.get(\"file\", \"\")).endswith(\".whl\")\r\n                        ):\r\n                            continue\r\n                        ps.update({k: v})\r\n\r\n                    else:\r\n                        ps.update({k: v})\r\n                else:\r\n                    ps.update({k: v})\r\n            else:\r\n                # Since these entries have no attributes we know they are not editable\r\n                # So we can safely exclude things that need to be editable in order to be resolved\r\n                # First exclude anything that is a vcs entry either in the key or value\r\n                if not (\r\n                    any(is_vcs(i) for i in [k, v])\r\n                    # Then exclude any installable files that are not directories\r\n                    # Because pip-tools can resolve setup.py for example\r\n                    or any(is_installable_file(i) for i in [k, v])\r\n                    # Then exclude any URLs because they need to be editable also\r\n                    # Things that are excluded can only be 'shallow resolved'\r\n                    or any(is_valid_url(i) for i in [k, v])\r\n                ):\r\n                    ps.update({k: v})\r\n        return ps\r\n\r\n    @property\r\n    def name(self):\r\n        if self._name is None:\r\n            self._name = self.pipfile_location.split(os.sep)[-2]\r\n        return self._name\r\n\r\n    @property\r\n    def pipfile_exists(self):\r\n        return os.path.isfile(self.pipfile_location)\r\n\r\n    @property\r\n    def required_python_version(self):\r\n        if self.pipfile_exists:\r\n            required = self.parsed_pipfile.get(\"requires\", {}).get(\r\n                \"python_full_version\"\r\n            )\r\n            if not required:\r\n                required = self.parsed_pipfile.get(\"requires\", {}).get(\"python_version\")\r\n            if required != \"*\":\r\n                return required\r\n\r\n    @property\r\n    def project_directory(self):\r\n        return os.path.abspath(os.path.join(self.pipfile_location, os.pardir))\r\n\r\n    @property\r\n    def requirements_exists(self):\r\n        return bool(self.requirements_location)\r\n\r\n    def is_venv_in_project(self):\r\n        return PIPENV_VENV_IN_PROJECT or (\r\n            self.project_directory\r\n            and os.path.isdir(os.path.join(self.project_directory, \".venv\"))\r\n        )\r\n\r\n    @property\r\n    def virtualenv_exists(self):\r\n        if os.path.exists(self.virtualenv_location):\r\n            if os.name == \"nt\":\r\n                extra = [\"Scripts\", \"activate.bat\"]\r\n            else:\r\n                extra = [\"bin\", \"activate\"]\r\n            return os.path.isfile(os.sep.join([self.virtualenv_location] + extra))\r\n\r\n        return False\r\n\r\n    def get_location_for_virtualenv(self):\r\n        # If there's no project yet, set location based on config.\r\n        if not self.project_directory:\r\n            if self.is_venv_in_project():\r\n                return os.path.abspath(\".venv\")\r\n            return str(get_workon_home().joinpath(self.virtualenv_name))\r\n\r\n        dot_venv = os.path.join(self.project_directory, \".venv\")\r\n\r\n        # If there's no .venv in project root, set location based on config.\r\n        if not os.path.exists(dot_venv):\r\n            if self.is_venv_in_project():\r\n                return dot_venv\r\n            return str(get_workon_home().joinpath(self.virtualenv_name))\r\n\r\n        # If .venv in project root is a directory, use it.\r\n        if os.path.isdir(dot_venv):\r\n            return dot_venv\r\n\r\n        # Now we assume .venv in project root is a file. Use its content.\r\n        with io.open(dot_venv) as f:\r\n            name = f.read().strip()\r\n\r\n        # If content looks like a path, use it as a relative path.\r\n        # Otherwise use directory named after content in WORKON_HOME.\r\n        if looks_like_dir(name):\r\n            path = vistir.compat.Path(self.project_directory, name)\r\n            return path.absolute().as_posix()\r\n        return str(get_workon_home().joinpath(name))\r\n\r\n    @property\r\n    def working_set(self):\r\n        from .utils import load_path\r\n        sys_path = load_path(self.which(\"python\"))\r\n        import pkg_resources\r\n        return pkg_resources.WorkingSet(sys_path)\r\n\r\n    @property\r\n    def installed_packages(self):\r\n        return self.environment.get_installed_packages()\r\n\r\n    @property\r\n    def installed_package_names(self):\r\n        return get_canonical_names([pkg.key for pkg in self.installed_packages])\r\n\r\n    @property\r\n    def lockfile_package_names(self):\r\n        dev_keys = get_canonical_names(self.lockfile_content[\"develop\"].keys())\r\n        default_keys = get_canonical_names(self.lockfile_content[\"default\"].keys())\r\n        return {\r\n            \"dev\": dev_keys,\r\n            \"default\": default_keys,\r\n            \"combined\": dev_keys | default_keys\r\n        }\r\n\r\n    @property\r\n    def pipfile_package_names(self):\r\n        dev_keys = get_canonical_names(self.dev_packages.keys())\r\n        default_keys = get_canonical_names(self.packages.keys())\r\n        return {\r\n            \"dev\": dev_keys,\r\n            \"default\": default_keys,\r\n            \"combined\": dev_keys | default_keys\r\n        }\r\n\r\n    def get_environment(self, allow_global=False):\r\n        # type: (bool) -> Environment\r\n        if allow_global:\r\n            prefix = sys.prefix\r\n        else:\r\n            prefix = self.virtualenv_location\r\n        is_venv = is_in_virtualenv()\r\n        sources = self.sources if self.sources else [DEFAULT_SOURCE]\r\n        environment = Environment(\r\n            prefix=prefix, is_venv=is_venv, sources=sources, pipfile=self.parsed_pipfile,\r\n            project=self\r\n        )\r\n        pipenv_dist = get_pipenv_dist(pkg=\"pipenv\")\r\n        if pipenv_dist:\r\n            environment.extend_dists(pipenv_dist)\r\n        else:\r\n            environment.add_dist(\"pipenv\")\r\n        return environment\r\n\r\n    @property\r\n    def environment(self):\r\n        if not self._environment:\r\n            allow_global = os.environ.get(\"PIPENV_USE_SYSTEM\", PIPENV_USE_SYSTEM)\r\n            self._environment = self.get_environment(allow_global=allow_global)\r\n        return self._environment\r\n\r\n    def get_outdated_packages(self):\r\n        return self.environment.get_outdated_packages(pre=self.pipfile.get(\"pre\", False))\r\n\r\n    @classmethod\r\n    def _sanitize(cls, name):\r\n        # Replace dangerous characters into '_'. The length of the sanitized\r\n        # project name is limited as 42 because of the limit of linux kernel\r\n        #\r\n        # 42 = 127 - len('/home//.local/share/virtualenvs//bin/python2') - 32 - len('-HASHHASH')\r\n        #\r\n        #      127 : BINPRM_BUF_SIZE - 1\r\n        #       32 : Maximum length of username\r\n        #\r\n        # References:\r\n        #   https://www.gnu.org/software/bash/manual/html_node/Double-Quotes.html\r\n        #   http://www.tldp.org/LDP/abs/html/special-chars.html#FIELDREF\r\n        #   https://github.com/torvalds/linux/blob/2bfe01ef/include/uapi/linux/binfmts.h#L18\r\n        return re.sub(r'[ $`!*@\"\\\\\\r\\n\\t]', \"_\", name)[0:42]\r\n\r\n    def _get_virtualenv_hash(self, name):\r\n        \"\"\"Get the name of the virtualenv adjusted for windows if needed\r\n\r\n        Returns (name, encoded_hash)\r\n        \"\"\"\r\n\r\n        def get_name(name, location):\r\n            name = self._sanitize(name)\r\n            hash = hashlib.sha256(location.encode()).digest()[:6]\r\n            encoded_hash = base64.urlsafe_b64encode(hash).decode()\r\n            return name, encoded_hash[:8]\r\n\r\n        clean_name, encoded_hash = get_name(name, self.pipfile_location)\r\n        venv_name = \"{0}-{1}\".format(clean_name, encoded_hash)\r\n\r\n        # This should work most of the time for\r\n        #   Case-sensitive filesystems,\r\n        #   In-project venv\r\n        #   \"Proper\" path casing (on non-case-sensitive filesystems).\r\n        if (\r\n            not fnmatch.fnmatch(\"A\", \"a\")\r\n            or self.is_venv_in_project()\r\n            or get_workon_home().joinpath(venv_name).exists()\r\n        ):\r\n            return clean_name, encoded_hash\r\n\r\n        # Check for different capitalization of the same project.\r\n        for path in get_workon_home().iterdir():\r\n            if not is_virtual_environment(path):\r\n                continue\r\n            try:\r\n                env_name, hash_ = path.name.rsplit(\"-\", 1)\r\n            except ValueError:\r\n                continue\r\n            if len(hash_) != 8 or env_name.lower() != name.lower():\r\n                continue\r\n            return get_name(env_name, self.pipfile_location.replace(name, env_name))\r\n\r\n        # Use the default if no matching env exists.\r\n        return clean_name, encoded_hash\r\n\r\n    @property\r\n    def virtualenv_name(self):\r\n        sanitized, encoded_hash = self._get_virtualenv_hash(self.name)\r\n        suffix = \"-{0}\".format(PIPENV_PYTHON) if PIPENV_PYTHON else \"\"\r\n        # If the pipfile was located at '/home/user/MY_PROJECT/Pipfile',\r\n        # the name of its virtualenv will be 'my-project-wyUfYPqE'\r\n        return sanitized + \"-\" + encoded_hash + suffix\r\n\r\n    @property\r\n    def virtualenv_location(self):\r\n        # if VIRTUAL_ENV is set, use that.\r\n        virtualenv_env = os.getenv(\"VIRTUAL_ENV\")\r\n        if (\r\n            \"PIPENV_ACTIVE\" not in os.environ\r\n            and not PIPENV_IGNORE_VIRTUALENVS and virtualenv_env\r\n        ):\r\n            return virtualenv_env\r\n\r\n        if not self._virtualenv_location:  # Use cached version, if available.\r\n            assert self.project_directory, \"project not created\"\r\n            self._virtualenv_location = self.get_location_for_virtualenv()\r\n        return self._virtualenv_location\r\n\r\n    @property\r\n    def virtualenv_src_location(self):\r\n        if self.virtualenv_location:\r\n            loc = os.sep.join([self.virtualenv_location, \"src\"])\r\n        else:\r\n            loc = os.sep.join([self.project_directory, \"src\"])\r\n        vistir.path.mkdir_p(loc)\r\n        return loc\r\n\r\n    @property\r\n    def download_location(self):\r\n        if self._download_location is None:\r\n            loc = os.sep.join([self.virtualenv_location, \"downloads\"])\r\n            self._download_location = loc\r\n        # Create the directory, if it doesn't exist.\r\n        vistir.path.mkdir_p(self._download_location)\r\n        return self._download_location\r\n\r\n    @property\r\n    def proper_names_db_path(self):\r\n        if self._proper_names_db_path is None:\r\n            self._proper_names_db_path = vistir.compat.Path(\r\n                self.virtualenv_location, \"pipenv-proper-names.txt\"\r\n            )\r\n        self._proper_names_db_path.touch()  # Ensure the file exists.\r\n        return self._proper_names_db_path\r\n\r\n    @property\r\n    def proper_names(self):\r\n        with self.proper_names_db_path.open() as f:\r\n            return f.read().splitlines()\r\n\r\n    def register_proper_name(self, name):\r\n        \"\"\"Registers a proper name to the database.\"\"\"\r\n        with self.proper_names_db_path.open(\"a\") as f:\r\n            f.write(u\"{0}\\n\".format(name))\r\n\r\n    @property\r\n    def pipfile_location(self):\r\n        if PIPENV_PIPFILE:\r\n            return PIPENV_PIPFILE\r\n\r\n        if self._pipfile_location is None:\r\n            try:\r\n                loc = pipfile.Pipfile.find(max_depth=PIPENV_MAX_DEPTH)\r\n            except RuntimeError:\r\n                loc = \"Pipfile\"\r\n            self._pipfile_location = _normalized(loc)\r\n        return self._pipfile_location\r\n\r\n    @property\r\n    def requirements_location(self):\r\n        if self._requirements_location is None:\r\n            try:\r\n                loc = find_requirements(max_depth=PIPENV_MAX_DEPTH)\r\n            except RuntimeError:\r\n                loc = None\r\n            self._requirements_location = loc\r\n        return self._requirements_location\r\n\r\n    @property\r\n    def parsed_pipfile(self):\r\n        \"\"\"Parse Pipfile into a TOMLFile and cache it\r\n\r\n        (call clear_pipfile_cache() afterwards if mutating)\"\"\"\r\n        contents = self.read_pipfile()\r\n        # use full contents to get around str/bytes 2/3 issues\r\n        cache_key = (self.pipfile_location, contents)\r\n        if cache_key not in _pipfile_cache:\r\n            parsed = self._parse_pipfile(contents)\r\n            _pipfile_cache[cache_key] = parsed\r\n        return _pipfile_cache[cache_key]\r\n\r\n    def read_pipfile(self):\r\n        # Open the pipfile, read it into memory.\r\n        if not self.pipfile_exists:\r\n            return \"\"\r\n        with io.open(self.pipfile_location) as f:\r\n            contents = f.read()\r\n            self._pipfile_newlines = preferred_newlines(f)\r\n\r\n        return contents\r\n\r\n    def clear_pipfile_cache(self):\r\n        \"\"\"Clear pipfile cache (e.g., so we can mutate parsed pipfile)\"\"\"\r\n        _pipfile_cache.clear()\r\n\r\n    def _parse_pipfile(self, contents):\r\n        try:\r\n            return tomlkit.parse(contents)\r\n        except Exception:\r\n            # We lose comments here, but it's for the best.)\r\n            # Fallback to toml parser, for large files.\r\n            return toml.loads(contents)\r\n\r\n    def _read_pyproject(self):\r\n        pyproject = self.path_to(\"pyproject.toml\")\r\n        if os.path.exists(pyproject):\r\n            self._pyproject = toml.load(pyproject)\r\n            build_system = self._pyproject.get(\"build-system\", None)\r\n            if not os.path.exists(self.path_to(\"setup.py\")):\r\n                if not build_system or not build_system.get(\"requires\"):\r\n                    build_system = {\r\n                        \"requires\": [\"setuptools>=40.8.0\", \"wheel\"],\r\n                        \"build-backend\": get_default_pyproject_backend(),\r\n                    }\r\n                self._build_system = build_system\r\n\r\n    @property\r\n    def build_requires(self):\r\n        return self._build_system.get(\"requires\", [\"setuptools>=40.8.0\", \"wheel\"])\r\n\r\n    @property\r\n    def build_backend(self):\r\n        return self._build_system.get(\"build-backend\", get_default_pyproject_backend())\r\n\r\n    @property\r\n    def settings(self):\r\n        \"\"\"A dictionary of the settings added to the Pipfile.\"\"\"\r\n        return self.parsed_pipfile.get(\"pipenv\", {})\r\n\r\n    def has_script(self, name):\r\n        try:\r\n            return name in self.parsed_pipfile[\"scripts\"]\r\n        except KeyError:\r\n            return False\r\n\r\n    def build_script(self, name, extra_args=None):\r\n        try:\r\n            script = Script.parse(self.parsed_pipfile[\"scripts\"][name])\r\n        except KeyError:\r\n            script = Script(name)\r\n        if extra_args:\r\n            script.extend(extra_args)\r\n        return script\r\n\r\n    def update_settings(self, d):\r\n        settings = self.settings\r\n        changed = False\r\n        for new in d:\r\n            if new not in settings:\r\n                settings[new] = d[new]\r\n                changed = True\r\n        if changed:\r\n            p = self.parsed_pipfile\r\n            p[\"pipenv\"] = settings\r\n            # Write the changes to disk.\r\n            self.write_toml(p)\r\n\r\n    @property\r\n    def _lockfile(self):\r\n        \"\"\"Pipfile.lock divided by PyPI and external dependencies.\"\"\"\r\n        pfile = pipfile.load(self.pipfile_location, inject_env=False)\r\n        lockfile = json.loads(pfile.lock())\r\n        for section in (\"default\", \"develop\"):\r\n            lock_section = lockfile.get(section, {})\r\n            for key in list(lock_section.keys()):\r\n                norm_key = pep423_name(key)\r\n                lockfile[section][norm_key] = lock_section.pop(key)\r\n        return lockfile\r\n\r\n    @property\r\n    def _pipfile(self):\r\n        from .vendor.requirementslib.models.pipfile import Pipfile as ReqLibPipfile\r\n        pf = ReqLibPipfile.load(self.pipfile_location)\r\n        return pf\r\n\r\n    @property\r\n    def lockfile_location(self):\r\n        return \"{0}.lock\".format(self.pipfile_location)\r\n\r\n    @property\r\n    def lockfile_exists(self):\r\n        return os.path.isfile(self.lockfile_location)\r\n\r\n    @property\r\n    def lockfile_content(self):\r\n        return self.load_lockfile()\r\n\r\n    def _get_editable_packages(self, dev=False):\r\n        section = \"dev-packages\" if dev else \"packages\"\r\n        packages = {\r\n            k: v\r\n            for k, v in self.parsed_pipfile.get(section, {}).items()\r\n            if is_editable(k) or is_editable(v)\r\n        }\r\n        return packages\r\n\r\n    def _get_vcs_packages(self, dev=False):\r\n        from pipenv.vendor.requirementslib.utils import is_vcs\r\n        section = \"dev-packages\" if dev else \"packages\"\r\n        packages = {\r\n            k: v\r\n            for k, v in self.parsed_pipfile.get(section, {}).items()\r\n            if is_vcs(v) or is_vcs(k)\r\n        }\r\n        return packages or {}\r\n\r\n    @property\r\n    def editable_packages(self):\r\n        return self._get_editable_packages(dev=False)\r\n\r\n    @property\r\n    def editable_dev_packages(self):\r\n        return self._get_editable_packages(dev=True)\r\n\r\n    @property\r\n    def vcs_packages(self):\r\n        \"\"\"Returns a list of VCS packages, for not pip-tools to consume.\"\"\"\r\n        return self._get_vcs_packages(dev=False)\r\n\r\n    @property\r\n    def vcs_dev_packages(self):\r\n        \"\"\"Returns a list of VCS packages, for not pip-tools to consume.\"\"\"\r\n        return self._get_vcs_packages(dev=True)\r\n\r\n    @property\r\n    def all_packages(self):\r\n        \"\"\"Returns a list of all packages.\"\"\"\r\n        p = dict(self.parsed_pipfile.get(\"dev-packages\", {}))\r\n        p.update(self.parsed_pipfile.get(\"packages\", {}))\r\n        return p\r\n\r\n    @property\r\n    def packages(self):\r\n        \"\"\"Returns a list of packages, for pip-tools to consume.\"\"\"\r\n        return self._build_package_list(\"packages\")\r\n\r\n    @property\r\n    def dev_packages(self):\r\n        \"\"\"Returns a list of dev-packages, for pip-tools to consume.\"\"\"\r\n        return self._build_package_list(\"dev-packages\")\r\n\r\n    @property\r\n    def pipfile_is_empty(self):\r\n        if not self.pipfile_exists:\r\n            return True\r\n\r\n        if not len(self.read_pipfile()):\r\n            return True\r\n\r\n        return False\r\n\r\n    def create_pipfile(self, python=None):\r\n        \"\"\"Creates the Pipfile, filled with juicy defaults.\"\"\"\r\n        from .vendor.pip_shims.shims import (\r\n            ConfigOptionParser, make_option_group, index_group\r\n        )\r\n\r\n        config_parser = ConfigOptionParser(name=self.name)\r\n        config_parser.add_option_group(make_option_group(index_group, config_parser))\r\n        install = config_parser.option_groups[0]\r\n        indexes = (\r\n            \" \".join(install.get_option(\"--extra-index-url\").default)\r\n            .lstrip(\"\\n\")\r\n            .split(\"\\n\")\r\n        )\r\n        sources = [DEFAULT_SOURCE]\r\n        for i, index in enumerate(indexes):\r\n            if not index:\r\n                continue\r\n\r\n            source_name = \"pip_index_{}\".format(i)\r\n            verify_ssl = index.startswith(\"https\")\r\n            sources.append(\r\n                {u\"url\": index, u\"verify_ssl\": verify_ssl, u\"name\": source_name}\r\n            )\r\n\r\n        data = {\r\n            u\"source\": sources,\r\n            # Default packages.\r\n            u\"packages\": {},\r\n            u\"dev-packages\": {},\r\n        }\r\n        # Default requires.\r\n        required_python = python\r\n        if not python:\r\n            if self.virtualenv_location:\r\n                required_python = self.which(\"python\", self.virtualenv_location)\r\n            else:\r\n                required_python = self.which(\"python\")\r\n        version = python_version(required_python) or PIPENV_DEFAULT_PYTHON_VERSION\r\n        if version and len(version) >= 3:\r\n            data[u\"requires\"] = {\"python_version\": version[: len(\"2.7\")]}\r\n        self.write_toml(data)\r\n\r\n    @classmethod\r\n    def populate_source(cls, source):\r\n        \"\"\"Derive missing values of source from the existing fields.\"\"\"\r\n        # Only URL pararemter is mandatory, let the KeyError be thrown.\r\n        if \"name\" not in source:\r\n            source[\"name\"] = get_url_name(source[\"url\"])\r\n        if \"verify_ssl\" not in source:\r\n            source[\"verify_ssl\"] = \"https://\" in source[\"url\"]\r\n        if not isinstance(source[\"verify_ssl\"], bool):\r\n            source[\"verify_ssl\"] = str(source[\"verify_ssl\"]).lower() == \"true\"\r\n        return source\r\n\r\n    def get_or_create_lockfile(self, from_pipfile=False):\r\n        from pipenv.vendor.requirementslib.models.lockfile import Lockfile as Req_Lockfile\r\n        lockfile = None\r\n        if from_pipfile and self.pipfile_exists:\r\n            lockfile_dict = {\r\n                \"default\": self._lockfile[\"default\"].copy(),\r\n                \"develop\": self._lockfile[\"develop\"].copy()\r\n            }\r\n            lockfile_dict.update({\"_meta\": self.get_lockfile_meta()})\r\n            lockfile = Req_Lockfile.from_data(\r\n                path=self.lockfile_location, data=lockfile_dict, meta_from_project=False\r\n            )\r\n        elif self.lockfile_exists:\r\n            try:\r\n                lockfile = Req_Lockfile.load(self.lockfile_location)\r\n            except OSError:\r\n                lockfile = Req_Lockfile.from_data(self.lockfile_location, self.lockfile_content)\r\n        else:\r\n            lockfile = Req_Lockfile.from_data(path=self.lockfile_location, data=self._lockfile, meta_from_project=False)\r\n        if lockfile._lockfile is not None:\r\n            return lockfile\r\n        if self.lockfile_exists and self.lockfile_content:\r\n            lockfile_dict = self.lockfile_content.copy()\r\n            sources = lockfile_dict.get(\"_meta\", {}).get(\"sources\", [])\r\n            if not sources:\r\n                sources = self.pipfile_sources\r\n            elif not isinstance(sources, list):\r\n                sources = [sources]\r\n            lockfile_dict[\"_meta\"][\"sources\"] = [\r\n                self.populate_source(s) for s in sources\r\n            ]\r\n            _created_lockfile = Req_Lockfile.from_data(\r\n                path=self.lockfile_location, data=lockfile_dict, meta_from_project=False\r\n            )\r\n            lockfile._lockfile = lockfile.projectfile.model = _created_lockfile\r\n            return lockfile\r\n        else:\r\n            return self.get_or_create_lockfile(from_pipfile=True)\r\n\r\n    def get_lockfile_meta(self):\r\n        from .vendor.plette.lockfiles import PIPFILE_SPEC_CURRENT\r\n        if self.lockfile_exists:\r\n            sources = self.lockfile_content.get(\"_meta\", {}).get(\"sources\", [])\r\n        else:\r\n            sources = [dict(source) for source in self.parsed_pipfile[\"source\"]]\r\n        if not isinstance(sources, list):\r\n            sources = [sources]\r\n        return {\r\n            \"hash\": {\"sha256\": self.calculate_pipfile_hash()},\r\n            \"pipfile-spec\": PIPFILE_SPEC_CURRENT,\r\n            \"sources\": [self.populate_source(s) for s in sources],\r\n            \"requires\": self.parsed_pipfile.get(\"requires\", {})\r\n        }\r\n\r\n    def write_toml(self, data, path=None):\r\n        \"\"\"Writes the given data structure out as TOML.\"\"\"\r\n        if path is None:\r\n            path = self.pipfile_location\r\n        data = convert_toml_outline_tables(data)\r\n        try:\r\n            formatted_data = tomlkit.dumps(data).rstrip()\r\n        except Exception:\r\n            document = tomlkit.document()\r\n            for section in (\"packages\", \"dev-packages\"):\r\n                document[section] = tomlkit.table()\r\n                # Convert things to inline tables — fancy :)\r\n                for package in data.get(section, {}):\r\n                    if hasattr(data[section][package], \"keys\"):\r\n                        table = tomlkit.inline_table()\r\n                        table.update(data[section][package])\r\n                        document[section][package] = table\r\n                    else:\r\n                        document[section][package] = tomlkit.string(data[section][package])\r\n            formatted_data = tomlkit.dumps(document).rstrip()\r\n\r\n        if (\r\n            vistir.compat.Path(path).absolute()\r\n            == vistir.compat.Path(self.pipfile_location).absolute()\r\n        ):\r\n            newlines = self._pipfile_newlines\r\n        else:\r\n            newlines = DEFAULT_NEWLINES\r\n        formatted_data = cleanup_toml(formatted_data)\r\n        with io.open(path, \"w\", newline=newlines) as f:\r\n            f.write(formatted_data)\r\n        # pipfile is mutated!\r\n        self.clear_pipfile_cache()\r\n\r\n    def write_lockfile(self, content):\r\n        \"\"\"Write out the lockfile.\r\n        \"\"\"\r\n        s = self._lockfile_encoder.encode(content)\r\n        open_kwargs = {\"newline\": self._lockfile_newlines, \"encoding\": \"utf-8\"}\r\n        with vistir.contextmanagers.atomic_open_for_write(\r\n            self.lockfile_location, **open_kwargs\r\n        ) as f:\r\n            f.write(s)\r\n            # Write newline at end of document. GH-319.\r\n            # Only need '\\n' here; the file object handles the rest.\r\n            if not s.endswith(u\"\\n\"):\r\n                f.write(u\"\\n\")\r\n\r\n    @property\r\n    def pipfile_sources(self):\r\n        if self.pipfile_is_empty or \"source\" not in self.parsed_pipfile:\r\n            return [DEFAULT_SOURCE]\r\n        # We need to make copies of the source info so we don't\r\n        # accidentally modify the cache. See #2100 where values are\r\n        # written after the os.path.expandvars() call.\r\n        return [\r\n            {k: safe_expandvars(v) for k, v in source.items()}\r\n            for source in self.parsed_pipfile[\"source\"]\r\n        ]\r\n\r\n    @property\r\n    def sources(self):\r\n        if self.lockfile_exists and hasattr(self.lockfile_content, \"keys\"):\r\n            meta_ = self.lockfile_content.get(\"_meta\", {})\r\n            sources_ = meta_.get(\"sources\")\r\n            if sources_:\r\n                return sources_\r\n\r\n        else:\r\n            return self.pipfile_sources\r\n\r\n    @property\r\n    def index_urls(self):\r\n        return [src.get(\"url\") for src in self.sources]\r\n\r\n    def find_source(self, source):\r\n        \"\"\"\r\n        Given a source, find it.\r\n\r\n        source can be a url or an index name.\r\n        \"\"\"\r\n        if not is_valid_url(source):\r\n            try:\r\n                source = self.get_source(name=source)\r\n            except SourceNotFound:\r\n                source = self.get_source(url=source)\r\n        else:\r\n            source = self.get_source(url=source)\r\n        return source\r\n\r\n    def get_source(self, name=None, url=None, refresh=False):\r\n        from .utils import is_url_equal\r\n\r\n        def find_source(sources, name=None, url=None):\r\n            source = None\r\n            if name:\r\n                source = next(iter(\r\n                    s for s in sources if \"name\" in s and s[\"name\"] == name\r\n                ), None)\r\n            elif url:\r\n                source = next(iter(\r\n                    s for s in sources\r\n                    if \"url\" in s and is_url_equal(url, s.get(\"url\", \"\"))\r\n                ), None)\r\n            if source is not None:\r\n                return source\r\n\r\n        sources = (self.sources, self.pipfile_sources)\r\n        if refresh:\r\n            self.clear_pipfile_cache()\r\n            sources = reversed(sources)\r\n        found = next(\r\n            iter(find_source(source, name=name, url=url) for source in sources), None\r\n        )\r\n        target = next(iter(t for t in (name, url) if t is not None))\r\n        if found is None:\r\n            raise SourceNotFound(target)\r\n        return found\r\n\r\n    def get_package_name_in_pipfile(self, package_name, dev=False):\r\n        \"\"\"Get the equivalent package name in pipfile\"\"\"\r\n        key = \"dev-packages\" if dev else \"packages\"\r\n        section = self.parsed_pipfile.get(key, {})\r\n        package_name = pep423_name(package_name)\r\n        for name in section.keys():\r\n            if pep423_name(name) == package_name:\r\n                return name\r\n        return None\r\n\r\n    def remove_package_from_pipfile(self, package_name, dev=False):\r\n        # Read and append Pipfile.\r\n        name = self.get_package_name_in_pipfile(package_name, dev)\r\n        key = \"dev-packages\" if dev else \"packages\"\r\n        p = self.parsed_pipfile\r\n        if name:\r\n            del p[key][name]\r\n            self.write_toml(p)\r\n\r\n    def remove_packages_from_pipfile(self, packages):\r\n        parsed = self.parsed_pipfile\r\n        packages = set([pep423_name(pkg) for pkg in packages])\r\n        for section in (\"dev-packages\", \"packages\"):\r\n            pipfile_section = parsed.get(section, {})\r\n            pipfile_packages = set([\r\n                pep423_name(pkg_name) for pkg_name in pipfile_section.keys()\r\n            ])\r\n            to_remove = packages & pipfile_packages\r\n            # The normal toml parser can't handle deleting packages with preceding newlines\r\n            is_dev = section == \"dev-packages\"\r\n            for pkg in to_remove:\r\n                pkg_name = self.get_package_name_in_pipfile(pkg, dev=is_dev)\r\n                del parsed[section][pkg_name]\r\n        self.write_toml(parsed)\r\n\r\n    def add_package_to_pipfile(self, package, dev=False):\r\n        from .vendor.requirementslib import Requirement\r\n\r\n        # Read and append Pipfile.\r\n        p = self.parsed_pipfile\r\n        # Don't re-capitalize file URLs or VCSs.\r\n        if not isinstance(package, Requirement):\r\n            package = Requirement.from_line(package.strip())\r\n        req_name, converted = package.pipfile_entry\r\n        key = \"dev-packages\" if dev else \"packages\"\r\n        # Set empty group if it doesn't exist yet.\r\n        if key not in p:\r\n            p[key] = {}\r\n        name = self.get_package_name_in_pipfile(req_name, dev)\r\n        if name and is_star(converted):\r\n            # Skip for wildcard version\r\n            return\r\n        # Add the package to the group.\r\n        p[key][name or pep423_name(req_name)] = converted\r\n        # Write Pipfile.\r\n        self.write_toml(p)\r\n\r\n    def src_name_from_url(self, index_url):\r\n        name, _, tld_guess = six.moves.urllib.parse.urlsplit(index_url).netloc.rpartition(\r\n            \".\"\r\n        )\r\n        src_name = name.replace(\".\", \"\")\r\n        try:\r\n            self.get_source(name=src_name)\r\n        except SourceNotFound:\r\n            name = src_name\r\n        else:\r\n            from random import randint\r\n            name = \"{0}-{1}\".format(src_name, randint(1, 1000))\r\n        return name\r\n\r\n    def add_index_to_pipfile(self, index, verify_ssl=True):\r\n        \"\"\"Adds a given index to the Pipfile.\"\"\"\r\n        # Read and append Pipfile.\r\n        p = self.parsed_pipfile\r\n        try:\r\n            self.get_source(url=index)\r\n        except SourceNotFound:\r\n            source = {\"url\": index, \"verify_ssl\": verify_ssl}\r\n        else:\r\n            return\r\n        source[\"name\"] = self.src_name_from_url(index)\r\n        # Add the package to the group.\r\n        if \"source\" not in p:\r\n            p[\"source\"] = [source]\r\n        else:\r\n            p[\"source\"].append(source)\r\n        # Write Pipfile.\r\n        self.write_toml(p)\r\n\r\n    def recase_pipfile(self):\r\n        if self.ensure_proper_casing():\r\n            self.write_toml(self.parsed_pipfile)\r\n\r\n    def load_lockfile(self, expand_env_vars=True):\r\n        with io.open(self.lockfile_location, encoding=\"utf-8\") as lock:\r\n            j = json.load(lock)\r\n            self._lockfile_newlines = preferred_newlines(lock)\r\n        # lockfile is just a string\r\n        if not j or not hasattr(j, \"keys\"):\r\n            return j\r\n\r\n        if expand_env_vars:\r\n            # Expand environment variables in Pipfile.lock at runtime.\r\n            for i, source in enumerate(j[\"_meta\"][\"sources\"][:]):\r\n                j[\"_meta\"][\"sources\"][i][\"url\"] = os.path.expandvars(\r\n                    j[\"_meta\"][\"sources\"][i][\"url\"]\r\n                )\r\n\r\n        return j\r\n\r\n    def get_lockfile_hash(self):\r\n        if not os.path.exists(self.lockfile_location):\r\n            return\r\n\r\n        try:\r\n            lockfile = self.load_lockfile(expand_env_vars=False)\r\n        except ValueError:\r\n            # Lockfile corrupted\r\n            return \"\"\r\n        if \"_meta\" in lockfile and hasattr(lockfile, \"keys\"):\r\n            return lockfile[\"_meta\"].get(\"hash\", {}).get(\"sha256\")\r\n        # Lockfile exists but has no hash at all\r\n        return \"\"\r\n\r\n    def calculate_pipfile_hash(self):\r\n        # Update the lockfile if it is out-of-date.\r\n        p = pipfile.load(self.pipfile_location, inject_env=False)\r\n        return p.hash\r\n\r\n    def ensure_proper_casing(self):\r\n        \"\"\"Ensures proper casing of Pipfile packages\"\"\"\r\n        pfile = self.parsed_pipfile\r\n        casing_changed = self.proper_case_section(pfile.get(\"packages\", {}))\r\n        casing_changed |= self.proper_case_section(pfile.get(\"dev-packages\", {}))\r\n        return casing_changed\r\n\r\n    def proper_case_section(self, section):\r\n        \"\"\"Verify proper casing is retrieved, when available, for each\r\n        dependency in the section.\r\n        \"\"\"\r\n        # Casing for section.\r\n        changed_values = False\r\n        unknown_names = [k for k in section.keys() if k not in set(self.proper_names)]\r\n        # Replace each package with proper casing.\r\n        for dep in unknown_names:\r\n            try:\r\n                # Get new casing for package name.\r\n                new_casing = proper_case(dep)\r\n            except IOError:\r\n                # Unable to normalize package name.\r\n                continue\r\n\r\n            if new_casing != dep:\r\n                changed_values = True\r\n                self.register_proper_name(new_casing)\r\n                # Replace old value with new value.\r\n                old_value = section[dep]\r\n                section[new_casing] = old_value\r\n                del section[dep]\r\n        # Return whether or not values have been changed.\r\n        return changed_values\r\n\r\n    @cached_property\r\n    def finders(self):\r\n        from .vendor.pythonfinder import Finder\r\n        scripts_dirname = \"Scripts\" if os.name == \"nt\" else \"bin\"\r\n        scripts_dir = os.path.join(self.virtualenv_location, scripts_dirname)\r\n        finders = [\r\n            Finder(path=scripts_dir, global_search=gs, system=False)\r\n            for gs in (False, True)\r\n        ]\r\n        return finders\r\n\r\n    @property\r\n    def finder(self):\r\n        return next(iter(self.finders), None)\r\n\r\n    def which(self, search, as_path=True):\r\n        find = operator.methodcaller(\"which\", search)\r\n        result = next(iter(filter(None, (find(finder) for finder in self.finders))), None)\r\n        if not result:\r\n            result = self._which(search)\r\n        else:\r\n            if as_path:\r\n                result = str(result.path)\r\n        return result\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- env/Lib/site-packages/pipenv/project.py	(revision 7de091c5b19e7b06e80c151f7100df6d0f893820)
+++ env/Lib/site-packages/pipenv/project.py	(date 1591098437582)
@@ -37,8 +37,14 @@
 )
 
 if is_type_checking():
-    from typing import Dict, Text, Union
+    import pkg_resources
+    from typing import Dict, List, Optional, Set, Text, Tuple, Union
     TSource = Dict[Text, Union[Text, bool]]
+    TPackageEntry = Dict[str, Union[bool, str, List[str]]]
+    TPackage = Dict[str, TPackageEntry]
+    TScripts = Dict[str, str]
+    TPipenv = Dict[str, bool]
+    TPipfile = Dict[str, Union[TPackage, TScripts, TPipenv, List[TSource]]]
 
 
 def _normalized(p):
@@ -158,6 +164,7 @@
                 pass
 
     def path_to(self, p):
+        # type: (str) -> str
         """Returns the absolute path to a given relative path."""
         if os.path.isabs(p):
             return p
@@ -219,16 +226,19 @@
 
     @property
     def name(self):
+        # type: () -> str
         if self._name is None:
             self._name = self.pipfile_location.split(os.sep)[-2]
         return self._name
 
     @property
     def pipfile_exists(self):
+        # type: () -> bool
         return os.path.isfile(self.pipfile_location)
 
     @property
     def required_python_version(self):
+        # type: () -> str
         if self.pipfile_exists:
             required = self.parsed_pipfile.get("requires", {}).get(
                 "python_full_version"
@@ -240,13 +250,16 @@
 
     @property
     def project_directory(self):
+        # type: () -> str
         return os.path.abspath(os.path.join(self.pipfile_location, os.pardir))
 
     @property
     def requirements_exists(self):
+        # type: () -> bool
         return bool(self.requirements_location)
 
     def is_venv_in_project(self):
+        # type: () -> bool
         return PIPENV_VENV_IN_PROJECT or (
             self.project_directory
             and os.path.isdir(os.path.join(self.project_directory, ".venv"))
@@ -254,6 +267,7 @@
 
     @property
     def virtualenv_exists(self):
+        # type: () -> bool
         if os.path.exists(self.virtualenv_location):
             if os.name == "nt":
                 extra = ["Scripts", "activate.bat"]
@@ -264,6 +278,7 @@
         return False
 
     def get_location_for_virtualenv(self):
+        # type: () -> str
         # If there's no project yet, set location based on config.
         if not self.project_directory:
             if self.is_venv_in_project():
@@ -295,6 +310,7 @@
 
     @property
     def working_set(self):
+        # type: () -> pkg_resources.WorkingSet
         from .utils import load_path
         sys_path = load_path(self.which("python"))
         import pkg_resources
@@ -306,10 +322,12 @@
 
     @property
     def installed_package_names(self):
+        # type: () -> List[str]
         return get_canonical_names([pkg.key for pkg in self.installed_packages])
 
     @property
     def lockfile_package_names(self):
+        # type: () -> Dict[str, Set[str]]
         dev_keys = get_canonical_names(self.lockfile_content["develop"].keys())
         default_keys = get_canonical_names(self.lockfile_content["default"].keys())
         return {
@@ -320,6 +338,7 @@
 
     @property
     def pipfile_package_names(self):
+        # type: () -> Dict[str, Set[str]]
         dev_keys = get_canonical_names(self.dev_packages.keys())
         default_keys = get_canonical_names(self.packages.keys())
         return {
@@ -330,11 +349,11 @@
 
     def get_environment(self, allow_global=False):
         # type: (bool) -> Environment
-        if allow_global:
+        is_venv = is_in_virtualenv()
+        if allow_global and not is_venv:
             prefix = sys.prefix
         else:
             prefix = self.virtualenv_location
-        is_venv = is_in_virtualenv()
         sources = self.sources if self.sources else [DEFAULT_SOURCE]
         environment = Environment(
             prefix=prefix, is_venv=is_venv, sources=sources, pipfile=self.parsed_pipfile,
@@ -349,16 +368,19 @@
 
     @property
     def environment(self):
+        # type: () -> Environment
         if not self._environment:
             allow_global = os.environ.get("PIPENV_USE_SYSTEM", PIPENV_USE_SYSTEM)
             self._environment = self.get_environment(allow_global=allow_global)
         return self._environment
 
     def get_outdated_packages(self):
+        # type: () -> List[pkg_resources.Distribution]
         return self.environment.get_outdated_packages(pre=self.pipfile.get("pre", False))
 
     @classmethod
     def _sanitize(cls, name):
+        # type: (str) -> Tuple[str, str]
         # Replace dangerous characters into '_'. The length of the sanitized
         # project name is limited as 42 because of the limit of linux kernel
         #
@@ -374,6 +396,7 @@
         return re.sub(r'[ $`!*@"\\\r\n\t]', "_", name)[0:42]
 
     def _get_virtualenv_hash(self, name):
+        # type: (str) -> str
         """Get the name of the virtualenv adjusted for windows if needed
 
         Returns (name, encoded_hash)
@@ -416,6 +439,7 @@
 
     @property
     def virtualenv_name(self):
+        # type: () -> str
         sanitized, encoded_hash = self._get_virtualenv_hash(self.name)
         suffix = "-{0}".format(PIPENV_PYTHON) if PIPENV_PYTHON else ""
         # If the pipfile was located at '/home/user/MY_PROJECT/Pipfile',
@@ -424,6 +448,7 @@
 
     @property
     def virtualenv_location(self):
+        # type: () -> str
         # if VIRTUAL_ENV is set, use that.
         virtualenv_env = os.getenv("VIRTUAL_ENV")
         if (
@@ -439,6 +464,7 @@
 
     @property
     def virtualenv_src_location(self):
+        # type: () -> str
         if self.virtualenv_location:
             loc = os.sep.join([self.virtualenv_location, "src"])
         else:
@@ -448,6 +474,7 @@
 
     @property
     def download_location(self):
+        # type: () -> str
         if self._download_location is None:
             loc = os.sep.join([self.virtualenv_location, "downloads"])
             self._download_location = loc
@@ -457,6 +484,7 @@
 
     @property
     def proper_names_db_path(self):
+        # type: () -> str
         if self._proper_names_db_path is None:
             self._proper_names_db_path = vistir.compat.Path(
                 self.virtualenv_location, "pipenv-proper-names.txt"
@@ -466,16 +494,19 @@
 
     @property
     def proper_names(self):
+        # type: () -> str
         with self.proper_names_db_path.open() as f:
             return f.read().splitlines()
 
     def register_proper_name(self, name):
+        # type: (str) -> None
         """Registers a proper name to the database."""
         with self.proper_names_db_path.open("a") as f:
             f.write(u"{0}\n".format(name))
 
     @property
     def pipfile_location(self):
+        # type: () -> str
         if PIPENV_PIPFILE:
             return PIPENV_PIPFILE
 
@@ -489,6 +520,7 @@
 
     @property
     def requirements_location(self):
+        # type: () -> Optional[str]
         if self._requirements_location is None:
             try:
                 loc = find_requirements(max_depth=PIPENV_MAX_DEPTH)
@@ -499,6 +531,7 @@
 
     @property
     def parsed_pipfile(self):
+        # type: () -> Union[tomlkit.toml_document.TOMLDocument, TPipfile]
         """Parse Pipfile into a TOMLFile and cache it
 
         (call clear_pipfile_cache() afterwards if mutating)"""
@@ -511,6 +544,7 @@
         return _pipfile_cache[cache_key]
 
     def read_pipfile(self):
+        # type: () -> str
         # Open the pipfile, read it into memory.
         if not self.pipfile_exists:
             return ""
@@ -521,10 +555,12 @@
         return contents
 
     def clear_pipfile_cache(self):
+        # type: () -> None
         """Clear pipfile cache (e.g., so we can mutate parsed pipfile)"""
         _pipfile_cache.clear()
 
     def _parse_pipfile(self, contents):
+        # type: () -> Union[tomlkit.toml_document.TOMLDocument, TPipfile]
         try:
             return tomlkit.parse(contents)
         except Exception:
@@ -533,6 +569,7 @@
             return toml.loads(contents)
 
     def _read_pyproject(self):
+        # type: () -> None
         pyproject = self.path_to("pyproject.toml")
         if os.path.exists(pyproject):
             self._pyproject = toml.load(pyproject)
@@ -547,24 +584,29 @@
 
     @property
     def build_requires(self):
+        # type: () -> List[str]
         return self._build_system.get("requires", ["setuptools>=40.8.0", "wheel"])
 
     @property
     def build_backend(self):
+        # type: () -> str
         return self._build_system.get("build-backend", get_default_pyproject_backend())
 
     @property
     def settings(self):
+        # type: () -> Union[tomlkit.items.Table, Dict[str, Union[str, bool]]]
         """A dictionary of the settings added to the Pipfile."""
         return self.parsed_pipfile.get("pipenv", {})
 
     def has_script(self, name):
+        # type: (str) -> bool
         try:
             return name in self.parsed_pipfile["scripts"]
         except KeyError:
             return False
 
     def build_script(self, name, extra_args=None):
+        # type: (str, Optional[List[str]])
         try:
             script = Script.parse(self.parsed_pipfile["scripts"][name])
         except KeyError:
@@ -574,6 +616,7 @@
         return script
 
     def update_settings(self, d):
+        # type: (Dict[str, Union[str, bool]]) -> None
         settings = self.settings
         changed = False
         for new in d:
@@ -682,18 +725,10 @@
 
     def create_pipfile(self, python=None):
         """Creates the Pipfile, filled with juicy defaults."""
-        from .vendor.pip_shims.shims import (
-            ConfigOptionParser, make_option_group, index_group
-        )
-
-        config_parser = ConfigOptionParser(name=self.name)
-        config_parser.add_option_group(make_option_group(index_group, config_parser))
-        install = config_parser.option_groups[0]
-        indexes = (
-            " ".join(install.get_option("--extra-index-url").default)
-            .lstrip("\n")
-            .split("\n")
-        )
+        from .vendor.pip_shims.shims import InstallCommand
+        # Inherit the pip's index configuration of install command.
+        command = InstallCommand()
+        indexes = command.cmd_opts.get_option("--extra-index-url").default
         sources = [DEFAULT_SOURCE]
         for i, index in enumerate(indexes):
             if not index:
@@ -1012,7 +1047,7 @@
 
         if expand_env_vars:
             # Expand environment variables in Pipfile.lock at runtime.
-            for i, source in enumerate(j["_meta"]["sources"][:]):
+            for i, _ in enumerate(j["_meta"]["sources"][:]):
                 j["_meta"]["sources"][i]["url"] = os.path.expandvars(
                     j["_meta"]["sources"][i]["url"]
                 )
Index: env/Lib/site-packages/pipenv/pipenv.1
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>.\\\" Man page generated from reStructuredText.\r\n.\r\n.TH \"PIPENV\" \"1\" \"May 28, 2020\" \"2020.5.28\" \"pipenv\"\r\n.SH NAME\r\npipenv \\- pipenv Documentation\r\n.\r\n.nr rst2man-indent-level 0\r\n.\r\n.de1 rstReportMargin\r\n\\\\$1 \\\\n[an-margin]\r\nlevel \\\\n[rst2man-indent-level]\r\nlevel margin: \\\\n[rst2man-indent\\\\n[rst2man-indent-level]]\r\n-\r\n\\\\n[rst2man-indent0]\r\n\\\\n[rst2man-indent1]\r\n\\\\n[rst2man-indent2]\r\n..\r\n.de1 INDENT\r\n.\\\" .rstReportMargin pre:\r\n. RS \\\\$1\r\n. nr rst2man-indent\\\\n[rst2man-indent-level] \\\\n[an-margin]\r\n. nr rst2man-indent-level +1\r\n.\\\" .rstReportMargin post:\r\n..\r\n.de UNINDENT\r\n. RE\r\n.\\\" indent \\\\n[an-margin]\r\n.\\\" old: \\\\n[rst2man-indent\\\\n[rst2man-indent-level]]\r\n.nr rst2man-indent-level -1\r\n.\\\" new: \\\\n[rst2man-indent\\\\n[rst2man-indent-level]]\r\n.in \\\\n[rst2man-indent\\\\n[rst2man-indent-level]]u\r\n..\r\n\\fI\\%\\fP\\fI\\%\\fP\\fI\\%\\fP\r\n.sp\r\n.ce\r\n----\r\n\r\n.ce 0\r\n.sp\r\n.sp\r\n\\fBPipenv\\fP is a tool that aims to bring the best of all packaging worlds (bundler, composer, npm, cargo, yarn, etc.) to the Python world. \\fIWindows is a first\\-class citizen, in our world.\\fP\r\n.sp\r\nIt automatically creates and manages a virtualenv for your projects, as well as adds/removes packages from your \\fBPipfile\\fP as you install/uninstall packages. It also generates the ever\\-important \\fBPipfile.lock\\fP, which is used to produce deterministic builds.\r\n.sp\r\nPipenv is primarily meant to provide users and developers of applications with an easy method to setup a working environment. For the distinction between libraries and applications and the usage of \\fBsetup.py\\fP vs \\fBPipfile\\fP to define dependencies, see pipfile\\-vs\\-setuppy\\&.\r\n[image: a short animation of pipenv at work]\r\n[image]\r\n.sp\r\nThe problems that Pipenv seeks to solve are multi\\-faceted:\r\n.INDENT 0.0\r\n.IP \\(bu 2\r\nYou no longer need to use \\fBpip\\fP and \\fBvirtualenv\\fP separately. They work together.\r\n.IP \\(bu 2\r\nManaging a \\fBrequirements.txt\\fP file \\fI\\%can be problematic\\fP, so Pipenv uses \\fBPipfile\\fP and \\fBPipfile.lock\\fP to separate abstract dependency declarations from the last tested combination.\r\n.IP \\(bu 2\r\nHashes are used everywhere, always. Security. Automatically expose security vulnerabilities.\r\n.IP \\(bu 2\r\nStrongly encourage the use of the latest versions of dependencies to minimize security risks \\fI\\%arising from outdated components\\fP\\&.\r\n.IP \\(bu 2\r\nGive you insight into your dependency graph (e.g. \\fB$ pipenv graph\\fP).\r\n.IP \\(bu 2\r\nStreamline development workflow by loading \\fB\\&.env\\fP files.\r\n.UNINDENT\r\n.sp\r\nYou can quickly play with Pipenv right in your browser:\r\n\\fI\\%Try in browser\\fP.SH INSTALL PIPENV TODAY!\r\n.sp\r\nIf you\\(aqre on MacOS, you can install Pipenv easily with Homebrew. You can also use Linuxbrew on Linux using the same command:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n$ brew install pipenv\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\nOr, if you\\(aqre using Fedora 28:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n$ sudo dnf install pipenv\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\nOtherwise, refer to the installing\\-pipenv chapter for instructions.\r\n.sp\r\n✨\uD83C\uDF70✨\r\n.SS Pipenv & Virtual Environments\r\n[image]\r\n.sp\r\nThis tutorial walks you through installing and using Python packages.\r\n.sp\r\nIt will show you how to install and use the necessary tools and make strong\r\nrecommendations on best practices. Keep in mind that Python is used for a great\r\nmany different purposes, and precisely how you want to manage your dependencies\r\nmay change based on how you decide to publish your software. The guidance\r\npresented here is most directly applicable to the development and deployment of\r\nnetwork services (including web applications), but is also very well suited to\r\nmanaging development and testing environments for any kind of project.\r\n.sp\r\n\\fBNOTE:\\fP\r\n.INDENT 0.0\r\n.INDENT 3.5\r\nThis guide is written for Python 3, however, these instructions\r\nshould work fine on Python 2.7—if you are still using it, for some reason.\r\n.UNINDENT\r\n.UNINDENT\r\n.SS ☤ Make sure you\\(aqve got Python & pip\r\n.sp\r\nBefore you go any further, make sure you have Python and that it\\(aqs available\r\nfrom your command line. You can check this by simply running:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n$ python \\-\\-version\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\nYou should get some output like \\fB3.6.2\\fP\\&. If you do not have Python, please\r\ninstall the latest 3.x version from \\fI\\%python.org\\fP or refer to the\r\n\\fI\\%Installing Python\\fP section of \\fIThe Hitchhiker\\(aqs Guide to Python\\fP\\&.\r\n.sp\r\n\\fBNOTE:\\fP\r\n.INDENT 0.0\r\n.INDENT 3.5\r\nIf you\\(aqre newcomer and you get an error like this:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n>>> python\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\nNameError: name \\(aqpython\\(aq is not defined\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\nIt\\(aqs because this command is intended to be run in a \\fIshell\\fP (also called\r\na \\fIterminal\\fP or \\fIconsole\\fP). See the Python for Beginners\r\n\\fI\\%getting started tutorial\\fP for an introduction to using your operating\r\nsystem\\(aqs shell and interacting with Python.\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\nAdditionally, you\\(aqll need to make sure you have pip available. You can\r\ncheck this by running:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n$ pip \\-\\-version\r\npip 9.0.1\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\nIf you installed Python from source, with an installer from \\fI\\%python.org\\fP, via \\fI\\%Homebrew\\fP or via \\fI\\%Linuxbrew\\fP you should already have pip. If you\\(aqre on Linux and installed\r\nusing your OS package manager, you may have to \\fI\\%install pip\\fP separately.\r\n.sp\r\nIf you plan to install Pipenv using Homebrew or Linuxbrew you can skip this step. The\r\nHomebrew/Linuxbrew installer takes care of pip for you.\r\n.SS ☤ Installing Pipenv\r\n.sp\r\nPipenv is a dependency manager for Python projects. If you\\(aqre familiar\r\nwith Node.js\\(aqs \\fI\\%npm\\fP or Ruby\\(aqs \\fI\\%bundler\\fP, it is similar in spirit to those\r\ntools. While pip can install Python packages, Pipenv is recommended as\r\nit\\(aqs a higher\\-level tool that simplifies dependency management for common use\r\ncases.\r\n.SS ☤ Homebrew Installation of Pipenv\r\n.sp\r\n\\fI\\%Homebrew\\fP is a popular open\\-source package management system for macOS. For Linux users, \\fI\\%Linuxbrew\\fP  is a Linux port of that.\r\n.sp\r\nInstalling pipenv via Homebrew or Linuxbrew will keep pipenv and all of its dependencies in\r\nan isolated virtual environment so it doesn\\(aqt interfere with the rest of your\r\nPython installation.\r\n.sp\r\nOnce you have installed Homebrew or Linuxbrew simply run:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n$ brew install pipenv\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\nTo upgrade pipenv at any time:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n$ brew upgrade pipenv\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.SS ☤ Pragmatic Installation of Pipenv\r\n.sp\r\nIf you have a working installation of pip, and maintain certain \"tool\\-chain\" type Python modules as global utilities in your user environment, pip \\fI\\%user installs\\fP allow for installation into your home directory. Note that due to interaction between dependencies, you should limit tools installed in this way to basic building blocks for a Python workflow like virtualenv, pipenv, tox, and similar software.\r\n.sp\r\nTo install:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n$ pip install \\-\\-user pipenv\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\n\\fBNOTE:\\fP\r\n.INDENT 0.0\r\n.INDENT 3.5\r\nThis does a \\fI\\%user installation\\fP to prevent breaking any system\\-wide\r\npackages. If \\fBpipenv\\fP isn\\(aqt available in your shell after installation,\r\nyou\\(aqll need to add the \\fI\\%user base\\fP\\(aqs binary directory to your \\fBPATH\\fP\\&.\r\n.sp\r\nOn Linux and macOS you can find the user base binary directory by running\r\n\\fBpython \\-m site \\-\\-user\\-base\\fP and adding \\fBbin\\fP to the end. For example,\r\nthis will typically print \\fB~/.local\\fP (with \\fB~\\fP expanded to the\r\nabsolute path to your home directory) so you\\(aqll need to add\r\n\\fB~/.local/bin\\fP to your \\fBPATH\\fP\\&. You can set your \\fBPATH\\fP permanently by\r\n\\fI\\%modifying ~/.profile\\fP\\&.\r\n.sp\r\nOn Windows you can find the user base binary directory by running\r\n\\fBpython \\-m site \\-\\-user\\-site\\fP and replacing \\fBsite\\-packages\\fP with\r\n\\fBScripts\\fP\\&. For example, this could return\r\n\\fBC:\\eUsers\\eUsername\\eAppData\\eRoaming\\ePython36\\esite\\-packages\\fP so you would\r\nneed to set your \\fBPATH\\fP to include\r\n\\fBC:\\eUsers\\eUsername\\eAppData\\eRoaming\\ePython36\\eScripts\\fP\\&. You can set your\r\nuser \\fBPATH\\fP permanently in the \\fI\\%Control Panel\\fP\\&. You may need to log\r\nout for the \\fBPATH\\fP changes to take effect.\r\n.sp\r\nFor more information, see the \\fI\\%user installs documentation\\fP\\&.\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\nTo upgrade pipenv at any time:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n$ pip install \\-\\-user \\-\\-upgrade pipenv\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.SS ☤ Crude Installation of Pipenv\r\n.sp\r\nIf you don\\(aqt even have pip installed, you can use this crude installation method, which will bootstrap your whole system:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n$ curl https://raw.githubusercontent.com/pypa/pipenv/master/get\\-pipenv.py | python\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.SS ☤ Installing packages for your project\r\n.sp\r\nPipenv manages dependencies on a per\\-project basis. To install packages,\r\nchange into your project\\(aqs directory (or just an empty directory for this\r\ntutorial) and run:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n$ cd myproject\r\n$ pipenv install requests\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\nPipenv will install the excellent \\fI\\%Requests\\fP library and create a \\fBPipfile\\fP\r\nfor you in your project\\(aqs directory. The \\fBPipfile\\fP is used to track which\r\ndependencies your project needs in case you need to re\\-install them, such as\r\nwhen you share your project with others. You should get output similar to this\r\n(although the exact paths shown will vary):\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\nCreating a Pipfile for this project...\r\nCreating a virtualenv for this project...\r\nUsing base prefix \\(aq/usr/local/Cellar/python3/3.6.2/Frameworks/Python.framework/Versions/3.6\\(aq\r\nNew python executable in ~/.local/share/virtualenvs/tmp\\-agwWamBd/bin/python3.6\r\nAlso creating executable in ~/.local/share/virtualenvs/tmp\\-agwWamBd/bin/python\r\nInstalling setuptools, pip, wheel...done.\r\n\r\nVirtualenv location: ~/.local/share/virtualenvs/tmp\\-agwWamBd\r\nInstalling requests...\r\nCollecting requests\r\n  Using cached requests\\-2.18.4\\-py2.py3\\-none\\-any.whl\r\nCollecting idna<2.7,>=2.5 (from requests)\r\n  Using cached idna\\-2.6\\-py2.py3\\-none\\-any.whl\r\nCollecting urllib3<1.23,>=1.21.1 (from requests)\r\n  Using cached urllib3\\-1.22\\-py2.py3\\-none\\-any.whl\r\nCollecting chardet<3.1.0,>=3.0.2 (from requests)\r\n  Using cached chardet\\-3.0.4\\-py2.py3\\-none\\-any.whl\r\nCollecting certifi>=2017.4.17 (from requests)\r\n  Using cached certifi\\-2017.7.27.1\\-py2.py3\\-none\\-any.whl\r\nInstalling collected packages: idna, urllib3, chardet, certifi, requests\r\nSuccessfully installed certifi\\-2017.7.27.1 chardet\\-3.0.4 idna\\-2.6 requests\\-2.18.4 urllib3\\-1.22\r\n\r\nAdding requests to Pipfile\\(aqs [packages]...\r\nP.S. You have excellent taste! ✨ \uD83C\uDF70 ✨\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.SS ☤ Using installed packages\r\n.sp\r\nNow that Requests is installed you can create a simple \\fBmain.py\\fP file to\r\nuse it:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\nimport requests\r\n\r\nresponse = requests.get(\\(aqhttps://httpbin.org/ip\\(aq)\r\n\r\nprint(\\(aqYour IP is {0}\\(aq.format(response.json()[\\(aqorigin\\(aq]))\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\nThen you can run this script using \\fBpipenv run\\fP:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n$ pipenv run python main.py\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\nYou should get output similar to this:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\nYour IP is 8.8.8.8\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\nUsing \\fB$ pipenv run\\fP ensures that your installed packages are available to\r\nyour script. It\\(aqs also possible to spawn a new shell that ensures all commands\r\nhave access to your installed packages with \\fB$ pipenv shell\\fP\\&.\r\n.SS ☤ Virtualenv mapping caveat\r\n.INDENT 0.0\r\n.IP \\(bu 2\r\nPipenv automatically maps projects to their specific virtualenvs.\r\n.IP \\(bu 2\r\nThe virtualenv is stored globally with the name of the project’s root directory plus the hash of the full path to the project\\(aqs root (e.g., \\fBmy_project\\-a3de50\\fP).\r\n.IP \\(bu 2\r\nIf you change your project\\(aqs path, you break such a default mapping and pipenv will no longer be able to find and to use the project\\(aqs virtualenv.\r\n.IP \\(bu 2\r\nYou might want to set \\fBexport PIPENV_VENV_IN_PROJECT=1\\fP in your .bashrc/.zshrc (or any shell configuration file) for creating the virtualenv inside your project\\(aqs directory, avoiding problems with subsequent path changes.\r\n.UNINDENT\r\n.SS ☤ Next steps\r\n.sp\r\nCongratulations, you now know how to install and use Python packages! ✨ \uD83C\uDF70 ✨\r\n.SS Release and Version History\r\n.SS 2020.5.28 (2020\\-05\\-28)\r\n.SS Features & Improvements\r\n.INDENT 0.0\r\n.IP \\(bu 2\r\n\\fBpipenv install\\fP and \\fBpipenv sync\\fP will no longer attempt to install satisfied dependencies during installation.  \\fI\\%#3057\\fP,\r\n\\fI\\%#3506\\fP\r\n.IP \\(bu 2\r\nAdded support for resolution of direct\\-url dependencies in \\fBsetup.py\\fP files to respect \\fBPEP\\-508\\fP style URL dependencies.  \\fI\\%#3148\\fP\r\n.IP \\(bu 2\r\nAdded full support for resolution of all dependency types including direct URLs, zip archives, tarballs, etc.\r\n.INDENT 2.0\r\n.IP \\(bu 2\r\nImproved error handling and formatting.\r\n.IP \\(bu 2\r\nIntroduced improved cross platform stream wrappers for better \\fBstdout\\fP and \\fBstderr\\fP consistency.  \\fI\\%#3298\\fP\r\n.UNINDENT\r\n.IP \\(bu 2\r\nFor consistency with other commands and the \\fB\\-\\-dev\\fP option\r\ndescription, \\fBpipenv lock \\-\\-requirements \\-\\-dev\\fP now emits\r\nboth default and development dependencies.\r\nThe new \\fB\\-\\-dev\\-only\\fP option requests the previous\r\nbehaviour (e.g. to generate a \\fBdev\\-requirements.txt\\fP file).  \\fI\\%#3316\\fP\r\n.IP \\(bu 2\r\nPipenv will now successfully recursively lock VCS sub\\-dependencies.  \\fI\\%#3328\\fP\r\n.IP \\(bu 2\r\nAdded support for \\fB\\-\\-verbose\\fP output to \\fBpipenv run\\fP\\&.  \\fI\\%#3348\\fP\r\n.IP \\(bu 2\r\nPipenv will now discover and resolve the intrinsic dependencies of \\fBall\\fP VCS dependencies, whether they are editable or not, to prevent resolution conflicts.  \\fI\\%#3368\\fP\r\n.IP \\(bu 2\r\nAdded a new environment variable, \\fBPIPENV_RESOLVE_VCS\\fP, to toggle dependency resolution off for non\\-editable VCS, file, and URL based dependencies.  \\fI\\%#3577\\fP\r\n.IP \\(bu 2\r\nAdded the ability for Windows users to enable emojis by setting \\fBPIPENV_HIDE_EMOJIS=0\\fP\\&.  \\fI\\%#3595\\fP\r\n.IP \\(bu 2\r\nAllow overriding PIPENV_INSTALL_TIMEOUT environment variable (in seconds).  \\fI\\%#3652\\fP\r\n.IP \\(bu 2\r\nAllow overriding PIP_EXISTS_ACTION evironment variable (value is passed to pip install).\r\nPossible values here: \\fI\\%https://pip.pypa.io/en/stable/reference/pip/#exists\\-action\\-option\\fP\r\nUseful when you need to \\fIPIP_EXISTS_ACTION=i\\fP (ignore existing packages) \\- great for CI environments, where you need really fast setup.  \\fI\\%#3738\\fP\r\n.IP \\(bu 2\r\nPipenv will no longer forcibly override \\fBPIP_NO_DEPS\\fP on all vcs and file dependencies as resolution happens on these in a pre\\-lock step.  \\fI\\%#3763\\fP\r\n.IP \\(bu 2\r\nImproved verbose logging output during \\fBpipenv lock\\fP will now stream output to the console while maintaining a spinner.  \\fI\\%#3810\\fP\r\n.IP \\(bu 2\r\nAdded support for automatic python installs via \\fBasdf\\fP and associated \\fBPIPENV_DONT_USE_ASDF\\fP environment variable.  \\fI\\%#4018\\fP\r\n.IP \\(bu 2\r\nPyenv/asdf can now be used whether or not they are available on PATH. Setting PYENV_ROOT/ASDF_DIR in a Pipenv\\(aqs .env allows Pipenv to install an interpreter without any shell customizations, so long as pyenv/asdf is installed.  \\fI\\%#4245\\fP\r\n.IP \\(bu 2\r\nAdded \\fB\\-\\-key\\fP command line parameter for including personal PyUp.io API tokens when running \\fBpipenv check\\fP\\&.  \\fI\\%#4257\\fP\r\n.UNINDENT\r\n.SS Behavior Changes\r\n.INDENT 0.0\r\n.IP \\(bu 2\r\nMake conservative checks of known exceptions when subprocess returns output, so user won\\(aqt see the whole traceback \\- just the error.  \\fI\\%#2553\\fP\r\n.IP \\(bu 2\r\nDo not touch Pipfile early and rely on it so that one can do \\fBpipenv sync\\fP without a Pipfile.  \\fI\\%#3386\\fP\r\n.IP \\(bu 2\r\nRe\\-enable \\fB\\-\\-help\\fP option for \\fBpipenv run\\fP command.  \\fI\\%#3844\\fP\r\n.IP \\(bu 2\r\nMake sure \\fBpipenv lock \\-r \\-\\-pypi\\-mirror {MIRROR_URL}\\fP will respect the pypi\\-mirror in requirements output.  \\fI\\%#4199\\fP\r\n.UNINDENT\r\n.SS Bug Fixes\r\n.INDENT 0.0\r\n.IP \\(bu 2\r\nRaise \\fIPipenvUsageError\\fP when [[source]] does not contain url field.  \\fI\\%#2373\\fP\r\n.IP \\(bu 2\r\nFixed a bug which caused editable package resolution to sometimes fail with an unhelpful setuptools\\-related error message.  \\fI\\%#2722\\fP\r\n.IP \\(bu 2\r\nFixed an issue which caused errors due to reliance on the system utilities \\fBwhich\\fP and \\fBwhere\\fP which may not always exist on some systems.\r\n\\- Fixed a bug which caused periodic failures in python discovery when executables named \\fBpython\\fP were not present on the target \\fB$PATH\\fP\\&.  \\fI\\%#2783\\fP\r\n.IP \\(bu 2\r\nDependency resolution now writes hashes for local and remote files to the lockfile.  \\fI\\%#3053\\fP\r\n.IP \\(bu 2\r\nFixed a bug which prevented \\fBpipenv graph\\fP from correctly showing all dependencies when running from within \\fBpipenv shell\\fP\\&.  \\fI\\%#3071\\fP\r\n.IP \\(bu 2\r\nFixed resolution of direct\\-url dependencies in \\fBsetup.py\\fP files to respect \\fBPEP\\-508\\fP style URL dependencies.  \\fI\\%#3148\\fP\r\n.IP \\(bu 2\r\nFixed a bug which caused failures in warning reporting when running pipenv inside a virtualenv under some circumstances.\r\n.INDENT 2.0\r\n.IP \\(bu 2\r\nFixed a bug with package discovery when running \\fBpipenv clean\\fP\\&.  \\fI\\%#3298\\fP\r\n.UNINDENT\r\n.IP \\(bu 2\r\nQuote command arguments with carets (\\fB^\\fP) on Windows to work around unintended shell escapes.  \\fI\\%#3307\\fP\r\n.IP \\(bu 2\r\nHandle alternate names for UTF\\-8 encoding.  \\fI\\%#3313\\fP\r\n.IP \\(bu 2\r\nAbort pipenv before adding the non\\-exist package to Pipfile.  \\fI\\%#3318\\fP\r\n.IP \\(bu 2\r\nDon\\(aqt normalize the package name user passes in.  \\fI\\%#3324\\fP\r\n.IP \\(bu 2\r\nFix a bug where custom virtualenv can not be activated with pipenv shell  \\fI\\%#3339\\fP\r\n.IP \\(bu 2\r\nFix a bug that \\fB\\-\\-site\\-packages\\fP flag is not recognized.  \\fI\\%#3351\\fP\r\n.IP \\(bu 2\r\nFix a bug where pipenv \\-\\-clear is not working  \\fI\\%#3353\\fP\r\n.IP \\(bu 2\r\nFix unhashable type error during \\fB$ pipenv install \\-\\-selective\\-upgrade\\fP  \\fI\\%#3384\\fP\r\n.IP \\(bu 2\r\nDependencies with direct \\fBPEP508\\fP compliant VCS URLs specified in their \\fBinstall_requires\\fP will now be successfully locked during the resolution process.  \\fI\\%#3396\\fP\r\n.IP \\(bu 2\r\nFixed a keyerror which could occur when locking VCS dependencies in some cases.  \\fI\\%#3404\\fP\r\n.IP \\(bu 2\r\nFixed a bug that \\fBValidationError\\fP is thrown when some fields are missing in source section.  \\fI\\%#3427\\fP\r\n.IP \\(bu 2\r\nUpdated the index names in lock file when source name in Pipfile is changed.  \\fI\\%#3449\\fP\r\n.IP \\(bu 2\r\nFixed an issue which caused \\fBpipenv install \\-\\-help\\fP to show duplicate entries for \\fB\\-\\-pre\\fP\\&.  \\fI\\%#3479\\fP\r\n.IP \\(bu 2\r\nFix bug causing \\fB[SSL: CERTIFICATE_VERIFY_FAILED]\\fP when Pipfile \\fB[[source]]\\fP has verify_ssl=false and url with custom port.  \\fI\\%#3502\\fP\r\n.IP \\(bu 2\r\nFix \\fBsync \\-\\-sequential\\fP ignoring \\fBpip install\\fP errors and logs.  \\fI\\%#3537\\fP\r\n.IP \\(bu 2\r\nFix the issue that lock file can\\(aqt be created when \\fBPIPENV_PIPFILE\\fP is not under working directory.  \\fI\\%#3584\\fP\r\n.IP \\(bu 2\r\nPipenv will no longer inadvertently set \\fBeditable=True\\fP on all vcs dependencies.  \\fI\\%#3647\\fP\r\n.IP \\(bu 2\r\nThe \\fB\\-\\-keep\\-outdated\\fP argument to \\fBpipenv install\\fP and \\fBpipenv lock\\fP will now drop specifier constraints when encountering editable dependencies.\r\n\\- In addition, \\fB\\-\\-keep\\-outdated\\fP will retain specifiers that would otherwise be dropped from any entries that have not been updated.  \\fI\\%#3656\\fP\r\n.IP \\(bu 2\r\nFixed a bug which sometimes caused pipenv to fail to respect the \\fB\\-\\-site\\-packages\\fP flag when passed with \\fBpipenv install\\fP\\&.  \\fI\\%#3718\\fP\r\n.IP \\(bu 2\r\nNormalize the package names to lowercase when comparing used and in\\-Pipfile packages.  \\fI\\%#3745\\fP\r\n.IP \\(bu 2\r\n\\fBpipenv update \\-\\-outdated\\fP will now correctly handle comparisons between pre/post\\-releases and normal releases.  \\fI\\%#3766\\fP\r\n.IP \\(bu 2\r\nFixed a \\fBKeyError\\fP which could occur when pinning outdated VCS dependencies via \\fBpipenv lock \\-\\-keep\\-outdated\\fP\\&.  \\fI\\%#3768\\fP\r\n.IP \\(bu 2\r\nResolved an issue which caused resolution to fail when encountering poorly formatted \\fBpython_version\\fP markers in \\fBsetup.py\\fP and \\fBsetup.cfg\\fP files.  \\fI\\%#3786\\fP\r\n.IP \\(bu 2\r\nFix a bug that installation errors are displayed as a list.  \\fI\\%#3794\\fP\r\n.IP \\(bu 2\r\nUpdate \\fBpythonfinder\\fP to fix a problem that \\fBpython.exe\\fP will be mistakenly chosen for\r\nvirtualenv creation under WSL.  \\fI\\%#3807\\fP\r\n.IP \\(bu 2\r\nFixed several bugs which could prevent editable VCS dependencies from being installed into target environments, even when reporting successful installation.  \\fI\\%#3809\\fP\r\n.IP \\(bu 2\r\n\\fBpipenv check \\-\\-system\\fP should find the correct Python interpreter when \\fBpython\\fP does not exist on the system.  \\fI\\%#3819\\fP\r\n.IP \\(bu 2\r\nResolve the symlinks when the path is absolute.  \\fI\\%#3842\\fP\r\n.IP \\(bu 2\r\nPass \\fB\\-\\-pre\\fP and \\fB\\-\\-clear\\fP options to \\fBpipenv update \\-\\-outdated\\fP\\&.  \\fI\\%#3879\\fP\r\n.IP \\(bu 2\r\nFixed a bug which prevented resolution of direct URL dependencies which have PEP508 style direct url VCS sub\\-dependencies with subdirectories.  \\fI\\%#3976\\fP\r\n.IP \\(bu 2\r\nHonor PIPENV_SPINNER environment variable  \\fI\\%#4045\\fP\r\n.IP \\(bu 2\r\nFixed an issue with \\fBpipenv check\\fP failing due to an invalid API key from \\fBpyup.io\\fP\\&.  \\fI\\%#4188\\fP\r\n.IP \\(bu 2\r\nFixed a bug which caused versions from VCS dependencies to be included in \\fBPipfile.lock\\fP inadvertently.  \\fI\\%#4217\\fP\r\n.IP \\(bu 2\r\nFixed a bug which caused pipenv to search non\\-existent virtual environments for \\fBpip\\fP when installing using \\fB\\-\\-system\\fP\\&.  \\fI\\%#4220\\fP\r\n.IP \\(bu 2\r\n\\fBRequires\\-Python\\fP values specifying constraint versions of python starting from \\fB1.x\\fP will now be parsed successfully.  \\fI\\%#4226\\fP\r\n.IP \\(bu 2\r\nFix a bug of \\fBpipenv update \\-\\-outdated\\fP that can\\(aqt print output correctly.  \\fI\\%#4229\\fP\r\n.IP \\(bu 2\r\nFixed a bug which caused pipenv to prefer source distributions over wheels from \\fBPyPI\\fP during the dependency resolution phase.\r\nFixed an issue which prevented proper build isolation using \\fBpep517\\fP based builders during dependency resolution.  \\fI\\%#4231\\fP\r\n.IP \\(bu 2\r\nDon\\(aqt fallback to system Python when no matching Python version is found.  \\fI\\%#4232\\fP\r\n.UNINDENT\r\n.SS Vendored Libraries\r\n.INDENT 0.0\r\n.IP \\(bu 2\r\nUpdated vendored dependencies:\r\n.INDENT 2.0\r\n.INDENT 3.5\r\n.INDENT 0.0\r\n.IP \\(bu 2\r\n\\fBattrs\\fP: \\fB18.2.0\\fP => \\fB19.1.0\\fP\r\n.IP \\(bu 2\r\n\\fBcertifi\\fP: \\fB2018.10.15\\fP => \\fB2019.3.9\\fP\r\n.IP \\(bu 2\r\n\\fBcached_property\\fP: \\fB1.4.3\\fP => \\fB1.5.1\\fP\r\n.IP \\(bu 2\r\n\\fBcerberus\\fP: \\fB1.2.0\\fP => \\fB1.3.1\\fP\r\n.IP \\(bu 2\r\n\\fBclick\\-completion\\fP: \\fB0.5.0\\fP => \\fB0.5.1\\fP\r\n.IP \\(bu 2\r\n\\fBcolorama\\fP: \\fB0.3.9\\fP => \\fB0.4.1\\fP\r\n.IP \\(bu 2\r\n\\fBdistlib\\fP: \\fB0.2.8\\fP => \\fB0.2.9\\fP\r\n.IP \\(bu 2\r\n\\fBidna\\fP: \\fB2.7\\fP => \\fB2.8\\fP\r\n.IP \\(bu 2\r\n\\fBjinja2\\fP: \\fB2.10.0\\fP => \\fB2.10.1\\fP\r\n.IP \\(bu 2\r\n\\fBmarkupsafe\\fP: \\fB1.0\\fP => \\fB1.1.1\\fP\r\n.IP \\(bu 2\r\n\\fBorderedmultidict\\fP: \\fB(new)\\fP => \\fB1.0\\fP\r\n.IP \\(bu 2\r\n\\fBpackaging\\fP: \\fB18.0\\fP => \\fB19.0\\fP\r\n.IP \\(bu 2\r\n\\fBparse\\fP: \\fB1.9.0\\fP => \\fB1.12.0\\fP\r\n.IP \\(bu 2\r\n\\fBpathlib2\\fP: \\fB2.3.2\\fP => \\fB2.3.3\\fP\r\n.IP \\(bu 2\r\n\\fBpep517\\fP: \\fB(new)\\fP => \\fB0.5.0\\fP\r\n.IP \\(bu 2\r\n\\fBpexpect\\fP: \\fB4.6.0\\fP => \\fB4.7.0\\fP\r\n.IP \\(bu 2\r\n\\fBpipdeptree\\fP: \\fB0.13.0\\fP => \\fB0.13.2\\fP\r\n.IP \\(bu 2\r\n\\fBpyparsing\\fP: \\fB2.2.2\\fP => \\fB2.3.1\\fP\r\n.IP \\(bu 2\r\n\\fBpython\\-dotenv\\fP: \\fB0.9.1\\fP => \\fB0.10.2\\fP\r\n.IP \\(bu 2\r\n\\fBpythonfinder\\fP: \\fB1.1.10\\fP => \\fB1.2.1\\fP\r\n.IP \\(bu 2\r\n\\fBpytoml\\fP: \\fB(new)\\fP => \\fB0.1.20\\fP\r\n.IP \\(bu 2\r\n\\fBrequests\\fP: \\fB2.20.1\\fP => \\fB2.21.0\\fP\r\n.IP \\(bu 2\r\n\\fBrequirementslib\\fP: \\fB1.3.3\\fP => \\fB1.5.0\\fP\r\n.IP \\(bu 2\r\n\\fBscandir\\fP: \\fB1.9.0\\fP => \\fB1.10.0\\fP\r\n.IP \\(bu 2\r\n\\fBshellingham\\fP: \\fB1.2.7\\fP => \\fB1.3.1\\fP\r\n.IP \\(bu 2\r\n\\fBsix\\fP: \\fB1.11.0\\fP => \\fB1.12.0\\fP\r\n.IP \\(bu 2\r\n\\fBtomlkit\\fP: \\fB0.5.2\\fP => \\fB0.5.3\\fP\r\n.IP \\(bu 2\r\n\\fBurllib3\\fP: \\fB1.24\\fP => \\fB1.25.2\\fP\r\n.IP \\(bu 2\r\n\\fBvistir\\fP: \\fB0.3.0\\fP => \\fB0.4.1\\fP\r\n.IP \\(bu 2\r\n\\fByaspin\\fP: \\fB0.14.0\\fP => \\fB0.14.3\\fP\r\n.UNINDENT\r\n.UNINDENT\r\n.UNINDENT\r\n.INDENT 2.0\r\n.IP \\(bu 2\r\nRemoved vendored dependency \\fBcursor\\fP\\&.  \\fI\\%#3298\\fP\r\n.UNINDENT\r\n.IP \\(bu 2\r\nUpdated \\fBpip_shims\\fP to support \\fB\\-\\-outdated\\fP with new pip versions.  \\fI\\%#3766\\fP\r\n.IP \\(bu 2\r\nUpdate vendored dependencies and invocations\r\n.INDENT 2.0\r\n.IP \\(bu 2\r\nUpdate vendored and patched dependencies\r\n\\- Update patches on \\fBpiptools\\fP, \\fBpip\\fP, \\fBpip\\-shims\\fP, \r\n.nf\r\n\\(ga\\(ga\r\n.fi\r\ntomlkit\\(ga\r\n.IP \\(bu 2\r\nFix invocations of dependencies\r\n\\- Fix custom \r\n.nf\r\n\\(ga\\(ga\r\n.fi\r\nInstallCommand\\(ga instantiation\r\n\\- Update \r\n.nf\r\n\\(ga\\(ga\r\n.fi\r\nPackageFinder\\(ga usage\r\n\\- Fix \r\n.nf\r\n\\(ga\\(ga\r\n.fi\r\nBool\\(ga stringify attempts from \r\n.nf\r\n\\(ga\\(ga\r\n.fi\r\ntomlkit\\(ga\r\n.UNINDENT\r\n.INDENT 2.0\r\n.TP\r\n.B Updated vendored dependencies:\r\n.INDENT 7.0\r\n.IP \\(bu 2\r\n\\fBattrs\\fP: \\fB\\(ga18.2.0\\fP => \\fB\\(ga19.1.0\\fP\r\n.IP \\(bu 2\r\n\\fBcertifi\\fP: \\fB\\(ga2018.10.15\\fP => \\fB\\(ga2019.3.9\\fP\r\n.IP \\(bu 2\r\n\\fBcached_property\\fP: \\fB\\(ga1.4.3\\fP => \\fB\\(ga1.5.1\\fP\r\n.IP \\(bu 2\r\n\\fBcerberus\\fP: \\fB\\(ga1.2.0\\fP => \\fB\\(ga1.3.1\\fP\r\n.IP \\(bu 2\r\n\\fBclick\\fP: \\fB\\(ga7.0.0\\fP => \\fB\\(ga7.1.1\\fP\r\n.IP \\(bu 2\r\n\\fBclick\\-completion\\fP: \\fB\\(ga0.5.0\\fP => \\fB\\(ga0.5.1\\fP\r\n.IP \\(bu 2\r\n\\fBcolorama\\fP: \\fB\\(ga0.3.9\\fP => \\fB\\(ga0.4.3\\fP\r\n.IP \\(bu 2\r\n\\fBcontextlib2\\fP: \\fB\\(ga(new)\\fP => \\fB\\(ga0.6.0.post1\\fP\r\n.IP \\(bu 2\r\n\\fBdistlib\\fP: \\fB\\(ga0.2.8\\fP => \\fB\\(ga0.2.9\\fP\r\n.IP \\(bu 2\r\n\\fBfuncsigs\\fP: \\fB\\(ga(new)\\fP => \\fB\\(ga1.0.2\\fP\r\n.IP \\(bu 2\r\n\\fBimportlib_metadata\\fP \\fB\\(ga1.3.0\\fP => \\fB\\(ga1.5.1\\fP\r\n.IP \\(bu 2\r\n\\fBimportlib\\-resources\\fP:  \\fB\\(ga(new)\\fP => \\fB\\(ga1.4.0\\fP\r\n.IP \\(bu 2\r\n\\fBidna\\fP: \\fB\\(ga2.7\\fP => \\fB\\(ga2.9\\fP\r\n.IP \\(bu 2\r\n\\fBjinja2\\fP: \\fB\\(ga2.10.0\\fP => \\fB\\(ga2.11.1\\fP\r\n.IP \\(bu 2\r\n\\fBmarkupsafe\\fP: \\fB\\(ga1.0\\fP => \\fB\\(ga1.1.1\\fP\r\n.IP \\(bu 2\r\n\\fBmore\\-itertools\\fP: \\fB\\(ga(new)\\fP => \\fB\\(ga5.0.0\\fP\r\n.IP \\(bu 2\r\n\\fBorderedmultidict\\fP: \\fB\\(ga(new)\\fP => \\fB\\(ga1.0\\fP\r\n.IP \\(bu 2\r\n\\fBpackaging\\fP: \\fB\\(ga18.0\\fP => \\fB\\(ga19.0\\fP\r\n.IP \\(bu 2\r\n\\fBparse\\fP: \\fB\\(ga1.9.0\\fP => \\fB\\(ga1.15.0\\fP\r\n.IP \\(bu 2\r\n\\fBpathlib2\\fP: \\fB\\(ga2.3.2\\fP => \\fB\\(ga2.3.3\\fP\r\n.IP \\(bu 2\r\n\\fBpep517\\fP: \\fB\\(ga(new)\\fP => \\fB\\(ga0.5.0\\fP\r\n.IP \\(bu 2\r\n\\fBpexpect\\fP: \\fB\\(ga4.6.0\\fP => \\fB\\(ga4.8.0\\fP\r\n.IP \\(bu 2\r\n\\fBpip\\-shims\\fP: \\fB\\(ga0.2.0\\fP => \\fB\\(ga0.5.1\\fP\r\n.IP \\(bu 2\r\n\\fBpipdeptree\\fP: \\fB\\(ga0.13.0\\fP => \\fB\\(ga0.13.2\\fP\r\n.IP \\(bu 2\r\n\\fBpyparsing\\fP: \\fB\\(ga2.2.2\\fP => \\fB\\(ga2.4.6\\fP\r\n.IP \\(bu 2\r\n\\fBpython\\-dotenv\\fP: \\fB\\(ga0.9.1\\fP => \\fB\\(ga0.10.2\\fP\r\n.IP \\(bu 2\r\n\\fBpythonfinder\\fP: \\fB\\(ga1.1.10\\fP => \\fB\\(ga1.2.2\\fP\r\n.IP \\(bu 2\r\n\\fBpytoml\\fP: \\fB\\(ga(new)\\fP => \\fB\\(ga0.1.20\\fP\r\n.IP \\(bu 2\r\n\\fBrequests\\fP: \\fB\\(ga2.20.1\\fP => \\fB\\(ga2.23.0\\fP\r\n.IP \\(bu 2\r\n\\fBrequirementslib\\fP: \\fB\\(ga1.3.3\\fP => \\fB\\(ga1.5.4\\fP\r\n.IP \\(bu 2\r\n\\fBscandir\\fP: \\fB\\(ga1.9.0\\fP => \\fB\\(ga1.10.0\\fP\r\n.IP \\(bu 2\r\n\\fBshellingham\\fP: \\fB\\(ga1.2.7\\fP => \\fB\\(ga1.3.2\\fP\r\n.IP \\(bu 2\r\n\\fBsix\\fP: \\fB\\(ga1.11.0\\fP => \\fB\\(ga1.14.0\\fP\r\n.IP \\(bu 2\r\n\\fBtomlkit\\fP: \\fB\\(ga0.5.2\\fP => \\fB\\(ga0.5.11\\fP\r\n.IP \\(bu 2\r\n\\fBurllib3\\fP: \\fB\\(ga1.24\\fP => \\fB\\(ga1.25.8\\fP\r\n.IP \\(bu 2\r\n\\fBvistir\\fP: \\fB\\(ga0.3.0\\fP => \\fB\\(ga0.5.0\\fP\r\n.IP \\(bu 2\r\n\\fByaspin\\fP: \\fB\\(ga0.14.0\\fP => \\fB\\(ga0.14.3\\fP\r\n.IP \\(bu 2\r\n\\fBzipp\\fP: \\fB\\(ga0.6.0\\fP\r\n.UNINDENT\r\n.UNINDENT\r\n.INDENT 2.0\r\n.IP \\(bu 2\r\nRemoved vendored dependency \\fBcursor\\fP\\&.  \\fI\\%#4169\\fP\r\n.UNINDENT\r\n.IP \\(bu 2\r\nAdd and update vendored dependencies to accommodate \\fBsafety\\fP vendoring:\r\n\\- \\fBsafety\\fP \\fB(none)\\fP => \\fB1.8.7\\fP\r\n\\- \\fBdparse\\fP \\fB(none)\\fP => \\fB0.5.0\\fP\r\n\\- \\fBpyyaml\\fP \\fB(none)\\fP => \\fB5.3.1\\fP\r\n\\- \\fBurllib3\\fP \\fB1.25.8\\fP => \\fB1.25.9\\fP\r\n\\- \\fBcertifi\\fP \\fB2019.11.28\\fP => \\fB2020.4.5.1\\fP\r\n\\- \\fBpyparsing\\fP \\fB2.4.6\\fP => \\fB2.4.7\\fP\r\n\\- \\fBresolvelib\\fP \\fB0.2.2\\fP => \\fB0.3.0\\fP\r\n\\- \\fBimportlib\\-metadata\\fP \\fB1.5.1\\fP => \\fB1.6.0\\fP\r\n\\- \\fBpip\\-shims\\fP \\fB0.5.1\\fP => \\fB0.5.2\\fP\r\n\\- \\fBrequirementslib\\fP \\fB1.5.5\\fP => \\fB1.5.6\\fP  \\fI\\%#4188\\fP\r\n.IP \\(bu 2\r\nUpdated vendored \\fBpip\\fP => \\fB20.0.2\\fP and \\fBpip\\-tools\\fP => \\fB5.0.0\\fP\\&.  \\fI\\%#4215\\fP\r\n.IP \\(bu 2\r\nUpdated vendored dependencies to latest versions for security and bug fixes:\r\n.INDENT 2.0\r\n.IP \\(bu 2\r\n\\fBrequirementslib\\fP \\fB1.5.8\\fP => \\fB1.5.9\\fP\r\n.IP \\(bu 2\r\n\\fBvistir\\fP \\fB0.5.0\\fP => \\fB0.5.1\\fP\r\n.IP \\(bu 2\r\n\\fBjinja2\\fP \\fB2.11.1\\fP => \\fB2.11.2\\fP\r\n.IP \\(bu 2\r\n\\fBclick\\fP \\fB7.1.1\\fP => \\fB7.1.2\\fP\r\n.IP \\(bu 2\r\n\\fBdateutil\\fP \\fB(none)\\fP => \\fB2.8.1\\fP\r\n.IP \\(bu 2\r\n\\fBbackports.functools_lru_cache\\fP \\fB1.5.0\\fP => \\fB1.6.1\\fP\r\n.IP \\(bu 2\r\n\\fBenum34\\fP \\fB1.1.6\\fP => \\fB1.1.10\\fP\r\n.IP \\(bu 2\r\n\\fBtoml\\fP \\fB0.10.0\\fP => \\fB0.10.1\\fP\r\n.IP \\(bu 2\r\n\\fBimportlib_resources\\fP \\fB1.4.0\\fP => \\fB1.5.0\\fP  \\fI\\%#4226\\fP\r\n.UNINDENT\r\n.IP \\(bu 2\r\nChanged attrs import path in vendored dependencies to always import from \\fBpipenv.vendor\\fP\\&.  \\fI\\%#4267\\fP\r\n.UNINDENT\r\n.SS Improved Documentation\r\n.INDENT 0.0\r\n.IP \\(bu 2\r\nAdded documenation about variable expansion in \\fBPipfile\\fP entries.  \\fI\\%#2317\\fP\r\n.IP \\(bu 2\r\nConsolidate all contributing docs in the rst file  \\fI\\%#3120\\fP\r\n.IP \\(bu 2\r\nUpdate the out\\-dated manual page.  \\fI\\%#3246\\fP\r\n.IP \\(bu 2\r\nMove CLI docs to its own page.  \\fI\\%#3346\\fP\r\n.IP \\(bu 2\r\nReplace (non\\-existant) video on docs index.rst with equivalent gif.  \\fI\\%#3499\\fP\r\n.IP \\(bu 2\r\nClarify wording in Basic Usage example on using double quotes to escape shell redirection  \\fI\\%#3522\\fP\r\n.IP \\(bu 2\r\nEnsure docs show navigation on small\\-screen devices  \\fI\\%#3527\\fP\r\n.IP \\(bu 2\r\nAdded a link to the TOML Spec under General Recommendations & Version Control to clarify how Pipfiles should be written.  \\fI\\%#3629\\fP\r\n.IP \\(bu 2\r\nUpdated the documentation with the new \\fBpytest\\fP entrypoint.  \\fI\\%#3759\\fP\r\n.IP \\(bu 2\r\nFix link to GIF in README.md demonstrating Pipenv\\(aqs usage, and add descriptive alt text.  \\fI\\%#3911\\fP\r\n.IP \\(bu 2\r\nAdded a line describing potential issues in fancy extension.  \\fI\\%#3912\\fP\r\n.IP \\(bu 2\r\nDocumental description of how Pipfile works and association with Pipenv.  \\fI\\%#3913\\fP\r\n.IP \\(bu 2\r\nClarify the proper value of \\fBpython_version\\fP and \\fBpython_full_version\\fP\\&.  \\fI\\%#3914\\fP\r\n.IP \\(bu 2\r\nWrite description for \\-\\-deploy extension and few extensions differences.  \\fI\\%#3915\\fP\r\n.IP \\(bu 2\r\nMore documentation for \\fB\\&.env\\fP files  \\fI\\%#4100\\fP\r\n.IP \\(bu 2\r\nUpdated documentation to point to working links.  \\fI\\%#4137\\fP\r\n.IP \\(bu 2\r\nReplace docs.pipenv.org with pipenv.pypa.io  \\fI\\%#4167\\fP\r\n.IP \\(bu 2\r\nAdded functionality to check spelling in documentation and cleaned up existing typographical issues.  \\fI\\%#4209\\fP\r\n.UNINDENT\r\n.SS 2018.11.26 (2018\\-11\\-26)\r\n.SS Bug Fixes\r\n.INDENT 0.0\r\n.IP \\(bu 2\r\nEnvironment variables are expanded correctly before running scripts on POSIX.  \\fI\\%#3178\\fP\r\n.IP \\(bu 2\r\nPipenv will no longer disable user\\-mode installation when the \\fB\\-\\-system\\fP flag is passed in.  \\fI\\%#3222\\fP\r\n.IP \\(bu 2\r\nFixed an issue with attempting to render unicode output in non\\-unicode locales.  \\fI\\%#3223\\fP\r\n.IP \\(bu 2\r\nFixed a bug which could cause failures to occur when parsing python entries from global pyenv version files.  \\fI\\%#3224\\fP\r\n.IP \\(bu 2\r\nFixed an issue which prevented the parsing of named extras sections from certain \\fBsetup.py\\fP files.  \\fI\\%#3230\\fP\r\n.IP \\(bu 2\r\nCorrectly detect the virtualenv location inside an activated virtualenv.  \\fI\\%#3231\\fP\r\n.IP \\(bu 2\r\nFixed a bug which caused spinner frames to be written to standard output during locking operations which could cause redirection pipes to fail.  \\fI\\%#3239\\fP\r\n.IP \\(bu 2\r\nFixed a bug that editable packages can\\(aqt be uninstalled correctly.  \\fI\\%#3240\\fP\r\n.IP \\(bu 2\r\nCorrected an issue with installation timeouts which caused dependency resolution to fail for longer duration resolution steps.  \\fI\\%#3244\\fP\r\n.IP \\(bu 2\r\nAdding normal pep 508 compatible markers is now fully functional when using VCS dependencies.  \\fI\\%#3249\\fP\r\n.IP \\(bu 2\r\nUpdated \\fBrequirementslib\\fP and \\fBpythonfinder\\fP for multiple bug fixes.  \\fI\\%#3254\\fP\r\n.IP \\(bu 2\r\nPipenv will now ignore hashes when installing with \\fB\\-\\-skip\\-lock\\fP\\&.  \\fI\\%#3255\\fP\r\n.IP \\(bu 2\r\nFixed an issue where pipenv could crash when multiple pipenv processes attempted to create the same directory.  \\fI\\%#3257\\fP\r\n.IP \\(bu 2\r\nFixed an issue which sometimes prevented successful creation of a project Pipfile.  \\fI\\%#3260\\fP\r\n.IP \\(bu 2\r\n\\fBpipenv install\\fP will now unset the \\fBPYTHONHOME\\fP environment variable when not combined with \\fB\\-\\-system\\fP\\&.  \\fI\\%#3261\\fP\r\n.IP \\(bu 2\r\nPipenv will ensure that warnings do not interfere with the resolution process by suppressing warnings\\(aq usage of standard output and writing to standard error instead.  \\fI\\%#3273\\fP\r\n.IP \\(bu 2\r\nFixed an issue which prevented variables from the environment, such as \\fBPIPENV_DEV\\fP or \\fBPIPENV_SYSTEM\\fP, from being parsed and implemented correctly.  \\fI\\%#3278\\fP\r\n.IP \\(bu 2\r\nClear pythonfinder cache after Python install.  \\fI\\%#3287\\fP\r\n.IP \\(bu 2\r\nFixed a race condition in hash resolution for dependencies for certain dependencies with missing cache entries or fresh Pipenv installs.  \\fI\\%#3289\\fP\r\n.IP \\(bu 2\r\nPipenv will now respect top\\-level pins over VCS dependency locks.  \\fI\\%#3296\\fP\r\n.UNINDENT\r\n.SS Vendored Libraries\r\n.INDENT 0.0\r\n.IP \\(bu 2\r\n.INDENT 2.0\r\n.TP\r\n.B Update vendored dependencies to resolve resolution output parsing and python finding:\r\n.INDENT 7.0\r\n.IP \\(bu 2\r\n\\fBpythonfinder 1.1.9 \\-> 1.1.10\\fP\r\n.IP \\(bu 2\r\n\\fBrequirementslib 1.3.1 \\-> 1.3.3\\fP\r\n.IP \\(bu 2\r\n\\fBvistir 0.2.3 \\-> 0.2.5\\fP  \\fI\\%#3280\\fP\r\n.UNINDENT\r\n.UNINDENT\r\n.UNINDENT\r\n.SS 2018.11.14 (2018\\-11\\-14)\r\n.SS Features & Improvements\r\n.INDENT 0.0\r\n.IP \\(bu 2\r\nImproved exceptions and error handling on failures.  \\fI\\%#1977\\fP\r\n.IP \\(bu 2\r\nAdded persistent settings for all CLI flags via \\fBPIPENV_{FLAG_NAME}\\fP environment variables by enabling \\fBauto_envvar_prefix=PIPENV\\fP in click (implements PEEP\\-0002).  \\fI\\%#2200\\fP\r\n.IP \\(bu 2\r\nAdded improved messaging about available but skipped updates due to dependency conflicts when running \\fBpipenv update \\-\\-outdated\\fP\\&.  \\fI\\%#2411\\fP\r\n.IP \\(bu 2\r\nAdded environment variable \\fBPIPENV_PYUP_API_KEY\\fP to add ability\r\nto override the bundled PyUP.io API key.  \\fI\\%#2825\\fP\r\n.IP \\(bu 2\r\nAdded additional output to \\fBpipenv update \\-\\-outdated\\fP to indicate that the operation succeeded and all packages were already up to date.  \\fI\\%#2828\\fP\r\n.IP \\(bu 2\r\nUpdated \\fBcrayons\\fP patch to enable colors on native powershell but swap native blue for magenta.  \\fI\\%#3020\\fP\r\n.IP \\(bu 2\r\nAdded support for \\fB\\-\\-bare\\fP to \\fBpipenv clean\\fP, and fixed \\fBpipenv sync \\-\\-bare\\fP to actually reduce output.  \\fI\\%#3041\\fP\r\n.IP \\(bu 2\r\nAdded windows\\-compatible spinner via upgraded \\fBvistir\\fP dependency.  \\fI\\%#3089\\fP\r\n.IP \\(bu 2\r\n.INDENT 2.0\r\n.IP \\(bu 2\r\nAdded support for python installations managed by \\fBasdf\\fP\\&.  \\fI\\%#3096\\fP\r\n.UNINDENT\r\n.IP \\(bu 2\r\nImproved runtime performance of no\\-op commands such as \\fBpipenv \\-\\-venv\\fP by around 2/3.  \\fI\\%#3158\\fP\r\n.IP \\(bu 2\r\nDo not show error but success for running \\fBpipenv uninstall \\-\\-all\\fP in a fresh virtual environment.  \\fI\\%#3170\\fP\r\n.IP \\(bu 2\r\nImproved asynchronous installation and error handling via queued subprocess parallelization.  \\fI\\%#3217\\fP\r\n.UNINDENT\r\n.SS Bug Fixes\r\n.INDENT 0.0\r\n.IP \\(bu 2\r\nRemote non\\-PyPI artifacts and local wheels and artifacts will now include their own hashes rather than including hashes from \\fBPyPI\\fP\\&.  \\fI\\%#2394\\fP\r\n.IP \\(bu 2\r\nNon\\-ascii characters will now be handled correctly when parsed by pipenv\\(aqs \\fBToML\\fP parsers.  \\fI\\%#2737\\fP\r\n.IP \\(bu 2\r\nUpdated \\fBpipenv uninstall\\fP to respect the \\fB\\-\\-skip\\-lock\\fP argument.  \\fI\\%#2848\\fP\r\n.IP \\(bu 2\r\nFixed a bug which caused uninstallation to sometimes fail to successfully remove packages from \\fBPipfiles\\fP with comments on preceding or following lines.  \\fI\\%#2885\\fP,\r\n\\fI\\%#3099\\fP\r\n.IP \\(bu 2\r\nPipenv will no longer fail when encountering python versions on Windows that have been uninstalled.  \\fI\\%#2983\\fP\r\n.IP \\(bu 2\r\nFixed unnecessary extras are added when translating markers  \\fI\\%#3026\\fP\r\n.IP \\(bu 2\r\nFixed a virtualenv creation issue which could cause new virtualenvs to inadvertently attempt to read and write to global site packages.  \\fI\\%#3047\\fP\r\n.IP \\(bu 2\r\nFixed an issue with virtualenv path derivation which could cause errors, particularly for users on WSL bash.  \\fI\\%#3055\\fP\r\n.IP \\(bu 2\r\nFixed a bug which caused \\fBUnexpected EOF\\fP errors to be thrown when \\fBpip\\fP was waiting for input from users who had put login credentials in environment variables.  \\fI\\%#3088\\fP\r\n.IP \\(bu 2\r\nFixed a bug in \\fBrequirementslib\\fP which prevented successful installation from mercurial repositories.  \\fI\\%#3090\\fP\r\n.IP \\(bu 2\r\nFixed random resource warnings when using pyenv or any other subprocess calls.  \\fI\\%#3094\\fP\r\n.IP \\(bu 2\r\n.INDENT 2.0\r\n.IP \\(bu 2\r\nFixed a bug which sometimes prevented cloning and parsing \\fBmercurial\\fP requirements.  \\fI\\%#3096\\fP\r\n.UNINDENT\r\n.IP \\(bu 2\r\nFixed an issue in \\fBdelegator.py\\fP related to subprocess calls when using \\fBPopenSpawn\\fP to stream output, which sometimes threw unexpected \\fBEOF\\fP errors.  \\fI\\%#3102\\fP,\r\n\\fI\\%#3114\\fP,\r\n\\fI\\%#3117\\fP\r\n.IP \\(bu 2\r\nFix the path casing issue that makes \\fIpipenv clean\\fP fail on Windows  \\fI\\%#3104\\fP\r\n.IP \\(bu 2\r\nPipenv will avoid leaving build artifacts in the current working directory.  \\fI\\%#3106\\fP\r\n.IP \\(bu 2\r\nFixed issues with broken subprocess calls leaking resource handles and causing random and sporadic failures.  \\fI\\%#3109\\fP\r\n.IP \\(bu 2\r\nFixed an issue which caused \\fBpipenv clean\\fP to sometimes clean packages from the base \\fBsite\\-packages\\fP folder or fail entirely.  \\fI\\%#3113\\fP\r\n.IP \\(bu 2\r\nUpdated \\fBpythonfinder\\fP to correct an issue with unnesting of nested paths when searching for python versions.  \\fI\\%#3121\\fP\r\n.IP \\(bu 2\r\nAdded additional logic for ignoring and replacing non\\-ascii characters when formatting console output on non\\-UTF\\-8 systems.  \\fI\\%#3131\\fP\r\n.IP \\(bu 2\r\nFix virtual environment discovery when \\fBPIPENV_VENV_IN_PROJECT\\fP is set, but the in\\-project \\fI\\&.venv\\fP is a file.  \\fI\\%#3134\\fP\r\n.IP \\(bu 2\r\nHashes for remote and local non\\-PyPI artifacts will now be included in \\fBPipfile.lock\\fP during resolution.  \\fI\\%#3145\\fP\r\n.IP \\(bu 2\r\nFix project path hashing logic in purpose to prevent collisions of virtual environments.  \\fI\\%#3151\\fP\r\n.IP \\(bu 2\r\nFix package installation when the virtual environment path contains parentheses.  \\fI\\%#3158\\fP\r\n.IP \\(bu 2\r\nAzure Pipelines YAML files are updated to use the latest syntax and product name.  \\fI\\%#3164\\fP\r\n.IP \\(bu 2\r\nFixed new spinner success message to write only one success message during resolution.  \\fI\\%#3183\\fP\r\n.IP \\(bu 2\r\nPipenv will now correctly respect the \\fB\\-\\-pre\\fP option when used with \\fBpipenv install\\fP\\&.  \\fI\\%#3185\\fP\r\n.IP \\(bu 2\r\nFix a bug where exception is raised when run pipenv graph in a project without created virtualenv  \\fI\\%#3201\\fP\r\n.IP \\(bu 2\r\nWhen sources are missing names, names will now be derived from the supplied URL.  \\fI\\%#3216\\fP\r\n.UNINDENT\r\n.SS Vendored Libraries\r\n.INDENT 0.0\r\n.IP \\(bu 2\r\nUpdated \\fBpythonfinder\\fP to correct an issue with unnesting of nested paths when searching for python versions.  \\fI\\%#3061\\fP,\r\n\\fI\\%#3121\\fP\r\n.IP \\(bu 2\r\n.INDENT 2.0\r\n.TP\r\n.B Updated vendored dependencies:\r\n.INDENT 7.0\r\n.IP \\(bu 2\r\n\\fBcertifi 2018.08.24 => 2018.10.15\\fP\r\n.IP \\(bu 2\r\n\\fBurllib3 1.23 => 1.24\\fP\r\n.IP \\(bu 2\r\n\\fBrequests 2.19.1 => 2.20.0\\fP\r\n.IP \\(bu 2\r\n\\fBshellingham \\(ga\\(ga1.2.6 => 1.2.7\\fP\r\n.IP \\(bu 2\r\n\\fBtomlkit 0.4.4. => 0.4.6\\fP\r\n.IP \\(bu 2\r\n\\fBvistir 0.1.6 => 0.1.8\\fP\r\n.IP \\(bu 2\r\n\\fBpythonfinder 0.1.2 => 0.1.3\\fP\r\n.IP \\(bu 2\r\n\\fBrequirementslib 1.1.9 => 1.1.10\\fP\r\n.IP \\(bu 2\r\n\\fBbackports.functools_lru_cache 1.5.0 (new)\\fP\r\n.IP \\(bu 2\r\n\\fBcursor 1.2.0 (new)\\fP  \\fI\\%#3089\\fP\r\n.UNINDENT\r\n.UNINDENT\r\n.IP \\(bu 2\r\n.INDENT 2.0\r\n.TP\r\n.B Updated vendored dependencies:\r\n.INDENT 7.0\r\n.IP \\(bu 2\r\n\\fBrequests 2.19.1 => 2.20.1\\fP\r\n.IP \\(bu 2\r\n\\fBtomlkit 0.4.46 => 0.5.2\\fP\r\n.IP \\(bu 2\r\n\\fBvistir 0.1.6 => 0.2.4\\fP\r\n.IP \\(bu 2\r\n\\fBpythonfinder 1.1.2 => 1.1.8\\fP\r\n.IP \\(bu 2\r\n\\fBrequirementslib 1.1.10 => 1.3.0\\fP  \\fI\\%#3096\\fP\r\n.UNINDENT\r\n.UNINDENT\r\n.IP \\(bu 2\r\nSwitch to \\fBtomlkit\\fP for parsing and writing. Drop \\fBprettytoml\\fP and \\fBcontoml\\fP from vendors.  \\fI\\%#3191\\fP\r\n.IP \\(bu 2\r\nUpdated \\fBrequirementslib\\fP to aid in resolution of local and remote archives.  \\fI\\%#3196\\fP\r\n.UNINDENT\r\n.SS Improved Documentation\r\n.INDENT 0.0\r\n.IP \\(bu 2\r\nExpanded development and testing documentation for contributors to get started.  \\fI\\%#3074\\fP\r\n.UNINDENT\r\n.SS 2018.10.13 (2018\\-10\\-13)\r\n.SS Bug Fixes\r\n.INDENT 0.0\r\n.IP \\(bu 2\r\nFixed a bug in \\fBpipenv clean\\fP which caused global packages to sometimes be inadvertently targeted for cleanup.  \\fI\\%#2849\\fP\r\n.IP \\(bu 2\r\nFix broken backport imports for vendored vistir.  \\fI\\%#2950\\fP,\r\n\\fI\\%#2955\\fP,\r\n\\fI\\%#2961\\fP\r\n.IP \\(bu 2\r\nFixed a bug with importing local vendored dependencies when running \\fBpipenv graph\\fP\\&.  \\fI\\%#2952\\fP\r\n.IP \\(bu 2\r\nFixed a bug which caused executable discovery to fail when running inside a virtualenv.  \\fI\\%#2957\\fP\r\n.IP \\(bu 2\r\nFix parsing of outline tables.  \\fI\\%#2971\\fP\r\n.IP \\(bu 2\r\nFixed a bug which caused \\fBverify_ssl\\fP to fail to drop through to \\fBpip install\\fP correctly as \\fBtrusted\\-host\\fP\\&.  \\fI\\%#2979\\fP\r\n.IP \\(bu 2\r\nFixed a bug which caused canonicalized package names to fail to resolve against PyPI.  \\fI\\%#2989\\fP\r\n.IP \\(bu 2\r\nEnhanced CI detection to detect Azure Devops builds.  \\fI\\%#2993\\fP\r\n.IP \\(bu 2\r\nFixed a bug which prevented installing pinned versions which used redirection symbols from the command line.  \\fI\\%#2998\\fP\r\n.IP \\(bu 2\r\nFixed a bug which prevented installing the local directory in non\\-editable mode.  \\fI\\%#3005\\fP\r\n.UNINDENT\r\n.SS Vendored Libraries\r\n.INDENT 0.0\r\n.IP \\(bu 2\r\nUpdated \\fBrequirementslib\\fP to version \\fB1.1.9\\fP\\&.  \\fI\\%#2989\\fP\r\n.IP \\(bu 2\r\nUpgraded \\fBpythonfinder => 1.1.1\\fP and \\fBvistir => 0.1.7\\fP\\&.  \\fI\\%#3007\\fP\r\n.UNINDENT\r\n.SS 2018.10.9 (2018\\-10\\-09)\r\n.SS Features & Improvements\r\n.INDENT 0.0\r\n.IP \\(bu 2\r\nAdded environment variables \\fIPIPENV_VERBOSE\\fP and \\fIPIPENV_QUIET\\fP to control\r\noutput verbosity without needing to pass options.  \\fI\\%#2527\\fP\r\n.IP \\(bu 2\r\nUpdated test\\-PyPI add\\-on to better support json\\-API access (forward compatibility).\r\nImproved testing process for new contributors.  \\fI\\%#2568\\fP\r\n.IP \\(bu 2\r\nGreatly enhanced python discovery functionality:\r\n.INDENT 2.0\r\n.IP \\(bu 2\r\nAdded pep514 (windows launcher/finder) support for python discovery.\r\n.IP \\(bu 2\r\nIntroduced architecture discovery for python installations which support different architectures.  \\fI\\%#2582\\fP\r\n.UNINDENT\r\n.IP \\(bu 2\r\nAdded support for \\fBpipenv shell\\fP on msys and cygwin/mingw/git bash for Windows.  \\fI\\%#2641\\fP\r\n.IP \\(bu 2\r\nEnhanced resolution of editable and VCS dependencies.  \\fI\\%#2643\\fP\r\n.IP \\(bu 2\r\nDeduplicate and refactor CLI to use stateful arguments and object passing.  See \\fI\\%this issue\\fP for reference.  \\fI\\%#2814\\fP\r\n.UNINDENT\r\n.SS Behavior Changes\r\n.INDENT 0.0\r\n.IP \\(bu 2\r\nVirtual environment activation for \\fBrun\\fP is revised to improve interpolation\r\nwith other Python discovery tools.  \\fI\\%#2503\\fP\r\n.IP \\(bu 2\r\nImprove terminal coloring to display better in Powershell.  \\fI\\%#2511\\fP\r\n.IP \\(bu 2\r\nInvoke \\fBvirtualenv\\fP directly for virtual environment creation, instead of depending on \\fBpew\\fP\\&.  \\fI\\%#2518\\fP\r\n.IP \\(bu 2\r\n\\fBpipenv \\-\\-help\\fP will now include short help descriptions.  \\fI\\%#2542\\fP\r\n.IP \\(bu 2\r\nAdd \\fBCOMSPEC\\fP to fallback option (along with \\fBSHELL\\fP and \\fBPYENV_SHELL\\fP)\r\nif shell detection fails, improving robustness on Windows.  \\fI\\%#2651\\fP\r\n.IP \\(bu 2\r\nFallback to shell mode if \\fIrun\\fP fails with Windows error 193 to handle non\\-executable commands. This should improve usability on Windows, where some users run non\\-executable files without specifying a command, relying on Windows file association to choose the current command.  \\fI\\%#2718\\fP\r\n.UNINDENT\r\n.SS Bug Fixes\r\n.INDENT 0.0\r\n.IP \\(bu 2\r\nFixed a bug which prevented installation of editable requirements using \\fBssh://\\fP style URLs  \\fI\\%#1393\\fP\r\n.IP \\(bu 2\r\nVCS Refs for locked local editable dependencies will now update appropriately to the latest hash when running \\fBpipenv update\\fP\\&.  \\fI\\%#1690\\fP\r\n.IP \\(bu 2\r\n\\fB\\&.tar.gz\\fP and \\fB\\&.zip\\fP artifacts will now have dependencies installed even when they are missing from the Lockfile.  \\fI\\%#2173\\fP\r\n.IP \\(bu 2\r\nThe command line parser will now handle multiple \\fB\\-e/\\-\\-editable\\fP dependencies properly via click\\(aqs option parser to help mitigate future parsing issues.  \\fI\\%#2279\\fP\r\n.IP \\(bu 2\r\nFixed the ability of pipenv to parse \\fBdependency_links\\fP from \\fBsetup.py\\fP when \\fBPIP_PROCESS_DEPENDENCY_LINKS\\fP is enabled.  \\fI\\%#2434\\fP\r\n.IP \\(bu 2\r\nFixed a bug which could cause \\fB\\-i/\\-\\-index\\fP arguments to sometimes be incorrectly picked up in packages.  This is now handled in the command line parser.  \\fI\\%#2494\\fP\r\n.IP \\(bu 2\r\nFixed non\\-deterministic resolution issues related to changes to the internal package finder in \\fBpip 10\\fP\\&.  \\fI\\%#2499\\fP,\r\n\\fI\\%#2529\\fP,\r\n\\fI\\%#2589\\fP,\r\n\\fI\\%#2666\\fP,\r\n\\fI\\%#2767\\fP,\r\n\\fI\\%#2785\\fP,\r\n\\fI\\%#2795\\fP,\r\n\\fI\\%#2801\\fP,\r\n\\fI\\%#2824\\fP,\r\n\\fI\\%#2862\\fP,\r\n\\fI\\%#2879\\fP,\r\n\\fI\\%#2894\\fP,\r\n\\fI\\%#2933\\fP\r\n.IP \\(bu 2\r\nFix subshell invocation on Windows for Python 2.  \\fI\\%#2515\\fP\r\n.IP \\(bu 2\r\nFixed a bug which sometimes caused pipenv to throw a \\fBTypeError\\fP or to run into encoding issues when writing a Lockfile on python 2.  \\fI\\%#2561\\fP\r\n.IP \\(bu 2\r\nImprove quoting logic for \\fBpipenv run\\fP so it works better with Windows\r\nbuilt\\-in commands.  \\fI\\%#2563\\fP\r\n.IP \\(bu 2\r\nFixed a bug related to parsing VCS requirements with both extras and subdirectory fragments.\r\nCorrected an issue in the \\fBrequirementslib\\fP parser which led to some markers being discarded rather than evaluated.  \\fI\\%#2564\\fP\r\n.IP \\(bu 2\r\nFixed multiple issues with finding the correct system python locations.  \\fI\\%#2582\\fP\r\n.IP \\(bu 2\r\nCatch JSON decoding error to prevent exception when the lock file is of\r\ninvalid format.  \\fI\\%#2607\\fP\r\n.IP \\(bu 2\r\nFixed a rare bug which could sometimes cause errors when installing packages with custom sources.  \\fI\\%#2610\\fP\r\n.IP \\(bu 2\r\nUpdate requirementslib to fix a bug which could raise an \\fBUnboundLocalError\\fP when parsing malformed VCS URIs.  \\fI\\%#2617\\fP\r\n.IP \\(bu 2\r\nFixed an issue which prevented passing multiple \\fB\\-\\-ignore\\fP parameters to \\fBpipenv check\\fP\\&.  \\fI\\%#2632\\fP\r\n.IP \\(bu 2\r\nFixed a bug which caused attempted hashing of \\fBssh://\\fP style URIs which could cause failures during installation of private ssh repositories.\r\n\\- Corrected path conversion issues which caused certain editable VCS paths to be converted to \\fBssh://\\fP URIs improperly.  \\fI\\%#2639\\fP\r\n.IP \\(bu 2\r\nFixed a bug which caused paths to be formatted incorrectly when using \\fBpipenv shell\\fP in bash for windows.  \\fI\\%#2641\\fP\r\n.IP \\(bu 2\r\nDependency links to private repositories defined via \\fBssh://\\fP schemes will now install correctly and skip hashing as long as \\fBPIP_PROCESS_DEPENDENCY_LINKS=1\\fP\\&.  \\fI\\%#2643\\fP\r\n.IP \\(bu 2\r\nFixed a bug which sometimes caused pipenv to parse the \\fBtrusted_host\\fP argument to pip incorrectly when parsing source URLs which specify \\fBverify_ssl = false\\fP\\&.  \\fI\\%#2656\\fP\r\n.IP \\(bu 2\r\nPrevent crashing when a virtual environment in \\fBWORKON_HOME\\fP is faulty.  \\fI\\%#2676\\fP\r\n.IP \\(bu 2\r\nFixed virtualenv creation failure when a .venv file is present in the project root.  \\fI\\%#2680\\fP\r\n.IP \\(bu 2\r\nFixed a bug which could cause the \\fB\\-e/\\-\\-editable\\fP argument on a dependency to be accidentally parsed as a dependency itself.  \\fI\\%#2714\\fP\r\n.IP \\(bu 2\r\nCorrectly pass \\fBverbose\\fP and \\fBdebug\\fP flags to the resolver subprocess so it generates appropriate output. This also resolves a bug introduced by the fix to #2527.  \\fI\\%#2732\\fP\r\n.IP \\(bu 2\r\nAll markers are now included in \\fBpipenv lock \\-\\-requirements\\fP output.  \\fI\\%#2748\\fP\r\n.IP \\(bu 2\r\nFixed a bug in marker resolution which could cause duplicate and non\\-deterministic markers.  \\fI\\%#2760\\fP\r\n.IP \\(bu 2\r\nFixed a bug in the dependency resolver which caused regular issues when handling \\fBsetup.py\\fP based dependency resolution.  \\fI\\%#2766\\fP\r\n.IP \\(bu 2\r\n.INDENT 2.0\r\n.TP\r\n.B Updated vendored dependencies:\r\n.INDENT 7.0\r\n.IP \\(bu 2\r\n\\fBpip\\-tools\\fP (updated and patched to latest w/ \\fBpip 18.0\\fP compatibility)\r\n.IP \\(bu 2\r\n\\fBpip 10.0.1 => 18.0\\fP\r\n.IP \\(bu 2\r\n\\fBclick 6.7 => 7.0\\fP\r\n.IP \\(bu 2\r\n\\fBtoml 0.9.4 => 0.10.0\\fP\r\n.IP \\(bu 2\r\n\\fBpyparsing 2.2.0 => 2.2.2\\fP\r\n.IP \\(bu 2\r\n\\fBdelegator 0.1.0 => 0.1.1\\fP\r\n.IP \\(bu 2\r\n\\fBattrs 18.1.0 => 18.2.0\\fP\r\n.IP \\(bu 2\r\n\\fBdistlib 0.2.7 => 0.2.8\\fP\r\n.IP \\(bu 2\r\n\\fBpackaging 17.1.0 => 18.0\\fP\r\n.IP \\(bu 2\r\n\\fBpassa 0.2.0 => 0.3.1\\fP\r\n.IP \\(bu 2\r\n\\fBpip_shims 0.1.2 => 0.3.1\\fP\r\n.IP \\(bu 2\r\n\\fBplette 0.1.1 => 0.2.2\\fP\r\n.IP \\(bu 2\r\n\\fBpythonfinder 1.0.2 => 1.1.0\\fP\r\n.IP \\(bu 2\r\n\\fBpytoml 0.1.18 => 0.1.19\\fP\r\n.IP \\(bu 2\r\n\\fBrequirementslib 1.1.16 => 1.1.17\\fP\r\n.IP \\(bu 2\r\n\\fBshellingham 1.2.4 => 1.2.6\\fP\r\n.IP \\(bu 2\r\n\\fBtomlkit 0.4.2 => 0.4.4\\fP\r\n.IP \\(bu 2\r\n\\fBvistir 0.1.4 => 0.1.6\\fP  \\fI\\%#2802\\fP,\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\n\\fI\\%#2867\\fP,\r\n\\fI\\%#2880\\fP\r\n.IP \\(bu 2\r\nFixed a bug where \\fIpipenv\\fP crashes when the \\fIWORKON_HOME\\fP directory does not exist.  \\fI\\%#2877\\fP\r\n.IP \\(bu 2\r\nFixed pip is not loaded from pipenv\\(aqs patched one but the system one  \\fI\\%#2912\\fP\r\n.IP \\(bu 2\r\nFixed various bugs related to \\fBpip 18.1\\fP release which prevented locking, installation, and syncing, and dumping to a \\fBrequirements.txt\\fP file.  \\fI\\%#2924\\fP\r\n.UNINDENT\r\n.SS Vendored Libraries\r\n.INDENT 0.0\r\n.IP \\(bu 2\r\nPew is no longer vendored. Entry point \\fBpewtwo\\fP, packages \\fBpipenv.pew\\fP and\r\n\\fBpipenv.patched.pew\\fP are removed.  \\fI\\%#2521\\fP\r\n.IP \\(bu 2\r\nUpdate \\fBpythonfinder\\fP to major release \\fB1.0.0\\fP for integration.  \\fI\\%#2582\\fP\r\n.IP \\(bu 2\r\nUpdate requirementslib to fix a bug which could raise an \\fBUnboundLocalError\\fP when parsing malformed VCS URIs.  \\fI\\%#2617\\fP\r\n.IP \\(bu 2\r\n.INDENT 2.0\r\n.IP \\(bu 2\r\nVendored new libraries \\fBvistir\\fP and \\fBpip\\-shims\\fP, \\fBtomlkit\\fP, \\fBmodutil\\fP, and \\fBplette\\fP\\&.\r\n.IP \\(bu 2\r\nUpdate vendored libraries:\r\n\\- \\fBscandir\\fP to \\fB1.9.0\\fP\r\n\\- \\fBclick\\-completion\\fP to \\fB0.4.1\\fP\r\n\\- \\fBsemver\\fP to \\fB2.8.1\\fP\r\n\\- \\fBshellingham\\fP to \\fB1.2.4\\fP\r\n\\- \\fBpytoml\\fP to \\fB0.1.18\\fP\r\n\\- \\fBcertifi\\fP to \\fB2018.8.24\\fP\r\n\\- \\fBptyprocess\\fP to \\fB0.6.0\\fP\r\n\\- \\fBrequirementslib\\fP to \\fB1.1.5\\fP\r\n\\- \\fBpythonfinder\\fP to \\fB1.0.2\\fP\r\n\\- \\fBpipdeptree\\fP to \\fB0.13.0\\fP\r\n\\- \\fBpython\\-dotenv\\fP to \\fB0.9.1\\fP  \\fI\\%#2639\\fP\r\n.UNINDENT\r\n.IP \\(bu 2\r\n.INDENT 2.0\r\n.TP\r\n.B Updated vendored dependencies:\r\n.INDENT 7.0\r\n.IP \\(bu 2\r\n\\fBpip\\-tools\\fP (updated and patched to latest w/ \\fBpip 18.0\\fP compatibility)\r\n.IP \\(bu 2\r\n\\fBpip 10.0.1 => 18.0\\fP\r\n.IP \\(bu 2\r\n\\fBclick 6.7 => 7.0\\fP\r\n.IP \\(bu 2\r\n\\fBtoml 0.9.4 => 0.10.0\\fP\r\n.IP \\(bu 2\r\n\\fBpyparsing 2.2.0 => 2.2.2\\fP\r\n.IP \\(bu 2\r\n\\fBdelegator 0.1.0 => 0.1.1\\fP\r\n.IP \\(bu 2\r\n\\fBattrs 18.1.0 => 18.2.0\\fP\r\n.IP \\(bu 2\r\n\\fBdistlib 0.2.7 => 0.2.8\\fP\r\n.IP \\(bu 2\r\n\\fBpackaging 17.1.0 => 18.0\\fP\r\n.IP \\(bu 2\r\n\\fBpassa 0.2.0 => 0.3.1\\fP\r\n.IP \\(bu 2\r\n\\fBpip_shims 0.1.2 => 0.3.1\\fP\r\n.IP \\(bu 2\r\n\\fBplette 0.1.1 => 0.2.2\\fP\r\n.IP \\(bu 2\r\n\\fBpythonfinder 1.0.2 => 1.1.0\\fP\r\n.IP \\(bu 2\r\n\\fBpytoml 0.1.18 => 0.1.19\\fP\r\n.IP \\(bu 2\r\n\\fBrequirementslib 1.1.16 => 1.1.17\\fP\r\n.IP \\(bu 2\r\n\\fBshellingham 1.2.4 => 1.2.6\\fP\r\n.IP \\(bu 2\r\n\\fBtomlkit 0.4.2 => 0.4.4\\fP\r\n.IP \\(bu 2\r\n\\fBvistir 0.1.4 => 0.1.6\\fP  \\fI\\%#2902\\fP,\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\n\\fI\\%#2935\\fP\r\n.UNINDENT\r\n.SS Improved Documentation\r\n.INDENT 0.0\r\n.IP \\(bu 2\r\nSimplified the test configuration process.  \\fI\\%#2568\\fP\r\n.IP \\(bu 2\r\nUpdated documentation to use working fortune cookie add\\-on.  \\fI\\%#2644\\fP\r\n.IP \\(bu 2\r\nAdded additional information about troubleshooting \\fBpipenv shell\\fP by using the the \\fB$PIPENV_SHELL\\fP environment variable.  \\fI\\%#2671\\fP\r\n.IP \\(bu 2\r\nAdded a link to \\fBPEP\\-440\\fP version specifiers in the documentation for additional detail.  \\fI\\%#2674\\fP\r\n.IP \\(bu 2\r\nAdded simple example to README.md for installing from git.  \\fI\\%#2685\\fP\r\n.IP \\(bu 2\r\nStopped recommending \\fI\\-\\-system\\fP for Docker contexts.  \\fI\\%#2762\\fP\r\n.IP \\(bu 2\r\nFixed the example url for doing \"pipenv install \\-e\r\nsome\\-repository\\-url#egg=something\", it was missing the \"egg=\" in the fragment\r\nidentifier.  \\fI\\%#2792\\fP\r\n.IP \\(bu 2\r\nFixed link to the \"be cordial\" essay in the contribution documentation.  \\fI\\%#2793\\fP\r\n.IP \\(bu 2\r\nClarify \\fIpipenv install\\fP documentation  \\fI\\%#2844\\fP\r\n.IP \\(bu 2\r\nReplace reference to uservoice with PEEP\\-000  \\fI\\%#2909\\fP\r\n.UNINDENT\r\n.SS 2018.7.1 (2018\\-07\\-01)\r\n.SS Features & Improvements\r\n.INDENT 0.0\r\n.IP \\(bu 2\r\nAll calls to \\fBpipenv shell\\fP are now implemented from the ground up using \\fI\\%shellingham\\fP, a custom library which was purpose built to handle edge cases and shell detection.  \\fI\\%#2371\\fP\r\n.IP \\(bu 2\r\nAdded support for python 3.7 via a few small compatibility / bug fixes.  \\fI\\%#2427\\fP,\r\n\\fI\\%#2434\\fP,\r\n\\fI\\%#2436\\fP\r\n.IP \\(bu 2\r\nAdded new flag \\fBpipenv \\-\\-support\\fP to replace the diagnostic command \\fBpython \\-m pipenv.help\\fP\\&.  \\fI\\%#2477\\fP,\r\n\\fI\\%#2478\\fP\r\n.IP \\(bu 2\r\nImproved import times and CLI run times with minor tweaks.  \\fI\\%#2485\\fP\r\n.UNINDENT\r\n.SS Bug Fixes\r\n.INDENT 0.0\r\n.IP \\(bu 2\r\nFixed an ongoing bug which sometimes resolved incompatible versions into the project Lockfile.  \\fI\\%#1901\\fP\r\n.IP \\(bu 2\r\nFixed a bug which caused errors when creating virtualenvs which contained leading dash characters.  \\fI\\%#2415\\fP\r\n.IP \\(bu 2\r\nFixed a logic error which caused \\fB\\-\\-deploy \\-\\-system\\fP to overwrite editable vcs packages in the Pipfile before installing, which caused any installation to fail by default.  \\fI\\%#2417\\fP\r\n.IP \\(bu 2\r\nUpdated requirementslib to fix an issue with properly quoting markers in VCS requirements.  \\fI\\%#2419\\fP\r\n.IP \\(bu 2\r\nInstalled new vendored jinja2 templates for \\fBclick\\-completion\\fP which were causing template errors for users with completion enabled.  \\fI\\%#2422\\fP\r\n.IP \\(bu 2\r\nAdded support for python 3.7 via a few small compatibility / bug fixes.  \\fI\\%#2427\\fP\r\n.IP \\(bu 2\r\nFixed an issue reading package names from \\fBsetup.py\\fP files in projects which imported utilities such as \\fBversioneer\\fP\\&.  \\fI\\%#2433\\fP\r\n.IP \\(bu 2\r\nPipenv will now ensure that its internal package names registry files are written with unicode strings.  \\fI\\%#2450\\fP\r\n.IP \\(bu 2\r\nFixed a bug causing requirements input as relative paths to be output as absolute paths or URIs.\r\nFixed a bug affecting normalization of \\fBgit+git@host\\fP URLs.  \\fI\\%#2453\\fP\r\n.IP \\(bu 2\r\nPipenv will now always use \\fBpathlib2\\fP for \\fBPath\\fP based filesystem interactions by default on \\fBpython<3.5\\fP\\&.  \\fI\\%#2454\\fP\r\n.IP \\(bu 2\r\nFixed a bug which prevented passing proxy PyPI indexes set with \\fB\\-\\-pypi\\-mirror\\fP from being passed to pip during virtualenv creation, which could cause the creation to freeze in some cases.  \\fI\\%#2462\\fP\r\n.IP \\(bu 2\r\nUsing the \\fBpython \\-m pipenv.help\\fP command will now use proper encoding for the host filesystem to avoid encoding issues.  \\fI\\%#2466\\fP\r\n.IP \\(bu 2\r\nThe new \\fBjinja2\\fP templates for \\fBclick_completion\\fP will now be included in pipenv source distributions.  \\fI\\%#2479\\fP\r\n.IP \\(bu 2\r\nResolved a long\\-standing issue with re\\-using previously generated \\fBInstallRequirement\\fP objects for resolution which could cause \\fBPKG\\-INFO\\fP file information to be deleted, raising a \\fBTypeError\\fP\\&.  \\fI\\%#2480\\fP\r\n.IP \\(bu 2\r\nResolved an issue parsing usernames from private PyPI URIs in \\fBPipfiles\\fP by updating \\fBrequirementslib\\fP\\&.  \\fI\\%#2484\\fP\r\n.UNINDENT\r\n.SS Vendored Libraries\r\n.INDENT 0.0\r\n.IP \\(bu 2\r\nAll calls to \\fBpipenv shell\\fP are now implemented from the ground up using \\fI\\%shellingham\\fP, a custom library which was purpose built to handle edge cases and shell detection.  \\fI\\%#2371\\fP\r\n.IP \\(bu 2\r\nUpdated requirementslib to fix an issue with properly quoting markers in VCS requirements.  \\fI\\%#2419\\fP\r\n.IP \\(bu 2\r\nInstalled new vendored jinja2 templates for \\fBclick\\-completion\\fP which were causing template errors for users with completion enabled.  \\fI\\%#2422\\fP\r\n.IP \\(bu 2\r\nAdd patch to \\fBprettytoml\\fP to support Python 3.7.  \\fI\\%#2426\\fP\r\n.IP \\(bu 2\r\nPatched \\fBprettytoml.AbstractTable._enumerate_items\\fP to handle \\fBStopIteration\\fP errors in preparation of release of python 3.7.  \\fI\\%#2427\\fP\r\n.IP \\(bu 2\r\nFixed an issue reading package names from \\fBsetup.py\\fP files in projects which imported utilities such as \\fBversioneer\\fP\\&.  \\fI\\%#2433\\fP\r\n.IP \\(bu 2\r\nUpdated \\fBrequirementslib\\fP to version \\fB1.0.9\\fP  \\fI\\%#2453\\fP\r\n.IP \\(bu 2\r\nUnraveled a lot of old, unnecessary patches to \\fBpip\\-tools\\fP which were causing non\\-deterministic resolution errors.  \\fI\\%#2480\\fP\r\n.IP \\(bu 2\r\nResolved an issue parsing usernames from private PyPI URIs in \\fBPipfiles\\fP by updating \\fBrequirementslib\\fP\\&.  \\fI\\%#2484\\fP\r\n.UNINDENT\r\n.SS Improved Documentation\r\n.INDENT 0.0\r\n.IP \\(bu 2\r\nAdded instructions for installing using Fedora\\(aqs official repositories.  \\fI\\%#2404\\fP\r\n.UNINDENT\r\n.SS 2018.6.25 (2018\\-06\\-25)\r\n.SS Features & Improvements\r\n.INDENT 0.0\r\n.IP \\(bu 2\r\nPipenv\\-created virtualenvs will now be associated with a \\fB\\&.project\\fP folder\r\n(features can be implemented on top of this later or users may choose to use\r\n\\fBpipenv\\-pipes\\fP to take full advantage of this.)  \\fI\\%#1861\\fP\r\n.IP \\(bu 2\r\nVirtualenv names will now appear in prompts for most Windows users.  \\fI\\%#2167\\fP\r\n.IP \\(bu 2\r\nAdded support for cmder shell paths with spaces.  \\fI\\%#2168\\fP\r\n.IP \\(bu 2\r\nAdded nested JSON output to the \\fBpipenv graph\\fP command.  \\fI\\%#2199\\fP\r\n.IP \\(bu 2\r\nDropped vendored pip 9 and vendored, patched, and migrated to pip 10. Updated\r\npatched piptools version.  \\fI\\%#2255\\fP\r\n.IP \\(bu 2\r\nPyPI mirror URLs can now be set to override instances of PyPI URLs by passing\r\nthe \\fB\\-\\-pypi\\-mirror\\fP argument from the command line or setting the\r\n\\fBPIPENV_PYPI_MIRROR\\fP environment variable.  \\fI\\%#2281\\fP\r\n.IP \\(bu 2\r\nVirtualenv activation lines will now avoid being written to some shell\r\nhistory files.  \\fI\\%#2287\\fP\r\n.IP \\(bu 2\r\nPipenv will now only search for \\fBrequirements.txt\\fP files when creating new\r\nprojects, and during that time only if the user doesn\\(aqt specify packages to\r\npass in.  \\fI\\%#2309\\fP\r\n.IP \\(bu 2\r\nAdded support for mounted drives via UNC paths.  \\fI\\%#2331\\fP\r\n.IP \\(bu 2\r\nAdded support for Windows Subsystem for Linux bash shell detection.  \\fI\\%#2363\\fP\r\n.IP \\(bu 2\r\nPipenv will now generate hashes much more quickly by resolving them in a\r\nsingle pass during locking.  \\fI\\%#2384\\fP\r\n.IP \\(bu 2\r\n\\fBpipenv run\\fP will now avoid spawning additional \\fBCOMSPEC\\fP instances to\r\nrun commands in when possible.  \\fI\\%#2385\\fP\r\n.IP \\(bu 2\r\nMassive internal improvements to requirements parsing codebase, resolver, and\r\nerror messaging.  \\fI\\%#2388\\fP\r\n.IP \\(bu 2\r\n\\fBpipenv check\\fP now may take multiple of the additional argument\r\n\\fB\\-\\-ignore\\fP which takes a parameter \\fBcve_id\\fP for the purpose of ignoring\r\nspecific CVEs.  \\fI\\%#2408\\fP\r\n.UNINDENT\r\n.SS Behavior Changes\r\n.INDENT 0.0\r\n.IP \\(bu 2\r\nPipenv will now parse & capitalize \\fBplatform_python_implementation\\fP markers\r\n\\&.. warning:: This could cause an issue if you have an out of date \\fBPipfile\\fP\r\nwhich lower\\-cases the comparison value (e.g. \\fBcpython\\fP instead of\r\n\\fBCPython\\fP).  \\fI\\%#2123\\fP\r\n.IP \\(bu 2\r\nPipenv will now only search for \\fBrequirements.txt\\fP files when creating new\r\nprojects, and during that time only if the user doesn\\(aqt specify packages to\r\npass in.  \\fI\\%#2309\\fP\r\n.UNINDENT\r\n.SS Bug Fixes\r\n.INDENT 0.0\r\n.IP \\(bu 2\r\nMassive internal improvements to requirements parsing codebase, resolver, and\r\nerror messaging.  \\fI\\%#1962\\fP,\r\n\\fI\\%#2186\\fP,\r\n\\fI\\%#2263\\fP,\r\n\\fI\\%#2312\\fP\r\n.IP \\(bu 2\r\nPipenv will now parse & capitalize \\fBplatform_python_implementation\\fP\r\nmarkers.  \\fI\\%#2123\\fP\r\n.IP \\(bu 2\r\nFixed a bug with parsing and grouping old\\-style \\fBsetup.py\\fP extras during\r\nresolution  \\fI\\%#2142\\fP\r\n.IP \\(bu 2\r\nFixed a bug causing pipenv graph to throw unhelpful exceptions when running\r\nagainst empty or non\\-existent environments.  \\fI\\%#2161\\fP\r\n.IP \\(bu 2\r\nFixed a bug which caused \\fB\\-\\-system\\fP to incorrectly abort when users were in\r\na virtualenv.  \\fI\\%#2181\\fP\r\n.IP \\(bu 2\r\nRemoved vendored \\fBcacert.pem\\fP which could cause issues for some users with\r\ncustom certificate settings.  \\fI\\%#2193\\fP\r\n.IP \\(bu 2\r\nFixed a regression which led to direct invocations of \\fBvirtualenv\\fP, rather\r\nthan calling it by module.  \\fI\\%#2198\\fP\r\n.IP \\(bu 2\r\nLocking will now pin the correct VCS ref during \\fBpipenv update\\fP runs.\r\nRunning \\fBpipenv update\\fP with a new vcs ref specified in the \\fBPipfile\\fP\r\nwill now properly obtain, resolve, and install the specified dependency at\r\nthe specified ref.  \\fI\\%#2209\\fP\r\n.IP \\(bu 2\r\n\\fBpipenv clean\\fP will now correctly ignore comments from \\fBpip freeze\\fP when\r\ncleaning the environment.  \\fI\\%#2262\\fP\r\n.IP \\(bu 2\r\nResolution bugs causing packages for incompatible python versions to be\r\nlocked have been fixed.  \\fI\\%#2267\\fP\r\n.IP \\(bu 2\r\nFixed a bug causing pipenv graph to fail to display sometimes.  \\fI\\%#2268\\fP\r\n.IP \\(bu 2\r\nUpdated \\fBrequirementslib\\fP to fix a bug in Pipfile parsing affecting\r\nrelative path conversions.  \\fI\\%#2269\\fP\r\n.IP \\(bu 2\r\nWindows executable discovery now leverages \\fBos.pathext\\fP\\&.  \\fI\\%#2298\\fP\r\n.IP \\(bu 2\r\nFixed a bug which caused \\fB\\-\\-deploy \\-\\-system\\fP to inadvertently create a\r\nvirtualenv before failing.  \\fI\\%#2301\\fP\r\n.IP \\(bu 2\r\nFixed an issue which led to a failure to unquote special characters in file\r\nand wheel paths.  \\fI\\%#2302\\fP\r\n.IP \\(bu 2\r\nVCS dependencies are now manually obtained only if they do not match the\r\nrequested ref.  \\fI\\%#2304\\fP\r\n.IP \\(bu 2\r\nAdded error handling functionality to properly cope with single\\-digit\r\n\\fBRequires\\-Python\\fP metadata with no specifiers.  \\fI\\%#2377\\fP\r\n.IP \\(bu 2\r\n\\fBpipenv update\\fP will now always run the resolver and lock before ensuring\r\ndependencies are in sync with project Lockfile.  \\fI\\%#2379\\fP\r\n.IP \\(bu 2\r\nResolved a bug in our patched resolvers which could cause nondeterministic\r\nresolution failures in certain conditions. Running \\fBpipenv install\\fP with no\r\narguments in a project with only a \\fBPipfile\\fP will now correctly lock first\r\nfor dependency resolution before installing.  \\fI\\%#2384\\fP\r\n.IP \\(bu 2\r\nPatched \\fBpython\\-dotenv\\fP to ensure that environment variables always get\r\nencoded to the filesystem encoding.  \\fI\\%#2386\\fP\r\n.UNINDENT\r\n.SS Improved Documentation\r\n.INDENT 0.0\r\n.IP \\(bu 2\r\nUpdate documentation wording to clarify Pipenv\\(aqs overall role in the packaging ecosystem.  \\fI\\%#2194\\fP\r\n.IP \\(bu 2\r\nAdded contribution documentation and guidelines.  \\fI\\%#2205\\fP\r\n.IP \\(bu 2\r\nAdded instructions for supervisord compatibility.  \\fI\\%#2215\\fP\r\n.IP \\(bu 2\r\nFixed broken links to development philosophy and contribution documentation.  \\fI\\%#2248\\fP\r\n.UNINDENT\r\n.SS Vendored Libraries\r\n.INDENT 0.0\r\n.IP \\(bu 2\r\nRemoved vendored \\fBcacert.pem\\fP which could cause issues for some users with\r\ncustom certificate settings.  \\fI\\%#2193\\fP\r\n.IP \\(bu 2\r\nDropped vendored pip 9 and vendored, patched, and migrated to pip 10. Updated\r\npatched piptools version.  \\fI\\%#2255\\fP\r\n.IP \\(bu 2\r\nUpdated \\fBrequirementslib\\fP to fix a bug in Pipfile parsing affecting\r\nrelative path conversions.  \\fI\\%#2269\\fP\r\n.IP \\(bu 2\r\nAdded custom shell detection library \\fBshellingham\\fP, a port of our changes\r\nto \\fBpew\\fP\\&.  \\fI\\%#2363\\fP\r\n.IP \\(bu 2\r\nPatched \\fBpython\\-dotenv\\fP to ensure that environment variables always get\r\nencoded to the filesystem encoding.  \\fI\\%#2386\\fP\r\n.IP \\(bu 2\r\nUpdated vendored libraries. The following vendored libraries were updated:\r\n.INDENT 2.0\r\n.IP \\(bu 2\r\ndistlib from version \\fB0.2.6\\fP to \\fB0.2.7\\fP\\&.\r\n.IP \\(bu 2\r\njinja2 from version \\fB2.9.5\\fP to \\fB2.10\\fP\\&.\r\n.IP \\(bu 2\r\npathlib2 from version \\fB2.1.0\\fP to \\fB2.3.2\\fP\\&.\r\n.IP \\(bu 2\r\nparse from version \\fB2.8.0\\fP to \\fB2.8.4\\fP\\&.\r\n.IP \\(bu 2\r\npexpect from version \\fB2.5.2\\fP to \\fB2.6.0\\fP\\&.\r\n.IP \\(bu 2\r\nrequests from version \\fB2.18.4\\fP to \\fB2.19.1\\fP\\&.\r\n.IP \\(bu 2\r\nidna from version \\fB2.6\\fP to \\fB2.7\\fP\\&.\r\n.IP \\(bu 2\r\ncertifi from version \\fB2018.1.16\\fP to \\fB2018.4.16\\fP\\&.\r\n.IP \\(bu 2\r\npackaging from version \\fB16.8\\fP to \\fB17.1\\fP\\&.\r\n.IP \\(bu 2\r\nsix from version \\fB1.10.0\\fP to \\fB1.11.0\\fP\\&.\r\n.IP \\(bu 2\r\nrequirementslib from version \\fB0.2.0\\fP to \\fB1.0.1\\fP\\&.\r\n.UNINDENT\r\n.sp\r\nIn addition, scandir was vendored and patched to avoid importing host system binaries when falling back to pathlib2.  \\fI\\%#2368\\fP\r\n.UNINDENT\r\n.SH USER TESTIMONIALS\r\n.INDENT 0.0\r\n.TP\r\n\\fBDavid Gang\\fP—\r\n\\fIThis package manager is really awesome. For the first time I know exactly what my dependencies are which I installed and what the transitive dependencies are. Combined with the fact that installs are deterministic, makes this package manager first class, like cargo\\fP\\&.\r\n.TP\r\n\\fBJustin Myles Holmes\\fP—\r\n\\fIPipenv is finally an abstraction meant to engage the mind instead of merely the filesystem.\\fP\r\n.UNINDENT\r\n.SH ☤ PIPENV FEATURES\r\n.INDENT 0.0\r\n.IP \\(bu 2\r\nEnables truly \\fIdeterministic builds\\fP, while easily specifying \\fIonly what you want\\fP\\&.\r\n.IP \\(bu 2\r\nGenerates and checks file hashes for locked dependencies.\r\n.IP \\(bu 2\r\nAutomatically install required Pythons, if \\fBpyenv\\fP is available.\r\n.IP \\(bu 2\r\nAutomatically finds your project home, recursively, by looking for a \\fBPipfile\\fP\\&.\r\n.IP \\(bu 2\r\nAutomatically generates a \\fBPipfile\\fP, if one doesn\\(aqt exist.\r\n.IP \\(bu 2\r\nAutomatically creates a virtualenv in a standard location.\r\n.IP \\(bu 2\r\nAutomatically adds/removes packages to a \\fBPipfile\\fP when they are installed or uninstalled.\r\n.IP \\(bu 2\r\nAutomatically loads \\fB\\&.env\\fP files, if they exist.\r\n.UNINDENT\r\n.sp\r\nThe main commands are \\fBinstall\\fP, \\fBuninstall\\fP, and \\fBlock\\fP, which generates a \\fBPipfile.lock\\fP\\&. These are intended to replace \\fB$ pip install\\fP usage, as well as manual virtualenv management (to activate a virtualenv, run \\fB$ pipenv shell\\fP).\r\n.SS Basic Concepts\r\n.INDENT 0.0\r\n.IP \\(bu 2\r\nA virtualenv will automatically be created, when one doesn\\(aqt exist.\r\n.IP \\(bu 2\r\nWhen no parameters are passed to \\fBinstall\\fP, all packages \\fB[packages]\\fP specified will be installed.\r\n.IP \\(bu 2\r\nTo initialize a Python 3 virtual environment, run \\fB$ pipenv \\-\\-three\\fP\\&.\r\n.IP \\(bu 2\r\nTo initialize a Python 2 virtual environment, run \\fB$ pipenv \\-\\-two\\fP\\&.\r\n.IP \\(bu 2\r\nOtherwise, whatever virtualenv defaults to will be the default.\r\n.UNINDENT\r\n.SS Other Commands\r\n.INDENT 0.0\r\n.IP \\(bu 2\r\n\\fBgraph\\fP will show you a dependency graph of your installed dependencies.\r\n.IP \\(bu 2\r\n\\fBshell\\fP will spawn a shell with the virtualenv activated. This shell can be deactivated by using \\fBexit\\fP\\&.\r\n.IP \\(bu 2\r\n\\fBrun\\fP will run a given command from the virtualenv, with any arguments forwarded (e.g. \\fB$ pipenv run python\\fP or \\fB$ pipenv run pip freeze\\fP).\r\n.IP \\(bu 2\r\n\\fBcheck\\fP checks for security vulnerabilities and asserts that PEP 508 requirements are being met by the current environment.\r\n.UNINDENT\r\n.SH FURTHER DOCUMENTATION GUIDES\r\n.SS Basic Usage of Pipenv\r\n[image]\r\n.sp\r\nThis document covers some of Pipenv\\(aqs more basic features.\r\n.SS ☤ Example Pipfile & Pipfile.lock\r\n.sp\r\nPipfiles contain information for the dependencies of the project, and supersedes\r\nthe requirements.txt file used in most Python projects. You should add a Pipfile in the\r\nGit repository letting users who clone the repository know the only thing required would be\r\ninstalling Pipenv in the machine and typing \\fBpipenv install\\fP\\&. Pipenv is a reference\r\nimplementation for using Pipfile.\r\n.sp\r\nHere is a simple example of a \\fBPipfile\\fP and the resulting \\fBPipfile.lock\\fP\\&.\r\n.SS Example Pipfile\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n[[source]]\r\nurl = \"https://pypi.python.org/simple\"\r\nverify_ssl = true\r\nname = \"pypi\"\r\n\r\n[packages]\r\nrequests = \"*\"\r\n\r\n\r\n[dev\\-packages]\r\npytest = \"*\"\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.SS Example Pipfile.lock\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n{\r\n    \"_meta\": {\r\n        \"hash\": {\r\n            \"sha256\": \"8d14434df45e0ef884d6c3f6e8048ba72335637a8631cc44792f52fd20b6f97a\"\r\n        },\r\n        \"host\\-environment\\-markers\": {\r\n            \"implementation_name\": \"cpython\",\r\n            \"implementation_version\": \"3.6.1\",\r\n            \"os_name\": \"posix\",\r\n            \"platform_machine\": \"x86_64\",\r\n            \"platform_python_implementation\": \"CPython\",\r\n            \"platform_release\": \"16.7.0\",\r\n            \"platform_system\": \"Darwin\",\r\n            \"platform_version\": \"Darwin Kernel Version 16.7.0: Thu Jun 15 17:36:27 PDT 2017; root:xnu\\-3789.70.16~2/RELEASE_X86_64\",\r\n            \"python_full_version\": \"3.6.1\",\r\n            \"python_version\": \"3.6\",\r\n            \"sys_platform\": \"darwin\"\r\n        },\r\n        \"pipfile\\-spec\": 5,\r\n        \"requires\": {},\r\n        \"sources\": [\r\n            {\r\n                \"name\": \"pypi\",\r\n                \"url\": \"https://pypi.python.org/simple\",\r\n                \"verify_ssl\": true\r\n            }\r\n        ]\r\n    },\r\n    \"default\": {\r\n        \"certifi\": {\r\n            \"hashes\": [\r\n                \"sha256:54a07c09c586b0e4c619f02a5e94e36619da8e2b053e20f594348c0611803704\",\r\n                \"sha256:40523d2efb60523e113b44602298f0960e900388cf3bb6043f645cf57ea9e3f5\"\r\n            ],\r\n            \"version\": \"==2017.7.27.1\"\r\n        },\r\n        \"chardet\": {\r\n            \"hashes\": [\r\n                \"sha256:fc323ffcaeaed0e0a02bf4d117757b98aed530d9ed4531e3e15460124c106691\",\r\n                \"sha256:84ab92ed1c4d4f16916e05906b6b75a6c0fb5db821cc65e70cbd64a3e2a5eaae\"\r\n            ],\r\n            \"version\": \"==3.0.4\"\r\n        },\r\n        \"idna\": {\r\n            \"hashes\": [\r\n                \"sha256:8c7309c718f94b3a625cb648ace320157ad16ff131ae0af362c9f21b80ef6ec4\",\r\n                \"sha256:2c6a5de3089009e3da7c5dde64a141dbc8551d5b7f6cf4ed7c2568d0cc520a8f\"\r\n            ],\r\n            \"version\": \"==2.6\"\r\n        },\r\n        \"requests\": {\r\n            \"hashes\": [\r\n                \"sha256:6a1b267aa90cac58ac3a765d067950e7dbbf75b1da07e895d1f594193a40a38b\",\r\n                \"sha256:9c443e7324ba5b85070c4a818ade28bfabedf16ea10206da1132edaa6dda237e\"\r\n            ],\r\n            \"version\": \"==2.18.4\"\r\n        },\r\n        \"urllib3\": {\r\n            \"hashes\": [\r\n                \"sha256:06330f386d6e4b195fbfc736b297f58c5a892e4440e54d294d7004e3a9bbea1b\",\r\n                \"sha256:cc44da8e1145637334317feebd728bd869a35285b93cbb4cca2577da7e62db4f\"\r\n            ],\r\n            \"version\": \"==1.22\"\r\n        }\r\n    },\r\n    \"develop\": {\r\n        \"py\": {\r\n            \"hashes\": [\r\n                \"sha256:2ccb79b01769d99115aa600d7eed99f524bf752bba8f041dc1c184853514655a\",\r\n                \"sha256:0f2d585d22050e90c7d293b6451c83db097df77871974d90efd5a30dc12fcde3\"\r\n            ],\r\n            \"version\": \"==1.4.34\"\r\n        },\r\n        \"pytest\": {\r\n            \"hashes\": [\r\n                \"sha256:b84f554f8ddc23add65c411bf112b2d88e2489fd45f753b1cae5936358bdf314\",\r\n                \"sha256:f46e49e0340a532764991c498244a60e3a37d7424a532b3ff1a6a7653f1a403a\"\r\n            ],\r\n            \"version\": \"==3.2.2\"\r\n        }\r\n    }\r\n}\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.SS ☤ General Recommendations & Version Control\r\n.INDENT 0.0\r\n.IP \\(bu 2\r\nGenerally, keep both \\fBPipfile\\fP and \\fBPipfile.lock\\fP in version control.\r\n.IP \\(bu 2\r\nDo not keep \\fBPipfile.lock\\fP in version control if multiple versions of Python are being targeted.\r\n.IP \\(bu 2\r\nSpecify your target Python version in your \\fIPipfile\\fP\\(aqs \\fB[requires]\\fP section. Ideally, you should only have one target Python version, as this is a deployment tool. \\fBpython_version\\fP should be in the format \\fBX.Y\\fP and \\fBpython_full_version\\fP should be in \\fBX.Y.Z\\fP format.\r\n.IP \\(bu 2\r\n\\fBpipenv install\\fP is fully compatible with \\fBpip install\\fP syntax, for which the full documentation can be found \\fI\\%here\\fP\\&.\r\n.IP \\(bu 2\r\nNote that the \\fBPipfile\\fP uses the \\fI\\%TOML Spec\\fP\\&.\r\n.UNINDENT\r\n.SS ☤ Example Pipenv Workflow\r\n.sp\r\nClone / create project repository:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n$ cd myproject\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\nInstall from Pipfile, if there is one:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n$ pipenv install\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\nOr, add a package to your new project:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n$ pipenv install <package>\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\nThis will create a \\fBPipfile\\fP if one doesn\\(aqt exist. If one does exist, it will automatically be edited with the new package you provided.\r\n.sp\r\nNext, activate the Pipenv shell:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n$ pipenv shell\r\n$ python \\-\\-version\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\nThis will spawn a new shell subprocess, which can be deactivated by using \\fBexit\\fP\\&.\r\n.SS ☤ Example Pipenv Upgrade Workflow\r\n.INDENT 0.0\r\n.IP \\(bu 2\r\nFind out what\\(aqs changed upstream: \\fB$ pipenv update \\-\\-outdated\\fP\\&.\r\n.IP \\(bu 2\r\n.INDENT 2.0\r\n.TP\r\n.B Upgrade packages, two options:\r\n.INDENT 7.0\r\n.IP a. 3\r\nWant to upgrade everything? Just do \\fB$ pipenv update\\fP\\&.\r\n.IP b. 3\r\nWant to upgrade packages one\\-at\\-a\\-time? \\fB$ pipenv update <pkg>\\fP for each outdated package.\r\n.UNINDENT\r\n.UNINDENT\r\n.UNINDENT\r\n.SS ☤ Importing from requirements.txt\r\n.sp\r\nIf you only have a \\fBrequirements.txt\\fP file available when running \\fBpipenv install\\fP,\r\npipenv will automatically import the contents of this file and create a \\fBPipfile\\fP for you.\r\n.sp\r\nYou can also specify \\fB$ pipenv install \\-r path/to/requirements.txt\\fP to import a requirements file.\r\n.sp\r\nIf your requirements file has version numbers pinned, you\\(aqll likely want to edit the new \\fBPipfile\\fP\r\nto remove those, and let \\fBpipenv\\fP keep track of pinning.  If you want to keep the pinned versions\r\nin your \\fBPipfile.lock\\fP for now, run \\fBpipenv lock \\-\\-keep\\-outdated\\fP\\&.  Make sure to\r\n\\fI\\%upgrade\\fP soon!\r\n.SS ☤ Specifying Versions of a Package\r\n.sp\r\nYou can specify versions of a package using the \\fI\\%Semantic Versioning scheme\\fP\r\n(i.e. \\fBmajor.minor.micro\\fP).\r\n.sp\r\nFor example, to install requests you can use:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n$ pipenv install requests~=1.2\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\nPipenv will install version \\fB1.2\\fP and any minor update, but not \\fB2.0\\fP\\&.\r\n.sp\r\nThis will update your \\fBPipfile\\fP to reflect this requirement, automatically.\r\n.sp\r\nIn general, Pipenv uses the same specifier format as pip. However, note that according to \\fI\\%PEP 440\\fP , you can\\(aqt use versions containing a hyphen or a plus sign.\r\n.sp\r\nTo make inclusive or exclusive version comparisons you can use:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n$ pipenv install \"requests>=1.4\"   # will install a version equal or larger than 1.4.0\r\n$ pipenv install \"requests<=2.13\"  # will install a version equal or lower than 2.13.0\r\n$ pipenv install \"requests>2.19\"   # will install 2.19.1 but not 2.19.0\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\n\\fBNOTE:\\fP\r\n.INDENT 0.0\r\n.INDENT 3.5\r\nThe use of double quotes around the package and version specification (i.e. \\fB\"requests>2.19\"\\fP) is highly recommended\r\nto avoid issues with \\fI\\%Input and output redirection\\fP\r\nin Unix\\-based operating systems.\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\nThe use of \\fB~=\\fP is preferred over the \\fB==\\fP identifier as the latter prevents pipenv from updating the packages:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n$ pipenv install \"requests~=2.2\"  # locks the major version of the package (this is equivalent to using ==2.*)\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\nTo avoid installing a specific version you can use the \\fB!=\\fP identifier.\r\n.sp\r\nFor an in depth explanation of the valid identifiers and more complex use cases check \\fI\\%the relevant section of PEP\\-440\\fP\\&.\r\n.SS ☤ Specifying Versions of Python\r\n.sp\r\nTo create a new virtualenv, using a specific version of Python you have installed (and\r\non your \\fBPATH\\fP), use the \\fB\\-\\-python VERSION\\fP flag, like so:\r\n.sp\r\nUse Python 3:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n$ pipenv \\-\\-python 3\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\nUse Python3.6:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n$ pipenv \\-\\-python 3.6\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\nUse Python 2.7.14:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n$ pipenv \\-\\-python 2.7.14\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\nWhen given a Python version, like this, Pipenv will automatically scan your system for a Python that matches that given version.\r\n.sp\r\nIf a \\fBPipfile\\fP hasn\\(aqt been created yet, one will be created for you, that looks like this:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n[[source]]\r\nurl = \"https://pypi.python.org/simple\"\r\nverify_ssl = true\r\n\r\n[dev\\-packages]\r\n\r\n[packages]\r\n\r\n[requires]\r\npython_version = \"3.6\"\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\n\\fBNOTE:\\fP\r\n.INDENT 0.0\r\n.INDENT 3.5\r\nThe inclusion of \\fB[requires] python_version = \"3.6\"\\fP specifies that your application requires this version\r\nof Python, and will be used automatically when running \\fBpipenv install\\fP against this \\fBPipfile\\fP in the future\r\n(e.g. on other machines). If this is not true, feel free to simply remove this section.\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\nIf you don\\(aqt specify a Python version on the command–line, either the \\fB[requires]\\fP \\fBpython_full_version\\fP or \\fBpython_version\\fP will be selected\r\nautomatically, falling back to whatever your system\\(aqs default \\fBpython\\fP installation is, at time of execution.\r\n.SS ☤ Editable Dependencies (e.g. \\fB\\-e .\\fP )\r\n.sp\r\nYou can tell Pipenv to install a path as editable — often this is useful for\r\nthe current working directory when working on packages:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n$ pipenv install \\-\\-dev \\-e .\r\n\r\n$ cat Pipfile\r\n\\&...\r\n[dev\\-packages]\r\n\"e1839a8\" = {path = \".\", editable = true}\r\n\\&...\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\n\\fBNOTE:\\fP\r\n.INDENT 0.0\r\n.INDENT 3.5\r\nAll sub\\-dependencies will get added to the \\fBPipfile.lock\\fP as well. Sub\\-dependencies are \\fBnot\\fP added to the\r\n\\fBPipfile.lock\\fP if you leave the \\fB\\-e\\fP option out.\r\n.UNINDENT\r\n.UNINDENT\r\n.SS ☤ Environment Management with Pipenv\r\n.sp\r\nThe three primary commands you\\(aqll use in managing your pipenv environment are\r\n\\fB$ pipenv install\\fP, \\fB$ pipenv uninstall\\fP, and \\fB$ pipenv lock\\fP\\&.\r\n.SS $ pipenv install\r\n.sp\r\n\\fB$ pipenv install\\fP is used for installing packages into the pipenv virtual environment\r\nand updating your Pipfile.\r\n.sp\r\nAlong with the basic install command, which takes the form:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n$ pipenv install [package names]\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\nThe user can provide these additional parameters:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.INDENT 0.0\r\n.IP \\(bu 2\r\n\\fB\\-\\-two\\fP — Performs the installation in a virtualenv using the system \\fBpython2\\fP link.\r\n.IP \\(bu 2\r\n\\fB\\-\\-three\\fP — Performs the installation in a virtualenv using the system \\fBpython3\\fP link.\r\n.IP \\(bu 2\r\n\\fB\\-\\-python\\fP — Performs the installation in a virtualenv using the provided Python interpreter.\r\n.UNINDENT\r\n.sp\r\n\\fBWARNING:\\fP\r\n.INDENT 0.0\r\n.INDENT 3.5\r\nNone of the above commands should be used together. They are also\r\n\\fBdestructive\\fP and will delete your current virtualenv before replacing\r\nit with an appropriately versioned one.\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\n\\fBNOTE:\\fP\r\n.INDENT 0.0\r\n.INDENT 3.5\r\nThe virtualenv created by Pipenv may be different from what you were expecting.\r\nDangerous characters (i.e. \\fB$\\(ga!*@\"\\fP as well as space, line feed, carriage return,\r\nand tab) are converted to underscores. Additionally, the full path to the current\r\nfolder is encoded into a \"slug value\" and appended to ensure the virtualenv name\r\nis unique.\r\n.UNINDENT\r\n.UNINDENT\r\n.INDENT 0.0\r\n.IP \\(bu 2\r\n\\fB\\-\\-dev\\fP — Install both \\fBdevelop\\fP and \\fBdefault\\fP packages from \\fBPipfile\\fP\\&.\r\n.IP \\(bu 2\r\n\\fB\\-\\-system\\fP — Use the system \\fBpip\\fP command rather than the one from your virtualenv.\r\n.IP \\(bu 2\r\n\\fB\\-\\-deploy\\fP — Make sure the packages are properly locked in Pipfile.lock, and abort if the lock file is out\\-of\\-date.\r\n.IP \\(bu 2\r\n\\fB\\-\\-ignore\\-pipfile\\fP — Ignore the \\fBPipfile\\fP and install from the \\fBPipfile.lock\\fP\\&.\r\n.IP \\(bu 2\r\n\\fB\\-\\-skip\\-lock\\fP — Ignore the \\fBPipfile.lock\\fP and install from the \\fBPipfile\\fP\\&. In addition, do not write out a \\fBPipfile.lock\\fP reflecting changes to the \\fBPipfile\\fP\\&.\r\n.UNINDENT\r\n.UNINDENT\r\n.UNINDENT\r\n.SS $ pipenv uninstall\r\n.sp\r\n\\fB$ pipenv uninstall\\fP supports all of the parameters in \\fI\\%pipenv install\\fP,\r\nas well as two additional options, \\fB\\-\\-all\\fP and \\fB\\-\\-all\\-dev\\fP\\&.\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.INDENT 0.0\r\n.IP \\(bu 2\r\n\\fB\\-\\-all\\fP — This parameter will purge all files from the virtual environment,\r\nbut leave the Pipfile untouched.\r\n.IP \\(bu 2\r\n\\fB\\-\\-all\\-dev\\fP — This parameter will remove all of the development packages from\r\nthe virtual environment, and remove them from the Pipfile.\r\n.UNINDENT\r\n.UNINDENT\r\n.UNINDENT\r\n.SS $ pipenv lock\r\n.sp\r\n\\fB$ pipenv lock\\fP is used to create a \\fBPipfile.lock\\fP, which declares \\fBall\\fP dependencies (and sub\\-dependencies) of your project, their latest available versions, and the current hashes for the downloaded files. This ensures repeatable, and most importantly \\fIdeterministic\\fP, builds.\r\n.SS ☤ About Shell Configuration\r\n.sp\r\nShells are typically misconfigured for subshell use, so \\fB$ pipenv shell \\-\\-fancy\\fP may produce unexpected results. If this is the case, try \\fB$ pipenv shell\\fP, which uses \"compatibility mode\", and will attempt to spawn a subshell despite misconfiguration.\r\n.sp\r\nA proper shell configuration only sets environment variables like \\fBPATH\\fP during a login session, not during every subshell spawn (as they are typically configured to do). In fish, this looks like this:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\nif status \\-\\-is\\-login\r\n    set \\-gx PATH /usr/local/bin $PATH\r\nend\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\nYou should do this for your shell too, in your \\fB~/.profile\\fP or \\fB~/.bashrc\\fP or wherever appropriate.\r\n.sp\r\n\\fBNOTE:\\fP\r\n.INDENT 0.0\r\n.INDENT 3.5\r\nThe shell launched in interactive mode. This means that if your shell reads its configuration from a specific file for interactive mode (e.g. bash by default looks for a \\fB~/.bashrc\\fP configuration file for interactive mode), then you\\(aqll need to modify (or create) this file.\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\nIf you experience issues with \\fB$ pipenv shell\\fP, just check the \\fBPIPENV_SHELL\\fP environment variable, which \\fB$ pipenv shell\\fP will use if available. For detail, see configuration\\-with\\-environment\\-variables\\&.\r\n.SS ☤ A Note about VCS Dependencies\r\n.sp\r\nYou can install packages with pipenv from git and other version control systems using URLs formatted according to the following rule:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n<vcs_type>+<scheme>://<location>/<user_or_organization>/<repository>@<branch_or_tag>#egg=<package_name>\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\nThe only optional section is the \\fB@<branch_or_tag>\\fP section.  When using git over SSH, you may use the shorthand vcs and scheme alias \\fBgit+git@<location>:<user_or_organization>/<repository>@<branch_or_tag>#<package_name>\\fP\\&. Note that this is translated to \\fBgit+ssh://git@<location>\\fP when parsed.\r\n.sp\r\nNote that it is \\fBstrongly recommended\\fP that you install any version\\-controlled dependencies in editable mode, using \\fBpipenv install \\-e\\fP, in order to ensure that dependency resolution can be performed with an up to date copy of the repository each time it is performed, and that it includes all known dependencies.\r\n.sp\r\nBelow is an example usage which installs the git repository located at \\fBhttps://github.com/requests/requests.git\\fP from tag \\fBv2.20.1\\fP as package name \\fBrequests\\fP:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n$ pipenv install \\-e git+https://github.com/requests/requests.git@v2.20.1#egg=requests\r\nCreating a Pipfile for this project...\r\nInstalling \\-e git+https://github.com/requests/requests.git@v2.20.1#egg=requests...\r\n[...snipped...]\r\nAdding \\-e git+https://github.com/requests/requests.git@v2.20.1#egg=requests to Pipfile\\(aqs [packages]...\r\n[...]\r\n\r\n$ cat Pipfile\r\n[packages]\r\nrequests = {git = \"https://github.com/requests/requests.git\", editable = true, ref = \"v2.20.1\"}\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\nValid values for \\fB<vcs_type>\\fP include \\fBgit\\fP, \\fBbzr\\fP, \\fBsvn\\fP, and \\fBhg\\fP\\&.  Valid values for \\fB<scheme>\\fP include \\fBhttp\\fP, \\fBhttps\\fP, \\fBssh\\fP, and \\fBfile\\fP\\&.  In specific cases you also have access to other schemes: \\fBsvn\\fP may be combined with \\fBsvn\\fP as a scheme, and \\fBbzr\\fP can be combined with \\fBsftp\\fP and \\fBlp\\fP\\&.\r\n.sp\r\nYou can read more about pip\\(aqs implementation of VCS support \\fI\\%here\\fP\\&. For more information about other options available when specifying VCS dependencies, please check the \\fI\\%Pipfile spec\\fP\\&.\r\n.SS ☤ Pipfile.lock Security Features\r\n.sp\r\n\\fBPipfile.lock\\fP takes advantage of some great new security improvements in \\fBpip\\fP\\&.\r\nBy default, the \\fBPipfile.lock\\fP will be generated with the sha256 hashes of each downloaded\r\npackage. This will allow \\fBpip\\fP to guarantee you\\(aqre installing what you intend to when\r\non a compromised network, or downloading dependencies from an untrusted PyPI endpoint.\r\n.sp\r\nWe highly recommend approaching deployments with promoting projects from a development\r\nenvironment into production. You can use \\fBpipenv lock\\fP to compile your dependencies on\r\nyour development environment and deploy the compiled \\fBPipfile.lock\\fP to all of your\r\nproduction environments for reproducible builds.\r\n.sp\r\n\\fBNOTE:\\fP\r\n.INDENT 0.0\r\n.INDENT 3.5\r\nIf you\\(aqd like a \\fBrequirements.txt\\fP output of the lockfile, run \\fB$ pipenv lock \\-r\\fP\\&.\r\nThis will include all hashes, however (which is great!). To get a \\fBrequirements.txt\\fP\r\nwithout hashes, use \\fB$ pipenv run pip freeze\\fP\\&.\r\n.UNINDENT\r\n.UNINDENT\r\n.SS Advanced Usage of Pipenv\r\n[image]\r\n.sp\r\nThis document covers some of Pipenv\\(aqs more glorious and advanced features.\r\n.SS ☤ Caveats\r\n.INDENT 0.0\r\n.IP \\(bu 2\r\nDependencies of wheels provided in a \\fBPipfile\\fP will not be captured by \\fB$ pipenv lock\\fP\\&.\r\n.IP \\(bu 2\r\nThere are some known issues with using private indexes, related to hashing. We\\(aqre actively working to solve this problem. You may have great luck with this, however.\r\n.IP \\(bu 2\r\nInstallation is intended to be as deterministic as possible —\\ use the \\fB\\-\\-sequential\\fP flag to increase this, if experiencing issues.\r\n.UNINDENT\r\n.SS ☤ Specifying Package Indexes\r\n.sp\r\nIf you\\(aqd like a specific package to be installed with a specific package index, you can do the following:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n[[source]]\r\nurl = \"https://pypi.org/simple\"\r\nverify_ssl = true\r\nname = \"pypi\"\r\n\r\n[[source]]\r\nurl = \"http://pypi.home.kennethreitz.org/simple\"\r\nverify_ssl = false\r\nname = \"home\"\r\n\r\n[dev\\-packages]\r\n\r\n[packages]\r\nrequests = {version=\"*\", index=\"home\"}\r\nmaya = {version=\"*\", index=\"pypi\"}\r\nrecords = \"*\"\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\nVery fancy.\r\n.SS ☤ Using a PyPI Mirror\r\n.sp\r\nIf you would like to override the default PyPI index URLs with the URL for a PyPI mirror, you can use the following:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n$ pipenv install \\-\\-pypi\\-mirror <mirror_url>\r\n\r\n$ pipenv update \\-\\-pypi\\-mirror <mirror_url>\r\n\r\n$ pipenv sync \\-\\-pypi\\-mirror <mirror_url>\r\n\r\n$ pipenv lock \\-\\-pypi\\-mirror <mirror_url>\r\n\r\n$ pipenv uninstall \\-\\-pypi\\-mirror <mirror_url>\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\nAlternatively, you can set the \\fBPIPENV_PYPI_MIRROR\\fP environment variable.\r\n.SS ☤ Injecting credentials into Pipfiles via environment variables\r\n.sp\r\nPipenv will expand environment variables (if defined) in your Pipfile. Quite\r\nuseful if you need to authenticate to a private PyPI:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n[[source]]\r\nurl = \"https://$USERNAME:${PASSWORD}@mypypi.example.com/simple\"\r\nverify_ssl = true\r\nname = \"pypi\"\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\nLuckily \\- pipenv will hash your Pipfile \\fIbefore\\fP expanding environment\r\nvariables (and, helpfully, will substitute the environment variables again when\r\nyou install from the lock file \\- so no need to commit any secrets! Woo!)\r\n.sp\r\nIf your credentials contain a special character, surround the references to the environment variables with quotation marks. For example, if your password contain a double quotation mark, surround the password variable with single quotation marks. Otherwise, you may get a \\fBValueError, \"No closing quotation\"\\fP error while installing dependencies.\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n[[source]]\r\nurl = \"https://$USERNAME:\\(aq${PASSWORD}\\(aq@mypypi.example.com/simple\"\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.SS ☤ Specifying Basically Anything\r\n.sp\r\nIf you\\(aqd like to specify that a specific package only be installed on certain systems,\r\nyou can use \\fI\\%PEP 508 specifiers\\fP to accomplish this.\r\n.sp\r\nHere\\(aqs an example \\fBPipfile\\fP, which will only install \\fBpywinusb\\fP on Windows systems:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n[[source]]\r\nurl = \"https://pypi.python.org/simple\"\r\nverify_ssl = true\r\nname = \"pypi\"\r\n\r\n[packages]\r\nrequests = \"*\"\r\npywinusb = {version = \"*\", sys_platform = \"== \\(aqwin32\\(aq\"}\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\nVoilà!\r\n.sp\r\nHere\\(aqs a more complex example:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n[[source]]\r\nurl = \"https://pypi.python.org/simple\"\r\nverify_ssl = true\r\n\r\n[packages]\r\nunittest2 = {version = \">=1.0,<3.0\", markers=\"python_version < \\(aq2.7.9\\(aq or (python_version >= \\(aq3.0\\(aq and python_version < \\(aq3.4\\(aq)\"}\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\nMagic. Pure, unadulterated magic.\r\n.SS ☤ Using pipenv for Deployments\r\n.sp\r\nYou may want to use \\fBpipenv\\fP as part of a deployment process.\r\n.sp\r\nYou can enforce that your \\fBPipfile.lock\\fP is up to date using the \\fB\\-\\-deploy\\fP flag:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n$ pipenv install \\-\\-deploy\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\nThis will fail a build if the \\fBPipfile.lock\\fP is out–of–date, instead of generating a new one.\r\n.sp\r\nOr you can install packages exactly as specified in \\fBPipfile.lock\\fP using the \\fBsync\\fP command:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n$ pipenv sync\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\n\\fBNOTE:\\fP\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n\\fBpipenv install \\-\\-ignore\\-pipfile\\fP is nearly equivalent to \\fBpipenv sync\\fP, but \\fBpipenv sync\\fP will \\fInever\\fP attempt to re\\-lock your dependencies as it is considered an atomic operation.  \\fBpipenv install\\fP by default does attempt to re\\-lock unless using the \\fB\\-\\-deploy\\fP flag.\r\n.UNINDENT\r\n.UNINDENT\r\n.SS Deploying System Dependencies\r\n.sp\r\nYou can tell Pipenv to install a Pipfile\\(aqs contents into its parent system with the \\fB\\-\\-system\\fP flag:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n$ pipenv install \\-\\-system\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\nThis is useful for managing the system Python, and deployment infrastructure (e.g. Heroku does this).\r\n.SS ☤ Pipenv and Other Python Distributions\r\n.sp\r\nTo use Pipenv with a third\\-party Python distribution (e.g. Anaconda), you simply provide the path to the Python binary:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n$ pipenv install \\-\\-python=/path/to/python\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\nAnaconda uses Conda to manage packages. To reuse Conda–installed Python packages, use the \\fB\\-\\-site\\-packages\\fP flag:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n$ pipenv \\-\\-python=/path/to/python \\-\\-site\\-packages\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.SS ☤ Generating a \\fBrequirements.txt\\fP\r\n.sp\r\nYou can convert a \\fBPipfile\\fP and \\fBPipfile.lock\\fP into a \\fBrequirements.txt\\fP\r\nfile very easily, and get all the benefits of extras and other goodies we have\r\nincluded.\r\n.sp\r\nLet\\(aqs take this \\fBPipfile\\fP:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n[[source]]\r\nurl = \"https://pypi.python.org/simple\"\r\nverify_ssl = true\r\n\r\n[packages]\r\nrequests = {version=\"*\"}\r\n\r\n[dev\\-packages]\r\npytest = {version=\"*\"}\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\nAnd generate a set of requirements out of it with only the default dependencies:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n$ pipenv lock \\-r\r\nchardet==3.0.4\r\nrequests==2.18.4\r\ncertifi==2017.7.27.1\r\nidna==2.6\r\nurllib3==1.22\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\nAs with other commands, passing \\fB\\-\\-dev\\fP will include both the default and\r\ndevelopment dependencies:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n$ pipenv lock \\-r \\-\\-dev\r\nchardet==3.0.4\r\nrequests==2.18.4\r\ncertifi==2017.7.27.1\r\nidna==2.6\r\nurllib3==1.22\r\npy==1.4.34\r\npytest==3.2.3\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\nFinally, if you wish to generate a requirements file with only the\r\ndevelopment requirements you can do that too, using the \\fB\\-\\-dev\\-only\\fP\r\nflag:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n$ pipenv lock \\-r \\-\\-dev\\-only\r\npy==1.4.34\r\npytest==3.2.3\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\nThe locked requirements are written to stdout, with shell output redirection\r\nused to write them to a file:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n$ pipenv lock \\-r > requirements.txt\r\n$ pipenv lock \\-r \\-\\-dev\\-only > dev\\-requirements.txt\r\n$ cat requirements.txt\r\nchardet==3.0.4\r\nrequests==2.18.4\r\ncertifi==2017.7.27.1\r\nidna==2.6\r\nurllib3==1.22\r\n$ cat dev\\-requirements.txt\r\npy==1.4.34\r\npytest==3.2.3\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.SS ☤ Detection of Security Vulnerabilities\r\n.sp\r\nPipenv includes the \\fI\\%safety\\fP package, and will use it to scan your dependency graph\r\nfor known security vulnerabilities!\r\n.sp\r\nExample:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n$ cat Pipfile\r\n[packages]\r\ndjango = \"==1.10.1\"\r\n\r\n$ pipenv check\r\nChecking PEP 508 requirements…\r\nPassed!\r\nChecking installed package safety…\r\n\r\n33075: django >=1.10,<1.10.3 resolved (1.10.1 installed)!\r\nDjango before 1.8.x before 1.8.16, 1.9.x before 1.9.11, and 1.10.x before 1.10.3, when settings.DEBUG is True, allow remote attackers to conduct DNS rebinding attacks by leveraging failure to validate the HTTP Host header against settings.ALLOWED_HOSTS.\r\n\r\n33076: django >=1.10,<1.10.3 resolved (1.10.1 installed)!\r\nDjango 1.8.x before 1.8.16, 1.9.x before 1.9.11, and 1.10.x before 1.10.3 use a hardcoded password for a temporary database user created when running tests with an Oracle database, which makes it easier for remote attackers to obtain access to the database server by leveraging failure to manually specify a password in the database settings TEST dictionary.\r\n\r\n33300: django >=1.10,<1.10.7 resolved (1.10.1 installed)!\r\nCVE\\-2017\\-7233: Open redirect and possible XSS attack via user\\-supplied numeric redirect URLs\r\n============================================================================================\r\n\r\nDjango relies on user input in some cases  (e.g.\r\n:func:\\(gadjango.contrib.auth.views.login\\(ga and :doc:\\(gai18n </topics/i18n/index>\\(ga)\r\nto redirect the user to an \"on success\" URL. The security check for these\r\nredirects (namely \\(ga\\(gadjango.utils.http.is_safe_url()\\(ga\\(ga) considered some numeric\r\nURLs (e.g. \\(ga\\(gahttp:999999999\\(ga\\(ga) \"safe\" when they shouldn\\(aqt be.\r\n\r\nAlso, if a developer relies on \\(ga\\(gais_safe_url()\\(ga\\(ga to provide safe redirect\r\ntargets and puts such a URL into a link, they could suffer from an XSS attack.\r\n\r\nCVE\\-2017\\-7234: Open redirect vulnerability in \\(ga\\(gadjango.views.static.serve()\\(ga\\(ga\r\n=============================================================================\r\n\r\nA maliciously crafted URL to a Django site using the\r\n:func:\\(ga~django.views.static.serve\\(ga view could redirect to any other domain. The\r\nview no longer does any redirects as they don\\(aqt provide any known, useful\r\nfunctionality.\r\n\r\nNote, however, that this view has always carried a warning that it is not\r\nhardened for production use and should be used only as a development aid.\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\n✨\uD83C\uDF70✨\r\n.sp\r\n\\fBNOTE:\\fP\r\n.INDENT 0.0\r\n.INDENT 3.5\r\nEach month, \\fIPyUp.io\\fP updates the \\fBsafety\\fP database of\r\ninsecure Python packages and \\fI\\%makes it available to the\r\ncommunity for free\\fP\\&. Pipenv\r\nmakes an API call to retrieve those results and use them\r\neach time you run \\fBpipenv check\\fP to show you vulnerable\r\ndependencies.\r\n.sp\r\nFor more up\\-to\\-date vulnerability data, you may also use your own safety\r\nAPI key by setting the environment variable \\fBPIPENV_PYUP_API_KEY\\fP\\&.\r\n.UNINDENT\r\n.UNINDENT\r\n.SS ☤ Community Integrations\r\n.sp\r\nThere are a range of community\\-maintained plugins and extensions available for a range of editors and IDEs, as well as\r\ndifferent products which integrate with Pipenv projects:\r\n.INDENT 0.0\r\n.IP \\(bu 2\r\n\\fI\\%Heroku\\fP (Cloud Hosting)\r\n.IP \\(bu 2\r\n\\fI\\%Platform.sh\\fP (Cloud Hosting)\r\n.IP \\(bu 2\r\n\\fI\\%PyUp\\fP (Security Notification)\r\n.IP \\(bu 2\r\n\\fI\\%Emacs\\fP (Editor Integration)\r\n.IP \\(bu 2\r\n\\fI\\%Fish Shell\\fP (Automatic \\fB$ pipenv shell\\fP!)\r\n.IP \\(bu 2\r\n\\fI\\%VS Code\\fP (Editor Integration)\r\n.IP \\(bu 2\r\n\\fI\\%PyCharm\\fP (Editor Integration)\r\n.UNINDENT\r\n.sp\r\nWorks in progress:\r\n.INDENT 0.0\r\n.IP \\(bu 2\r\n\\fI\\%Sublime Text\\fP (Editor Integration)\r\n.IP \\(bu 2\r\nMysterious upcoming Google Cloud product (Cloud Hosting)\r\n.UNINDENT\r\n.SS ☤ Open a Module in Your Editor\r\n.sp\r\nPipenv allows you to open any Python module that is installed (including ones in your codebase), with the \\fB$ pipenv open\\fP command:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n$ pipenv install \\-e git+https://github.com/kennethreitz/background.git#egg=background\r\nInstalling \\-e git+https://github.com/kennethreitz/background.git#egg=background…\r\n\\&...\r\nUpdated Pipfile.lock!\r\n\r\n$ pipenv open background\r\nOpening \\(aq/Users/kennethreitz/.local/share/virtualenvs/hmm\\-mGOawwm_/src/background/background.py\\(aq in your EDITOR.\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\nThis allows you to easily read the code you\\(aqre consuming, instead of looking it up on GitHub.\r\n.sp\r\n\\fBNOTE:\\fP\r\n.INDENT 0.0\r\n.INDENT 3.5\r\nThe standard \\fBEDITOR\\fP environment variable is used for this. If you\\(aqre using VS Code, for example, you\\(aqll want to \\fBexport EDITOR=code\\fP (if you\\(aqre on macOS you will want to \\fI\\%install the command\\fP on to your \\fBPATH\\fP first).\r\n.UNINDENT\r\n.UNINDENT\r\n.SS ☤ Automatic Python Installation\r\n.sp\r\nIf you have \\fI\\%pyenv\\fP installed and configured, Pipenv will automatically ask you if you want to install a required version of Python if you don\\(aqt already have it available.\r\n.sp\r\nThis is a very fancy feature, and we\\(aqre very proud of it:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n$ cat Pipfile\r\n[[source]]\r\nurl = \"https://pypi.python.org/simple\"\r\nverify_ssl = true\r\n\r\n[dev\\-packages]\r\n\r\n[packages]\r\nrequests = \"*\"\r\n\r\n[requires]\r\npython_version = \"3.6\"\r\n\r\n$ pipenv install\r\nWarning: Python 3.6 was not found on your system…\r\nWould you like us to install latest CPython 3.6 with pyenv? [Y/n]: y\r\nInstalling CPython 3.6.2 with pyenv (this may take a few minutes)…\r\n\\&...\r\nMaking Python installation global…\r\nCreating a virtualenv for this project…\r\nUsing /Users/kennethreitz/.pyenv/shims/python3 to create virtualenv…\r\n\\&...\r\nNo package provided, installing all dependencies.\r\n\\&...\r\nInstalling dependencies from Pipfile.lock…\r\n\uD83D\uDC0D   ❒❒❒❒❒❒❒❒❒❒❒❒❒❒❒❒❒❒❒❒❒❒❒❒❒❒❒❒❒❒❒❒ 5/5 — 00:00:03\r\nTo activate this project\\(aqs virtualenv, run the following:\r\n $ pipenv shell\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\nPipenv automatically honors both the \\fBpython_full_version\\fP and \\fBpython_version\\fP \\fI\\%PEP 508\\fP specifiers.\r\n.sp\r\n\uD83D\uDCAB✨\uD83C\uDF70✨\uD83D\uDCAB\r\n.SS ☤ Automatic Loading of \\fB\\&.env\\fP\r\n.sp\r\nIf a \\fB\\&.env\\fP file is present in your project, \\fB$ pipenv shell\\fP and \\fB$ pipenv run\\fP will automatically load it, for you:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n$ cat .env\r\nHELLO=WORLD⏎\r\n\r\n$ pipenv run python\r\nLoading .env environment variables…\r\nPython 2.7.13 (default, Jul 18 2017, 09:17:00)\r\n[GCC 4.2.1 Compatible Apple LLVM 8.1.0 (clang\\-802.0.42)] on darwin\r\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\r\n>>> import os\r\n>>> os.environ[\\(aqHELLO\\(aq]\r\n\\(aqWORLD\\(aq\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\nShell like variable expansion is available in \\fB\\&.env\\fP files using \\fI${VARNAME}\\fP syntax.:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n$ cat .env\r\nCONFIG_PATH=${HOME}/.config/foo\r\n\r\n$ pipenv run python\r\nLoading .env environment variables…\r\nPython 3.7.6 (default, Dec 19 2019, 22:52:49)\r\n[GCC 9.2.1 20190827 (Red Hat 9.2.1\\-1)] on linux\r\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\r\n>>> import os\r\n>>> os.environ[\\(aqCONFIG_PATH\\(aq]\r\n\\(aq/home/kennethreitz/.config/foo\\(aq\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\nThis is very useful for keeping production credentials out of your codebase.\r\nWe do not recommend committing \\fB\\&.env\\fP files into source control!\r\n.sp\r\nIf your \\fB\\&.env\\fP file is located in a different path or has a different name you may set the \\fBPIPENV_DOTENV_LOCATION\\fP environment variable:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n$ PIPENV_DOTENV_LOCATION=/path/to/.env pipenv shell\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\nTo prevent pipenv from loading the \\fB\\&.env\\fP file, set the \\fBPIPENV_DONT_LOAD_ENV\\fP environment variable:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n$ PIPENV_DONT_LOAD_ENV=1 pipenv shell\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\nSee \\fI\\%theskumar/python\\-dotenv\\fP for more information on \\fB\\&.env\\fP files.\r\n.SS ☤ Custom Script Shortcuts\r\n.sp\r\nPipenv supports creating custom shortcuts in the (optional) \\fB[scripts]\\fP section of your Pipfile.\r\n.sp\r\nYou can then run \\fBpipenv run <shortcut name>\\fP in your terminal to run the command in the\r\ncontext of your pipenv virtual environment even if you have not activated the pipenv shell first.\r\n.sp\r\nFor example, in your Pipfile:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n[scripts]\r\nprintspam = \"python \\-c \\e\"print(\\(aqI am a silly example, no one would need to do this\\(aq)\\e\"\"\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\nAnd then in your terminal:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n$ pipenv run printspam\r\nI am a silly example, no one would need to do this\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\nCommands that expect arguments will also work.\r\nFor example:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n[scripts]\r\nechospam = \"echo I am really a very silly example\"\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n$ pipenv run echospam \"indeed\"\r\nI am really a very silly example indeed\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.SS ☤ Support for Environment Variables\r\n.sp\r\nPipenv supports the usage of environment variables in place of authentication fragments\r\nin your Pipfile. These will only be parsed if they are present in the \\fB[[source]]\\fP\r\nsection. For example:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n[[source]]\r\nurl = \"https://${PYPI_USERNAME}:${PYPI_PASSWORD}@my_private_repo.example.com/simple\"\r\nverify_ssl = true\r\nname = \"pypi\"\r\n\r\n[dev\\-packages]\r\n\r\n[packages]\r\nrequests = {version=\"*\", index=\"home\"}\r\nmaya = {version=\"*\", index=\"pypi\"}\r\nrecords = \"*\"\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\nEnvironment variables may be specified as \\fB${MY_ENVAR}\\fP or \\fB$MY_ENVAR\\fP\\&.\r\n.sp\r\nOn Windows, \\fB%MY_ENVAR%\\fP is supported in addition to \\fB${MY_ENVAR}\\fP or \\fB$MY_ENVAR\\fP\\&.\r\n.SS ☤ Configuration With Environment Variables\r\n.sp\r\nPipenv comes with a handful of options that can be enabled via shell environment\r\nvariables. To activate them, simply create the variable in your shell and pipenv\r\nwill detect it.\r\n.INDENT 0.0\r\n.TP\r\n.B pipenv.environments.PIPENV_CACHE_DIR = \\(aq/home/techalchemy/.cache/pipenv\\(aq\r\nLocation for Pipenv to store it\\(aqs package cache.\r\n.sp\r\nDefault is to use appdir\\(aqs user cache directory.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B pipenv.environments.PIPENV_COLORBLIND = False\r\nIf set, disable terminal colors.\r\n.sp\r\nSome people don\\(aqt like colors in their terminals, for some reason. Default is\r\nto show colors.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B pipenv.environments.PIPENV_DEFAULT_PYTHON_VERSION = \\(aq3.8\\(aq\r\nUse this Python version when creating new virtual environments by default.\r\n.sp\r\nThis can be set to a version string, e.g. \\fB3.6\\fP, or a path. Default is to use\r\nwhatever Python Pipenv is installed under (i.e. \\fBsys.executable\\fP). Command\r\nline flags (e.g. \\fB\\-\\-python\\fP, \\fB\\-\\-three\\fP, and \\fB\\-\\-two\\fP) are prioritized over\r\nthis configuration.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B pipenv.environments.PIPENV_DONT_LOAD_ENV = False\r\nIf set, Pipenv does not load the \\fB\\&.env\\fP file.\r\n.sp\r\nDefault is to load \\fB\\&.env\\fP for \\fBrun\\fP and \\fBshell\\fP commands.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B pipenv.environments.PIPENV_DONT_USE_ASDF = False\r\nIf set, Pipenv does not attempt to install Python with asdf.\r\n.sp\r\nDefault is to install Python automatically via asdf when needed, if possible.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B pipenv.environments.PIPENV_DONT_USE_PYENV = False\r\nIf set, Pipenv does not attempt to install Python with pyenv.\r\n.sp\r\nDefault is to install Python automatically via pyenv when needed, if possible.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B pipenv.environments.PIPENV_DOTENV_LOCATION = None\r\nIf set, Pipenv loads the \\fB\\&.env\\fP file at the specified location.\r\n.sp\r\nDefault is to load \\fB\\&.env\\fP from the project root, if found.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B pipenv.environments.PIPENV_EMULATOR = \\(aq\\(aq\r\nIf set, the terminal emulator\\(aqs name for \\fBpipenv shell\\fP to use.\r\n.sp\r\nDefault is to detect emulators automatically. This should be set if your\r\nemulator, e.g. Cmder, cannot be detected correctly.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B pipenv.environments.PIPENV_HIDE_EMOJIS = False\r\nDisable emojis in output.\r\n.sp\r\nDefault is to show emojis. This is automatically set on Windows.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B pipenv.environments.PIPENV_IGNORE_VIRTUALENVS = False\r\nIf set, Pipenv will always assign a virtual environment for this project.\r\n.sp\r\nBy default, Pipenv tries to detect whether it is run inside a virtual\r\nenvironment, and reuses it if possible. This is usually the desired behavior,\r\nand enables the user to use any user\\-built environments with Pipenv.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B pipenv.environments.PIPENV_INSTALL_TIMEOUT = 900\r\nMax number of seconds to wait for package installation.\r\n.sp\r\nDefaults to 900 (15 minutes), a very long arbitrary time.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B pipenv.environments.PIPENV_MAX_DEPTH = 4\r\nMaximum number of directories to recursively search for a Pipfile.\r\n.sp\r\nDefault is 3. See also \\fBPIPENV_NO_INHERIT\\fP\\&.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B pipenv.environments.PIPENV_MAX_RETRIES = 0\r\nSpecify how many retries Pipenv should attempt for network requests.\r\n.sp\r\nDefault is 0. Automatically set to 1 on CI environments for robust testing.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B pipenv.environments.PIPENV_MAX_ROUNDS = 16\r\nTells Pipenv how many rounds of resolving to do for Pip\\-Tools.\r\n.sp\r\nDefault is 16, an arbitrary number that works most of the time.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B pipenv.environments.PIPENV_MAX_SUBPROCESS = 8\r\nHow many subprocesses should Pipenv use when installing.\r\n.sp\r\nDefault is 16, an arbitrary number that seems to work.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B pipenv.environments.PIPENV_NOSPIN = False\r\nIf set, disable terminal spinner.\r\n.sp\r\nThis can make the logs cleaner. Automatically set on Windows, and in CI\r\nenvironments.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B pipenv.environments.PIPENV_NO_INHERIT = False\r\nTell Pipenv not to inherit parent directories.\r\n.sp\r\nThis is useful for deployment to avoid using the wrong current directory.\r\nOverwrites \\fBPIPENV_MAX_DEPTH\\fP\\&.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B pipenv.environments.PIPENV_PIPFILE = None\r\nIf set, this specifies a custom Pipfile location.\r\n.sp\r\nWhen running pipenv from a location other than the same directory where the\r\nPipfile is located, instruct pipenv to find the Pipfile in the location\r\nspecified by this environment variable.\r\n.sp\r\nDefault is to find Pipfile automatically in the current and parent directories.\r\nSee also \\fBPIPENV_MAX_DEPTH\\fP\\&.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B pipenv.environments.PIPENV_PYPI_MIRROR = None\r\nIf set, tells pipenv to override PyPI index urls with a mirror.\r\n.sp\r\nDefault is to not mirror PyPI, i.e. use the real one, pypi.org. The\r\n\\fB\\-\\-pypi\\-mirror\\fP command line flag overwrites this.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B pipenv.environments.PIPENV_RESOLVE_VCS = True\r\nTells Pipenv whether to resolve all VCS dependencies in full.\r\n.sp\r\nAs of Pipenv 2018.11.26, only editable VCS dependencies were resolved in full.\r\nTo retain this behavior and avoid handling any conflicts that arise from the new\r\napproach, you may set this to \\(aq0\\(aq, \\(aqoff\\(aq, or \\(aqfalse\\(aq.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B pipenv.environments.PIPENV_SHELL = \\(aq/usr/bin/fish\\(aq\r\nAn absolute path to the preferred shell for \\fBpipenv shell\\fP\\&.\r\n.sp\r\nDefault is to detect automatically what shell is currently in use.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B pipenv.environments.PIPENV_SHELL_FANCY = False\r\nIf set, always use fancy mode when invoking \\fBpipenv shell\\fP\\&.\r\n.sp\r\nDefault is to use the compatibility shell if possible.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B pipenv.environments.PIPENV_SKIP_LOCK = False\r\nIf set, Pipenv won\\(aqt lock dependencies automatically.\r\n.sp\r\nThis might be desirable if a project has large number of dependencies,\r\nbecause locking is an inherently slow operation.\r\n.sp\r\nDefault is to lock dependencies and update \\fBPipfile.lock\\fP on each run.\r\n.sp\r\nNOTE: This only affects the \\fBinstall\\fP and \\fBuninstall\\fP commands.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B pipenv.environments.PIPENV_SPINNER = \\(aqdots\\(aq\r\nSets the default spinner type.\r\n.sp\r\nSpinners are identical to the \\fBnode.js\\fP spinners and can be found at\r\n\\fI\\%https://github.com/sindresorhus/cli\\-spinners\\fP\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B pipenv.environments.PIPENV_TIMEOUT = 120\r\nMax number of seconds Pipenv will wait for virtualenv creation to complete.\r\n.sp\r\nDefault is 120 seconds, an arbitrary number that seems to work.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B pipenv.environments.PIPENV_VENV_IN_PROJECT = False\r\nIf set, creates \\fB\\&.venv\\fP in your project directory.\r\n.sp\r\nDefault is to create new virtual environments in a global location.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B pipenv.environments.PIPENV_YES = False\r\nIf set, Pipenv automatically assumes \"yes\" at all prompts.\r\n.sp\r\nDefault is to prompt the user for an answer if the current command line session\r\nif interactive.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B pipenv.environments.PIP_EXISTS_ACTION = \\(aqw\\(aq\r\nSpecifies the value for pip\\(aqs \\-\\-exists\\-action option\r\n.sp\r\nDefaults to \\fB(w)ipe\\fP\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B pipenv.environments.env_to_bool(val)\r\nConvert \\fBval\\fP to boolean, returning True if truthy or False if falsey\r\n.INDENT 7.0\r\n.TP\r\n.B Parameters\r\n\\fBval\\fP (\\fIAny\\fP) \\-\\- The value to convert\r\n.TP\r\n.B Returns\r\nFalse if Falsey, True if truthy\r\n.TP\r\n.B Return type\r\nbool\r\n.UNINDENT\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B pipenv.environments.get_from_env(arg, prefix=\\(aqPIPENV\\(aq, check_for_negation=True)\r\nCheck the environment for a variable, returning its truthy or stringified value\r\n.sp\r\nFor example, setting \\fBPIPENV_NO_RESOLVE_VCS=1\\fP would mean that\r\n\\fBget_from_env(\"RESOLVE_VCS\", prefix=\"PIPENV\")\\fP would return \\fBFalse\\fP\\&.\r\n.INDENT 7.0\r\n.TP\r\n.B Parameters\r\n.INDENT 7.0\r\n.IP \\(bu 2\r\n\\fBarg\\fP (\\fIstr\\fP) \\-\\- The name of the variable to look for\r\n.IP \\(bu 2\r\n\\fBprefix\\fP (\\fIstr\\fP) \\-\\- The prefix to attach to the variable, defaults to \"PIPENV\"\r\n.IP \\(bu 2\r\n\\fBcheck_for_negation\\fP (\\fIbool\\fP) \\-\\- Whether to check for \\fB<PREFIX>_NO_<arg>\\fP, defaults\r\nto True\r\n.UNINDENT\r\n.TP\r\n.B Returns\r\nThe value from the environment if available\r\n.TP\r\n.B Return type\r\nOptional[Union[str, bool]]\r\n.UNINDENT\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B pipenv.environments.is_in_virtualenv()\r\nCheck virtualenv membership dynamically\r\n.INDENT 7.0\r\n.TP\r\n.B Returns\r\nTrue or false depending on whether we are in a regular virtualenv or not\r\n.TP\r\n.B Return type\r\nbool\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\nIf you\\(aqd like to set these environment variables on a per\\-project basis, I recommend utilizing the fantastic \\fI\\%direnv\\fP project, in order to do so.\r\n.sp\r\nAlso note that \\fI\\%pip itself supports environment variables\\fP, if you need additional customization.\r\n.sp\r\nFor example:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n$ PIP_INSTALL_OPTION=\"\\-\\- \\-DCMAKE_BUILD_TYPE=Release\" pipenv install \\-e .\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.SS ☤ Custom Virtual Environment Location\r\n.sp\r\nPipenv automatically honors the \\fBWORKON_HOME\\fP environment variable, if you\r\nhave it set —\\ so you can tell pipenv to store your virtual environments\r\nwherever you want, e.g.:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\nexport WORKON_HOME=~/.venvs\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\nIn addition, you can also have Pipenv stick the virtualenv in \\fBproject/.venv\\fP by setting the \\fBPIPENV_VENV_IN_PROJECT\\fP environment variable.\r\n.SS ☤ Testing Projects\r\n.sp\r\nPipenv is being used in projects like \\fI\\%Requests\\fP for declaring development dependencies and running the test suite.\r\n.sp\r\nWe have currently tested deployments with both \\fI\\%Travis\\-CI\\fP and \\fI\\%tox\\fP with success.\r\n.SS Travis CI\r\n.sp\r\nAn example Travis CI setup can be found in \\fI\\%Requests\\fP\\&. The project uses a Makefile to\r\ndefine common functions such as its \\fBinit\\fP and \\fBtests\\fP commands. Here is\r\na stripped down example \\fB\\&.travis.yml\\fP:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\nlanguage: python\r\npython:\r\n    \\- \"2.6\"\r\n    \\- \"2.7\"\r\n    \\- \"3.3\"\r\n    \\- \"3.4\"\r\n    \\- \"3.5\"\r\n    \\- \"3.6\"\r\n    \\- \"3.7\\-dev\"\r\n\r\n# command to install dependencies\r\ninstall: \"make\"\r\n\r\n# command to run tests\r\nscript:\r\n    \\- make test\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\nand the corresponding Makefile:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\ninit:\r\n    pip install pipenv\r\n    pipenv install \\-\\-dev\r\n\r\ntest:\r\n    pipenv run pytest tests\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.SS Tox Automation Project\r\n.sp\r\nAlternatively, you can configure a \\fBtox.ini\\fP like the one below for both local\r\nand external testing:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n[tox]\r\nenvlist = flake8\\-py3, py26, py27, py33, py34, py35, py36, pypy\r\n\r\n[testenv]\r\ndeps = pipenv\r\ncommands=\r\n    pipenv install \\-\\-dev\r\n    pipenv run pytest tests\r\n\r\n[testenv:flake8\\-py3]\r\nbasepython = python3.4\r\ncommands=\r\n    pipenv install \\-\\-dev\r\n    pipenv run flake8 \\-\\-version\r\n    pipenv run flake8 setup.py docs project test\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\nPipenv will automatically use the virtualenv provided by \\fBtox\\fP\\&. If \\fBpipenv install \\-\\-dev\\fP installs e.g. \\fBpytest\\fP, then installed command \\fBpytest\\fP will be present in given virtualenv and can be called directly by \\fBpytest tests\\fP instead of \\fBpipenv run pytest tests\\fP\\&.\r\n.sp\r\nYou might also want to add \\fB\\-\\-ignore\\-pipfile\\fP to \\fBpipenv install\\fP, as to\r\nnot accidentally modify the lock\\-file on each test run. This causes Pipenv\r\nto ignore changes to the \\fBPipfile\\fP and (more importantly) prevents it from\r\nadding the current environment to \\fBPipfile.lock\\fP\\&. This might be important as\r\nthe current environment (i.e. the virtualenv provisioned by tox) will usually\r\ncontain the current project (which may or may not be desired) and additional\r\ndependencies from \\fBtox\\fP\\(aqs \\fBdeps\\fP directive. The initial provisioning may\r\nalternatively be disabled by adding \\fBskip_install = True\\fP to tox.ini.\r\n.sp\r\nThis method requires you to be explicit about updating the lock\\-file, which is\r\nprobably a good idea in any case.\r\n.sp\r\nA 3rd party plugin, \\fI\\%tox\\-pipenv\\fP is also available to use Pipenv natively with tox.\r\n.SS ☤ Shell Completion\r\n.sp\r\nTo enable completion in fish, add this to your configuration:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\neval (pipenv \\-\\-completion)\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\nAlternatively, with bash or zsh, add this to your configuration:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\neval \"$(pipenv \\-\\-completion)\"\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\nMagic shell completions are now enabled!\r\n.sp\r\n✨\uD83C\uDF70✨\r\n.SS ☤ Working with Platform\\-Provided Python Components\r\n.sp\r\nIt\\(aqs reasonably common for platform specific Python bindings for\r\noperating system interfaces to only be available through the system\r\npackage manager, and hence unavailable for installation into virtual\r\nenvironments with \\fIpip\\fP\\&. In these cases, the virtual environment can\r\nbe created with access to the system \\fIsite\\-packages\\fP directory:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n$ pipenv \\-\\-three \\-\\-site\\-packages\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\nTo ensure that all \\fIpip\\fP\\-installable components actually are installed\r\ninto the virtual environment and system packages are only used for\r\ninterfaces that don\\(aqt participate in Python\\-level dependency resolution\r\nat all, use the \\fIPIP_IGNORE_INSTALLED\\fP setting:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n$ PIP_IGNORE_INSTALLED=1 pipenv install \\-\\-dev\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.SS ☤ Pipfile vs setup.py\r\n.sp\r\nThere is a subtle but very important distinction to be made between \\fBapplications\\fP and \\fBlibraries\\fP\\&. This is a very common source of confusion in the Python community.\r\n.sp\r\nLibraries provide reusable functionality to other libraries and applications (let\\(aqs use the umbrella term \\fBprojects\\fP here). They are required to work alongside other libraries, all with their own set of sub\\-dependencies. They define \\fBabstract dependencies\\fP\\&. To avoid version conflicts in sub\\-dependencies of different libraries within a project, libraries should never ever pin dependency versions. Although they may specify lower or (less frequently) upper bounds, if they rely on some specific feature/fix/bug. Library dependencies are specified via \\fBinstall_requires\\fP in \\fBsetup.py\\fP\\&.\r\n.sp\r\nLibraries are ultimately meant to be used in some \\fBapplication\\fP\\&. Applications are different in that they usually are not depended on by other projects. They are meant to be deployed into some specific environment and only then should the exact versions of all their dependencies and sub\\-dependencies be made concrete. To make this process easier is currently the main goal of Pipenv.\r\n.sp\r\nTo summarize:\r\n.INDENT 0.0\r\n.IP \\(bu 2\r\nFor libraries, define \\fBabstract dependencies\\fP via \\fBinstall_requires\\fP in \\fBsetup.py\\fP\\&. The decision of which version exactly to be installed and where to obtain that dependency is not yours to make!\r\n.IP \\(bu 2\r\nFor applications, define \\fBdependencies and where to get them\\fP in the \\fIPipfile\\fP and use this file to update the set of \\fBconcrete dependencies\\fP in \\fBPipfile.lock\\fP\\&. This file defines a specific idempotent environment that is known to work for your project. The \\fBPipfile.lock\\fP is your source of truth. The \\fBPipfile\\fP is a convenience for you to create that lock\\-file, in that it allows you to still remain somewhat vague about the exact version of a dependency to be used. Pipenv is there to help you define a working conflict\\-free set of specific dependency\\-versions, which would otherwise be a very tedious task.\r\n.IP \\(bu 2\r\nOf course, \\fBPipfile\\fP and Pipenv are still useful for library developers, as they can be used to define a development or test environment.\r\n.IP \\(bu 2\r\nAnd, of course, there are projects for which the distinction between library and application isn\\(aqt that clear. In that case, use \\fBinstall_requires\\fP alongside Pipenv and \\fBPipfile\\fP\\&.\r\n.UNINDENT\r\n.sp\r\nYou can also do this:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n$ pipenv install \\-e .\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\nThis will tell Pipenv to lock all your \\fBsetup.py\\fP–declared dependencies.\r\n.SS ☤ Changing Pipenv\\(aqs Cache Location\r\n.sp\r\nYou can force Pipenv to use a different cache location by setting the environment variable \\fBPIPENV_CACHE_DIR\\fP to the location you wish. This is useful in the same situations that you would change \\fBPIP_CACHE_DIR\\fP to a different directory.\r\n.SS ☤ Changing Default Python Versions\r\n.sp\r\nBy default, Pipenv will initialize a project using whatever version of python the python3 is. Besides starting a project with the \\fB\\-\\-three\\fP or \\fB\\-\\-two\\fP flags, you can also use \\fBPIPENV_DEFAULT_PYTHON_VERSION\\fP to specify what version to use when starting a project when \\fB\\-\\-three\\fP or \\fB\\-\\-two\\fP aren\\(aqt used.\r\n.SS Pipenv CLI Reference\r\n.SS pipenv\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\npipenv [OPTIONS] COMMAND [ARGS]...\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\nOptions.INDENT 0.0\r\n.TP\r\n.B \\-\\-where\r\nOutput project home information.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-venv\r\nOutput virtualenv information.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-py\r\nOutput Python interpreter information.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-envs\r\nOutput Environment Variable options.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-rm\r\nRemove the virtualenv.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-bare\r\nMinimal output.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-completion\r\nOutput completion (to be executed by the shell).\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-man\r\nDisplay manpage.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-support\r\nOutput diagnostic information for use in GitHub issues.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-site\\-packages, \\-\\-no\\-site\\-packages\r\nEnable site\\-packages for the virtualenv.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-python <python>\r\nSpecify which version of Python virtualenv should use.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-three, \\-\\-two\r\nUse Python 3/2 when creating virtualenv.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-clear\r\nClears caches (pipenv, pip, and pip\\-tools).\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-v, \\-\\-verbose\r\nVerbose mode.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-pypi\\-mirror <pypi_mirror>\r\nSpecify a PyPI mirror.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-version\r\nShow the version and exit.\r\n.UNINDENT\r\n.SS check\r\n.sp\r\nChecks for PyUp Safety security vulnerabilities and against PEP 508 markers provided in Pipfile.\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\npipenv check [OPTIONS] [ARGS]...\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\nOptions.INDENT 0.0\r\n.TP\r\n.B \\-\\-unused <unused>\r\nGiven a code path, show potentially unused dependencies.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-db <db>\r\nPath to a local PyUp Safety vulnerabilities database. Default: ENV PIPENV_SAFETY_DB or None.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-i, \\-\\-ignore <ignore>\r\nIgnore specified vulnerability during PyUp Safety checks.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-output <output>\r\nTranslates to \\-\\-json, \\-\\-full\\-report or \\-\\-bare from PyUp Safety check\r\n.INDENT 7.0\r\n.TP\r\n.B Options\r\ndefault|json|full\\-report|bare\r\n.UNINDENT\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-key <key>\r\nSafety API key from PyUp.io for scanning dependencies against a live vulnerabilities database. Leave blank for scanning against a database that only updates once a month.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-quiet\r\nQuiet standard output, except vulnerability report.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-python <python>\r\nSpecify which version of Python virtualenv should use.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-three, \\-\\-two\r\nUse Python 3/2 when creating virtualenv.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-clear\r\nClears caches (pipenv, pip, and pip\\-tools).\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-v, \\-\\-verbose\r\nVerbose mode.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-pypi\\-mirror <pypi_mirror>\r\nSpecify a PyPI mirror.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-system\r\nSystem pip management.\r\n.UNINDENT\r\nArguments.INDENT 0.0\r\n.TP\r\n.B ARGS\r\nOptional argument(s)\r\n.UNINDENT\r\n.SS clean\r\n.sp\r\nUninstalls all packages not specified in Pipfile.lock.\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\npipenv clean [OPTIONS]\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\nOptions.INDENT 0.0\r\n.TP\r\n.B \\-\\-bare\r\nMinimal output.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-dry\\-run\r\nJust output unneeded packages.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-v, \\-\\-verbose\r\nVerbose mode.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-three, \\-\\-two\r\nUse Python 3/2 when creating virtualenv.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-python <python>\r\nSpecify which version of Python virtualenv should use.\r\n.UNINDENT\r\n.SS graph\r\n.sp\r\nDisplays currently\\-installed dependency graph information.\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\npipenv graph [OPTIONS]\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\nOptions.INDENT 0.0\r\n.TP\r\n.B \\-\\-bare\r\nMinimal output.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-json\r\nOutput JSON.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-json\\-tree\r\nOutput JSON in nested tree.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-reverse\r\nReversed dependency graph.\r\n.UNINDENT\r\n.SS install\r\n.sp\r\nInstalls provided packages and adds them to Pipfile, or (if no packages are given), installs all packages from Pipfile.\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\npipenv install [OPTIONS] [PACKAGES]...\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\nOptions.INDENT 0.0\r\n.TP\r\n.B \\-\\-system\r\nSystem pip management.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-c, \\-\\-code <code>\r\nInstall packages automatically discovered from import statements.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-deploy\r\nAbort if the Pipfile.lock is out\\-of\\-date, or Python version is wrong.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-site\\-packages, \\-\\-no\\-site\\-packages\r\nEnable site\\-packages for the virtualenv.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-skip\\-lock\r\nSkip locking mechanisms and use the Pipfile instead during operation.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-e, \\-\\-editable <editable>\r\nAn editable Python package URL or path, often to a VCS repository.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-ignore\\-pipfile\r\nIgnore Pipfile when installing, using the Pipfile.lock.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-selective\\-upgrade\r\nUpdate specified packages.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-r, \\-\\-requirements <requirements>\r\nImport a requirements.txt file.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-extra\\-index\\-url <extra_index_url>\r\nURLs to the extra PyPI compatible indexes to query for package look\\-ups.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-i, \\-\\-index <index>\r\nTarget PyPI\\-compatible package index url.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-sequential\r\nInstall dependencies one\\-at\\-a\\-time, instead of concurrently.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-d, \\-\\-dev\r\nInstall both develop and default packages\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-keep\\-outdated\r\nKeep out\\-dated dependencies from being updated in Pipfile.lock.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-pre\r\nAllow pre\\-releases.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-python <python>\r\nSpecify which version of Python virtualenv should use.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-three, \\-\\-two\r\nUse Python 3/2 when creating virtualenv.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-clear\r\nClears caches (pipenv, pip, and pip\\-tools).\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-v, \\-\\-verbose\r\nVerbose mode.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-pypi\\-mirror <pypi_mirror>\r\nSpecify a PyPI mirror.\r\n.UNINDENT\r\nArguments.INDENT 0.0\r\n.TP\r\n.B PACKAGES\r\nOptional argument(s)\r\n.UNINDENT\r\nEnvironment variables.INDENT 0.0\r\n.TP\r\n.B PIPENV_SKIP_LOCK\r\n.INDENT 7.0\r\n.INDENT 3.5\r\nProvide a default for \\fI\\%\\-\\-skip\\-lock\\fP\r\n.UNINDENT\r\n.UNINDENT\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B PIP_EXTRA_INDEX_URL\r\n.INDENT 7.0\r\n.INDENT 3.5\r\nProvide a default for \\fI\\%\\-\\-extra\\-index\\-url\\fP\r\n.UNINDENT\r\n.UNINDENT\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B PIP_INDEX_URL\r\n.INDENT 7.0\r\n.INDENT 3.5\r\nProvide a default for \\fI\\%\\-i\\fP\r\n.UNINDENT\r\n.UNINDENT\r\n.UNINDENT\r\n.SS lock\r\n.sp\r\nGenerates Pipfile.lock.\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\npipenv lock [OPTIONS]\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\nOptions.INDENT 0.0\r\n.TP\r\n.B \\-\\-dev\\-only\r\nEmit development dependencies \\fIonly\\fP (overrides \\-\\-dev)\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-r, \\-\\-requirements\r\nGenerate output in requirements.txt format.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-d, \\-\\-dev\r\nGenerate both develop and default requirements\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-keep\\-outdated\r\nKeep out\\-dated dependencies from being updated in Pipfile.lock.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-pre\r\nAllow pre\\-releases.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-python <python>\r\nSpecify which version of Python virtualenv should use.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-three, \\-\\-two\r\nUse Python 3/2 when creating virtualenv.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-clear\r\nClears caches (pipenv, pip, and pip\\-tools).\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-v, \\-\\-verbose\r\nVerbose mode.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-pypi\\-mirror <pypi_mirror>\r\nSpecify a PyPI mirror.\r\n.UNINDENT\r\n.SS open\r\n.sp\r\nView a given module in your editor.\r\n.sp\r\nThis uses the EDITOR environment variable. You can temporarily override it,\r\nfor example:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\nEDITOR=atom pipenv open requests\r\n.UNINDENT\r\n.UNINDENT\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\npipenv open [OPTIONS] MODULE\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\nOptions.INDENT 0.0\r\n.TP\r\n.B \\-\\-python <python>\r\nSpecify which version of Python virtualenv should use.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-three, \\-\\-two\r\nUse Python 3/2 when creating virtualenv.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-clear\r\nClears caches (pipenv, pip, and pip\\-tools).\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-v, \\-\\-verbose\r\nVerbose mode.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-pypi\\-mirror <pypi_mirror>\r\nSpecify a PyPI mirror.\r\n.UNINDENT\r\nArguments.INDENT 0.0\r\n.TP\r\n.B MODULE\r\nRequired argument\r\n.UNINDENT\r\n.SS run\r\n.sp\r\nSpawns a command installed into the virtualenv.\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\npipenv run [OPTIONS] COMMAND [ARGS]...\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\nOptions.INDENT 0.0\r\n.TP\r\n.B \\-\\-python <python>\r\nSpecify which version of Python virtualenv should use.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-three, \\-\\-two\r\nUse Python 3/2 when creating virtualenv.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-clear\r\nClears caches (pipenv, pip, and pip\\-tools).\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-v, \\-\\-verbose\r\nVerbose mode.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-pypi\\-mirror <pypi_mirror>\r\nSpecify a PyPI mirror.\r\n.UNINDENT\r\nArguments.INDENT 0.0\r\n.TP\r\n.B COMMAND\r\nRequired argument\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B ARGS\r\nOptional argument(s)\r\n.UNINDENT\r\n.SS shell\r\n.sp\r\nSpawns a shell within the virtualenv.\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\npipenv shell [OPTIONS] [SHELL_ARGS]...\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\nOptions.INDENT 0.0\r\n.TP\r\n.B \\-\\-fancy\r\nRun in shell in fancy mode. Make sure the shell have no path manipulating scripts. Run $pipenv shell for issues with compatibility mode.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-anyway\r\nAlways spawn a sub\\-shell, even if one is already spawned.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-pypi\\-mirror <pypi_mirror>\r\nSpecify a PyPI mirror.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-three, \\-\\-two\r\nUse Python 3/2 when creating virtualenv.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-python <python>\r\nSpecify which version of Python virtualenv should use.\r\n.UNINDENT\r\nArguments.INDENT 0.0\r\n.TP\r\n.B SHELL_ARGS\r\nOptional argument(s)\r\n.UNINDENT\r\n.SS sync\r\n.sp\r\nInstalls all packages specified in Pipfile.lock.\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\npipenv sync [OPTIONS]\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\nOptions.INDENT 0.0\r\n.TP\r\n.B \\-\\-bare\r\nMinimal output.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-sequential\r\nInstall dependencies one\\-at\\-a\\-time, instead of concurrently.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-d, \\-\\-dev\r\nInstall both develop and default packages\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-keep\\-outdated\r\nKeep out\\-dated dependencies from being updated in Pipfile.lock.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-pre\r\nAllow pre\\-releases.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-python <python>\r\nSpecify which version of Python virtualenv should use.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-three, \\-\\-two\r\nUse Python 3/2 when creating virtualenv.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-clear\r\nClears caches (pipenv, pip, and pip\\-tools).\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-v, \\-\\-verbose\r\nVerbose mode.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-pypi\\-mirror <pypi_mirror>\r\nSpecify a PyPI mirror.\r\n.UNINDENT\r\n.SS uninstall\r\n.sp\r\nUninstalls a provided package and removes it from Pipfile.\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\npipenv uninstall [OPTIONS] [PACKAGES]...\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\nOptions.INDENT 0.0\r\n.TP\r\n.B \\-\\-all\\-dev\r\nUninstall all package from [dev\\-packages].\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-all\r\nPurge all package(s) from virtualenv. Does not edit Pipfile.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-e, \\-\\-editable <editable>\r\nAn editable Python package URL or path, often to a VCS repository.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-skip\\-lock\r\nSkip locking mechanisms and use the Pipfile instead during operation.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-d, \\-\\-dev\r\nDeprecated (as it has no effect). May be removed in a future release.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-keep\\-outdated\r\nKeep out\\-dated dependencies from being updated in Pipfile.lock.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-pre\r\nAllow pre\\-releases.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-python <python>\r\nSpecify which version of Python virtualenv should use.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-three, \\-\\-two\r\nUse Python 3/2 when creating virtualenv.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-clear\r\nClears caches (pipenv, pip, and pip\\-tools).\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-v, \\-\\-verbose\r\nVerbose mode.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-pypi\\-mirror <pypi_mirror>\r\nSpecify a PyPI mirror.\r\n.UNINDENT\r\nArguments.INDENT 0.0\r\n.TP\r\n.B PACKAGES\r\nOptional argument(s)\r\n.UNINDENT\r\nEnvironment variables.INDENT 0.0\r\n.TP\r\n.B PIPENV_SKIP_LOCK\r\n.INDENT 7.0\r\n.INDENT 3.5\r\nProvide a default for \\fI\\%\\-\\-skip\\-lock\\fP\r\n.UNINDENT\r\n.UNINDENT\r\n.UNINDENT\r\n.SS update\r\n.sp\r\nRuns lock, then sync.\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\npipenv update [OPTIONS] [PACKAGES]...\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\nOptions.INDENT 0.0\r\n.TP\r\n.B \\-\\-bare\r\nMinimal output.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-outdated\r\nList out\\-of\\-date dependencies.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-dry\\-run\r\nList out\\-of\\-date dependencies.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-e, \\-\\-editable <editable>\r\nAn editable Python package URL or path, often to a VCS repository.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-ignore\\-pipfile\r\nIgnore Pipfile when installing, using the Pipfile.lock.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-selective\\-upgrade\r\nUpdate specified packages.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-r, \\-\\-requirements <requirements>\r\nImport a requirements.txt file.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-extra\\-index\\-url <extra_index_url>\r\nURLs to the extra PyPI compatible indexes to query for package look\\-ups.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-i, \\-\\-index <index>\r\nTarget PyPI\\-compatible package index url.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-sequential\r\nInstall dependencies one\\-at\\-a\\-time, instead of concurrently.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-d, \\-\\-dev\r\nInstall both develop and default packages\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-keep\\-outdated\r\nKeep out\\-dated dependencies from being updated in Pipfile.lock.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-pre\r\nAllow pre\\-releases.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-python <python>\r\nSpecify which version of Python virtualenv should use.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-three, \\-\\-two\r\nUse Python 3/2 when creating virtualenv.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-clear\r\nClears caches (pipenv, pip, and pip\\-tools).\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-v, \\-\\-verbose\r\nVerbose mode.\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B \\-\\-pypi\\-mirror <pypi_mirror>\r\nSpecify a PyPI mirror.\r\n.UNINDENT\r\nArguments.INDENT 0.0\r\n.TP\r\n.B PACKAGES\r\nOptional argument(s)\r\n.UNINDENT\r\nEnvironment variables.INDENT 0.0\r\n.TP\r\n.B PIP_EXTRA_INDEX_URL\r\n.INDENT 7.0\r\n.INDENT 3.5\r\nProvide a default for \\fI\\%\\-\\-extra\\-index\\-url\\fP\r\n.UNINDENT\r\n.UNINDENT\r\n.UNINDENT\r\n.INDENT 0.0\r\n.TP\r\n.B PIP_INDEX_URL\r\n.INDENT 7.0\r\n.INDENT 3.5\r\nProvide a default for \\fI\\%\\-i\\fP\r\n.UNINDENT\r\n.UNINDENT\r\n.UNINDENT\r\n.SS Frequently Encountered Pipenv Problems\r\n.sp\r\nPipenv is constantly being improved by volunteers, but is still a very young\r\nproject with limited resources, and has some quirks that needs to be dealt\r\nwith. We need everyone’s help (including yours!).\r\n.sp\r\nHere are some common questions people have using Pipenv. Please take a look\r\nbelow and see if they resolve your problem.\r\n.sp\r\n\\fBNOTE:\\fP\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n\\fBMake sure you’re running the newest Pipenv version first!\\fP\r\n.UNINDENT\r\n.UNINDENT\r\n.SS ☤ Your dependencies could not be resolved\r\n.sp\r\nMake sure your dependencies actually \\fIdo\\fP resolve. If you’re confident they\r\nare, you may need to clear your resolver cache. Run the following command:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\npipenv lock \\-\\-clear\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\nand try again.\r\n.sp\r\nIf this does not work, try manually deleting the whole cache directory. It is\r\nusually one of the following locations:\r\n.INDENT 0.0\r\n.IP \\(bu 2\r\n\\fB~/Library/Caches/pipenv\\fP (macOS)\r\n.IP \\(bu 2\r\n\\fB%LOCALAPPDATA%\\epipenv\\epipenv\\eCache\\fP (Windows)\r\n.IP \\(bu 2\r\n\\fB~/.cache/pipenv\\fP (other operating systems)\r\n.UNINDENT\r\n.sp\r\nPipenv does not install pre\\-releases (i.e. a version with an alpha/beta/etc.\r\nsuffix, such as \\fI1.0b1\\fP) by default. You will need to pass the \\fB\\-\\-pre\\fP flag\r\nin your command, or set\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n[pipenv]\r\nallow_prereleases = true\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\nin your Pipfile.\r\n.SS ☤ No module named <module name>\r\n.sp\r\nThis is usually a result of mixing Pipenv with system packages. We \\fIstrongly\\fP\r\nrecommend installing Pipenv in an isolated environment. Uninstall all existing\r\nPipenv installations, and see installing\\-pipenv to choose one of the\r\nrecommended way to install Pipenv instead.\r\n.SS ☤ My pyenv\\-installed Python is not found\r\n.sp\r\nMake sure you have \\fBPYENV_ROOT\\fP set correctly. Pipenv only supports CPython\r\ndistributions, with version name like \\fB3.6.4\\fP or similar.\r\n.SS ☤ Pipenv does not respect pyenv’s global and local Python versions\r\n.sp\r\nPipenv by default uses the Python it is installed against to create the\r\nvirtualenv. You can set the \\fB\\-\\-python\\fP option, or\r\n\\fB$PYENV_ROOT/shims/python\\fP to let it consult pyenv when choosing the\r\ninterpreter. See specifying_versions for more information.\r\n.sp\r\nIf you want Pipenv to automatically “do the right thing”, you can set the\r\nenvironment variable \\fBPIPENV_PYTHON\\fP to \\fB$PYENV_ROOT/shims/python\\fP\\&. This\r\nwill make Pipenv use pyenv’s active Python version to create virtual\r\nenvironments by default.\r\n.SS ☤ ValueError: unknown locale: UTF\\-8\r\n.sp\r\nmacOS has a bug in its locale detection that prevents us from detecting your\r\nshell encoding correctly. This can also be an issue on other systems if the\r\nlocale variables do not specify an encoding.\r\n.sp\r\nThe workaround is to set the following two environment variables to a standard\r\nlocalization format:\r\n.INDENT 0.0\r\n.IP \\(bu 2\r\n\\fBLC_ALL\\fP\r\n.IP \\(bu 2\r\n\\fBLANG\\fP\r\n.UNINDENT\r\n.sp\r\nFor Bash, for example, you can add the following to your \\fB~/.bash_profile\\fP:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\nexport LC_ALL=\\(aqen_US.UTF\\-8\\(aq\r\nexport LANG=\\(aqen_US.UTF\\-8\\(aq\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\nFor Zsh, the file to edit is \\fB~/.zshrc\\fP\\&.\r\n.sp\r\n\\fBNOTE:\\fP\r\n.INDENT 0.0\r\n.INDENT 3.5\r\nYou can change both the \\fBen_US\\fP and \\fBUTF\\-8\\fP part to the\r\nlanguage/locale and encoding you use.\r\n.UNINDENT\r\n.UNINDENT\r\n.SS ☤ /bin/pip: No such file or directory\r\n.sp\r\nThis may be related to your locale setting. See \\fI\\%☤ ValueError: unknown locale: UTF\\-8\\fP\r\nfor a possible solution.\r\n.SS ☤ \\fBshell\\fP does not show the virtualenv’s name in prompt\r\n.sp\r\nThis is intentional. You can do it yourself with either shell plugins, or\r\nclever \\fBPS1\\fP configuration. If you really want it back, use\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\npipenv shell \\-c\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\ninstead (not available on Windows).\r\n.SS ☤ Pipenv does not respect dependencies in setup.py\r\n.sp\r\nNo, it does not, intentionally. Pipfile and setup.py serve different purposes,\r\nand should not consider each other by default. See pipfile\\-vs\\-setuppy\r\nfor more information.\r\n.SS ☤ Using \\fBpipenv run\\fP in Supervisor program\r\n.sp\r\nWhen you configure a supervisor program\\(aqs \\fBcommand\\fP with \\fBpipenv run ...\\fP, you\r\nneed to set locale environment variables properly to make it work.\r\n.sp\r\nAdd this line under \\fB[supervisord]\\fP section in \\fB/etc/supervisor/supervisord.conf\\fP:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n[supervisord]\r\nenvironment=LC_ALL=\\(aqen_US.UTF\\-8\\(aq,LANG=\\(aqen_US.UTF\\-8\\(aq\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.SS ☤ An exception is raised during \\fBLocking dependencies…\\fP\r\n.sp\r\nRun \\fBpipenv lock \\-\\-clear\\fP and try again. The lock sequence caches results\r\nto speed up subsequent runs. The cache may contain faulty results if a bug\r\ncauses the format to corrupt, even after the bug is fixed. \\fB\\-\\-clear\\fP flushes\r\nthe cache, and therefore removes the bad results.\r\n.SH CONTRIBUTION GUIDES\r\n.SS Development Philosophy\r\n.sp\r\nPipenv is an open but opinionated tool, created by an open but opinionated developer.\r\n.SS Management Style\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n\\fBTo be updated (as of March 2020)\\fP\\&.\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\n\\fI\\%Kenneth Reitz\\fP is the BDFL. He has final say in any decision related to the Pipenv project. Kenneth is responsible for the direction and form of the library, as well as its presentation. In addition to making decisions based on technical merit, he is responsible for making decisions based on the development philosophy of Pipenv.\r\n.sp\r\n\\fI\\%Dan Ryan\\fP, \\fI\\%Tzu\\-ping Chung\\fP, and \\fI\\%Nate Prewitt\\fP are the core contributors.\r\nThey are responsible for triaging bug reports, reviewing pull requests and ensuring that Kenneth is kept up to speed with developments around the library.\r\nThe day\\-to\\-day managing of the project is done by the core contributors. They are responsible for making judgments about whether or not a feature request is\r\nlikely to be accepted by Kenneth.\r\n.SS Values\r\n.INDENT 0.0\r\n.IP \\(bu 2\r\nSimplicity is always better than functionality.\r\n.IP \\(bu 2\r\nListen to everyone, then disregard it.\r\n.IP \\(bu 2\r\nThe API is all that matters. Everything else is secondary.\r\n.IP \\(bu 2\r\nFit the 90% use\\-case. Ignore the nay\\-sayers.\r\n.UNINDENT\r\n.SS Contributing to Pipenv\r\n.sp\r\nIf you\\(aqre reading this, you\\(aqre probably interested in contributing to Pipenv.\r\nThank you very much! Open source projects live\\-and\\-die based on the support\r\nthey receive from others, and the fact that you\\(aqre even considering\r\ncontributing to the Pipenv project is \\fIvery\\fP generous of you.\r\n.sp\r\nThis document lays out guidelines and advice for contributing to this project.\r\nIf you\\(aqre thinking of contributing, please start by reading this document and\r\ngetting a feel for how contributing to this project works. If you have any\r\nquestions, feel free to reach out to either \\fI\\%Dan Ryan\\fP, \\fI\\%Tzu\\-ping Chung\\fP,\r\nor \\fI\\%Nate Prewitt\\fP, the primary maintainers.\r\n.sp\r\nThe guide is split into sections based on the type of contribution you\\(aqre\r\nthinking of making, with a section that covers general guidelines for all\r\ncontributors.\r\n.SS General Guidelines\r\n.SS Be Cordial\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n\\fBBe cordial or be on your way\\fP\\&. \\fI—Kenneth Reitz\\fP\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\nPipenv has one very important rule governing all forms of contribution,\r\nincluding reporting bugs or requesting features. This golden rule is\r\n\"\\fI\\%be cordial or be on your way\\fP\".\r\n.sp\r\n\\fBAll contributions are welcome\\fP, as long as\r\neveryone involved is treated with respect.\r\n.SS Get Early Feedback\r\n.sp\r\nIf you are contributing, do not feel the need to sit on your contribution until\r\nit is perfectly polished and complete. It helps everyone involved for you to\r\nseek feedback as early as you possibly can. Submitting an early, unfinished\r\nversion of your contribution for feedback in no way prejudices your chances of\r\ngetting that contribution accepted, and can save you from putting a lot of work\r\ninto a contribution that is not suitable for the project.\r\n.SS Contribution Suitability\r\n.sp\r\nOur project maintainers have the last word on whether or not a contribution is\r\nsuitable for Pipenv. All contributions will be considered carefully, but from\r\ntime to time, contributions will be rejected because they do not suit the\r\ncurrent goals or needs of the project.\r\n.sp\r\nIf your contribution is rejected, don\\(aqt despair! As long as you followed these\r\nguidelines, you will have a much better chance of getting your next\r\ncontribution accepted.\r\n.SS Questions\r\n.sp\r\nThe GitHub issue tracker is for \\fIbug reports\\fP and \\fIfeature requests\\fP\\&. Please do\r\nnot use it to ask questions about how to use Pipenv. These questions should\r\ninstead be directed to \\fI\\%Stack Overflow\\fP\\&. Make sure that your question is tagged\r\nwith the \\fBpipenv\\fP tag when asking it on Stack Overflow, to ensure that it is\r\nanswered promptly and accurately.\r\n.SS Code Contributions\r\n.SS Steps for Submitting Code\r\n.sp\r\nWhen contributing code, you\\(aqll want to follow this checklist:\r\n.INDENT 0.0\r\n.IP 1. 3\r\nUnderstand our \\fI\\%development philosophy\\fP\\&.\r\n.IP 2. 3\r\nFork the repository on GitHub.\r\n.IP 3. 3\r\nSet up your \\fI\\%Development Setup\\fP\r\n.IP 4. 3\r\nRun the tests (\\fI\\%Testing\\fP) to confirm they all pass on your system.\r\nIf they don\\(aqt, you\\(aqll need to investigate why they fail. If you\\(aqre unable\r\nto diagnose this yourself, raise it as a bug report by following the guidelines\r\nin this document: \\fI\\%Bug Reports\\fP\\&.\r\n.IP 5. 3\r\nWrite tests that demonstrate your bug or feature. Ensure that they fail.\r\n.IP 6. 3\r\nMake your change.\r\n.IP 7. 3\r\nRun the entire test suite again, confirming that all tests pass \\fIincluding\r\nthe ones you just added\\fP\\&.\r\n.IP 8. 3\r\nSend a GitHub Pull Request to the main repository\\(aqs \\fBmaster\\fP branch.\r\nGitHub Pull Requests are the expected method of code collaboration on this\r\nproject.\r\n.UNINDENT\r\n.sp\r\nThe following sub\\-sections go into more detail on some of the points above.\r\n.SS Development Setup\r\n.sp\r\nTo get your development environment setup, run:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\npip install \\-e .\r\npipenv install \\-\\-dev\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\nThis will install the repository version of Pipenv and then install the development\r\ndependencies. Once that has completed, you can start developing.\r\n.sp\r\nThe repository version of Pipenv must be installed over other global versions to\r\nresolve conflicts with the \\fBpipenv\\fP folder being implicitly added to \\fBsys.path\\fP\\&.\r\nSee \\fI\\%pypa/pipenv#2557\\fP for more details.\r\n.SS Testing\r\n.sp\r\nTests are written in \\fBpytest\\fP style and can be run very simply:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\npytest\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\nThis will run all Pipenv tests, which can take awhile. To run a subset of the\r\ntests, the standard pytest filters are available, such as:\r\n.INDENT 0.0\r\n.IP \\(bu 2\r\nprovide a directory or file: \\fBpytest tests/unit\\fP or \\fBpytest tests/unit/test_cmdparse.py\\fP\r\n.IP \\(bu 2\r\nprovide a keyword expression: \\fBpytest \\-k test_lock_editable_vcs_without_install\\fP\r\n.IP \\(bu 2\r\nprovide a nodeid: \\fBpytest tests/unit/test_cmdparse.py::test_parse\\fP\r\n.IP \\(bu 2\r\nprovide a test marker: \\fBpytest \\-m lock\\fP\r\n.UNINDENT\r\n.SS Code Review\r\n.sp\r\nContributions will not be merged until they have been code reviewed. You should\r\nimplement any code review feedback unless you strongly object to it. In the\r\nevent that you object to the code review feedback, you should make your case\r\nclearly and calmly. If, after doing so, the feedback is judged to still apply,\r\nyou must either apply the feedback or withdraw your contribution.\r\n.SS Package Index\r\n.sp\r\nTo speed up testing, tests that rely on a package index for locking and\r\ninstalling use a local server that contains vendored packages in the\r\n\\fBtests/pypi\\fP directory. Each vendored package should have it\\(aqs own folder\r\ncontaining the necessary releases. When adding a release for a package, it is\r\neasiest to use either the \\fB\\&.tar.gz\\fP or universal wheels (ex: \\fBpy2.py3\\-none\\fP). If\r\na \\fB\\&.tar.gz\\fP or universal wheel is not available, add wheels for all available\r\narchitectures and platforms.\r\n.SS Documentation Contributions\r\n.sp\r\nDocumentation improvements are always welcome! The documentation files live in\r\nthe \\fBdocs/\\fP directory of the codebase. They\\(aqre written in\r\n\\fI\\%reStructuredText\\fP, and use \\fI\\%Sphinx\\fP to generate the full suite of\r\ndocumentation.\r\n.sp\r\nWhen contributing documentation, please do your best to follow the style of the\r\ndocumentation files. This means a soft\\-limit of 79 characters wide in your text\r\nfiles and a semi\\-formal, yet friendly and approachable, prose style.\r\n.sp\r\nWhen presenting Python code, use single\\-quoted strings (\\fB\\(aqhello\\(aq\\fP instead of\r\n\\fB\"hello\"\\fP).\r\n.SS Bug Reports\r\n.sp\r\nBug reports are hugely important! They are recorded as \\fI\\%GitHub issues\\fP\\&. Please\r\nbe aware of the following things when filing bug reports:\r\n.INDENT 0.0\r\n.IP 1. 3\r\nAvoid raising duplicate issues. \\fIPlease\\fP use the GitHub issue search feature\r\nto check whether your bug report or feature request has been mentioned in\r\nthe past. Duplicate bug reports and feature requests are a huge maintenance\r\nburden on the limited resources of the project. If it is clear from your\r\nreport that you would have struggled to find the original, that\\(aqs okay, but\r\nif searching for a selection of words in your issue title would have found\r\nthe duplicate then the issue will likely be closed extremely abruptly.\r\n.IP 2. 3\r\nWhen filing bug reports about exceptions or tracebacks, please include the\r\n\\fIcomplete\\fP traceback. Partial tracebacks, or just the exception text, are\r\nnot helpful. Issues that do not contain complete tracebacks may be closed\r\nwithout warning.\r\n.IP 3. 3\r\nMake sure you provide a suitable amount of information to work with. This\r\nmeans you should provide:\r\n.INDENT 3.0\r\n.IP \\(bu 2\r\nGuidance on \\fBhow to reproduce the issue\\fP\\&. Ideally, this should be a\r\n\\fIsmall\\fP code sample that can be run immediately by the maintainers.\r\nFailing that, let us know what you\\(aqre doing, how often it happens, what\r\nenvironment you\\(aqre using, etc. Be thorough: it prevents us needing to ask\r\nfurther questions.\r\n.IP \\(bu 2\r\nTell us \\fBwhat you expected to happen\\fP\\&. When we run your example code,\r\nwhat are we expecting to happen? What does \"success\" look like for your\r\ncode?\r\n.IP \\(bu 2\r\nTell us \\fBwhat actually happens\\fP\\&. It\\(aqs not helpful for you to say \"it\r\ndoesn\\(aqt work\" or \"it fails\". Tell us \\fIhow\\fP it fails: do you get an\r\nexception? A hang? The packages installed seem incorrect?\r\nHow was the actual result different from your expected result?\r\n.IP \\(bu 2\r\nTell us \\fBwhat version of Pipenv you\\(aqre using\\fP, and\r\n\\fBhow you installed it\\fP\\&. Different versions of Pipenv behave\r\ndifferently and have different bugs, and some distributors of Pipenv\r\nship patches on top of the code we supply.\r\n.UNINDENT\r\n.sp\r\nIf you do not provide all of these things, it will take us much longer to\r\nfix your problem. If we ask you to clarify these and you never respond, we\r\nwill close your issue without fixing it.\r\n.UNINDENT\r\n.SS Run the tests\r\n.sp\r\nThree ways of running the tests are as follows:\r\n.INDENT 0.0\r\n.IP 1. 3\r\n\\fBmake test\\fP (which uses \\fBdocker\\fP)\r\n.IP 2. 3\r\n\\fB\\&./run\\-tests.sh\\fP or \\fBrun\\-tests.bat\\fP\r\n.IP 3. 3\r\nUsing pipenv:\r\n.UNINDENT\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n$ git clone https://github.com/pypa/pipenv.git\r\n$ cd pipenv\r\n$ git submodule sync && git submodule update \\-\\-init \\-\\-recursive\r\n$ pipenv install \\-\\-dev\r\n$ pipenv run pytest\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.sp\r\nFor the last two, it is important that your environment is setup correctly, and\r\nthis may take some work, for example, on a specific Mac installation, the following\r\nsteps may be needed:\r\n.INDENT 0.0\r\n.INDENT 3.5\r\n.sp\r\n.nf\r\n.ft C\r\n# Make sure the tests can access github\r\nif [ \"$SSH_AGENT_PID\" = \"\" ]\r\nthen\r\n   eval \\(gassh\\-agent\\(ga\r\n   ssh\\-add\r\nfi\r\n\r\n# Use unix like utilities, installed with brew,\r\n# e.g. brew install coreutils\r\nfor d in /usr/local/opt/*/libexec/gnubin /usr/local/opt/python/libexec/bin\r\ndo\r\n  [[ \":$PATH:\" != *\":$d:\"* ]] && PATH=\"$d:${PATH}\"\r\ndone\r\n\r\nexport PATH\r\n\r\n# PIP_FIND_LINKS currently breaks test_uninstall.py\r\nunset PIP_FIND_LINKS\r\n.ft P\r\n.fi\r\n.UNINDENT\r\n.UNINDENT\r\n.INDENT 0.0\r\n.IP \\(bu 2\r\ngenindex\r\n.IP \\(bu 2\r\nmodindex\r\n.IP \\(bu 2\r\nsearch\r\n.UNINDENT\r\n.SH AUTHOR\r\nPython Packaging Authority\r\n.SH COPYRIGHT\r\n2020. A project founded by <a href=\"http://kennethreitz.com/pages/open-projects.html\">Kenneth Reitz</a>\r\n.\\\" Generated by docutils manpage writer.\r\n.\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- env/Lib/site-packages/pipenv/pipenv.1	(revision 7de091c5b19e7b06e80c151f7100df6d0f893820)
+++ env/Lib/site-packages/pipenv/pipenv.1	(date 1591098437580)
@@ -1,6 +1,6 @@
 .\" Man page generated from reStructuredText.
 .
-.TH "PIPENV" "1" "May 28, 2020" "2020.5.28" "pipenv"
+.TH "PIPENV" "1" "Jun 02, 2020" "2020.6.2" "pipenv"
 .SH NAME
 pipenv \- pipenv Documentation
 .
@@ -396,6 +396,53 @@
 .sp
 Congratulations, you now know how to install and use Python packages! ✨ 🍰 ✨
 .SS Release and Version History
+.SS 2020.6.2 (2020\-06\-02)
+.SS Features & Improvements
+.INDENT 0.0
+.IP \(bu 2
+Pipenv will now detect existing \fBvenv\fP and \fBvirtualenv\fP based virtual environments more robustly.  \fI\%#4276\fP
+.UNINDENT
+.SS Bug Fixes
+.INDENT 0.0
+.IP \(bu 2
+\fB+\fP signs in URL authentication fragments will no longer be incorrectly replaced with space ( \(ga\(ga \(ga\(ga ) characters.  \fI\%#4271\fP
+.IP \(bu 2
+Fixed a regression which caused Pipenv to fail when running under \fB/\fP\&.  \fI\%#4273\fP
+.IP \(bu 2
+\fBsetup.py\fP files with \fBversion\fP variables read from \fBos.environ\fP are now able to be parsed successfully.  \fI\%#4274\fP
+.IP \(bu 2
+Fixed a bug which caused Pipenv to fail to install packages in a virtual environment if those packages were already present in the system global environment.  \fI\%#4276\fP
+.IP \(bu 2
+Fix a bug that caused non\-specific versions to be pinned in \fBPipfile.lock\fP\&.  \fI\%#4278\fP
+.IP \(bu 2
+Corrected a missing exception import and invalid function call invocations in \fBpipenv.cli.command\fP\&.  \fI\%#4286\fP
+.IP \(bu 2
+Fixed an issue with resolving packages with names defined by function calls in \fBsetup.py\fP\&.  \fI\%#4292\fP
+.IP \(bu 2
+Fixed a regression with installing the current directory, or \fB\&.\fP, inside a \fBvenv\fP based virtual environment.  \fI\%#4295\fP
+.IP \(bu 2
+Fixed a bug with the discovery of python paths on Windows which could prevent installation of environments during \fBpipenv install\fP\&.  \fI\%#4296\fP
+.IP \(bu 2
+Fixed an issue in the \fBrequirementslib\fP AST parser which prevented parsing of \fBsetup.py\fP files for dependency metadata.  \fI\%#4298\fP
+.IP \(bu 2
+Fix a bug where Pipenv doesn\(aqt realize the session is interactive  \fI\%#4305\fP
+.UNINDENT
+.SS Vendored Libraries
+.INDENT 0.0
+.IP \(bu 2
+Updated requirementslib to version \fB1.5.11\fP\&.  \fI\%#4292\fP
+.IP \(bu 2
+.INDENT 2.0
+.TP
+.B Updated vendored dependencies:
+.INDENT 7.0
+.IP \(bu 2
+\fBpythonfinder\fP: \fB1.2.2\fP => \fB1.2.4\fP
+.IP \(bu 2
+\fBrequirementslib\fP: \fB1.5.9\fP => \fB1.5.10\fP  \fI\%#4302\fP
+.UNINDENT
+.UNINDENT
+.UNINDENT
 .SS 2020.5.28 (2020\-05\-28)
 .SS Features & Improvements
 .INDENT 0.0
